{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Foreword In the I.T. world of today, robust and secure applications are becoming more and more important. Many business processes no longer work without I.T. and the dependence of businesses on their I.T. has grown tremendously, meaning we need robust and maintainable applications. An important requirement is to have standards and guidelines, which make it possible to maintain source code created by a number of people quickly and easily. This forms the basis of well functioning off- or on-shoring strategy, as it allows quality assurance to be carried out efficiently at the source. Good standards and guidelines are based on the wealth of experience and knowledge gained from past (and future?) problems, such as those, which can arise in a cloud environment, for example. Urban Lankes Chairman biGENIUS AG The Oracle Database Developer community is made stronger by resources freely shared by experts around the world, such as the Trivadis Coding Guidelines. If you have not yet adopted standards for writing SQL and PL/SQL in your applications, this is a great place to start. Steven Feuerstein Senior Advisor Insum Solutions Coding Guidelines are a crucial part of software development. It is a matter of fact, that code is more often read than written \u2013 therefore we should take efforts to ease the work of the reader, which is not necessarily the author. I am convinced that this standard may be a good starting point for your own guidelines. Roger Troller Senior Consultant finnova AG Bankware License The Trivadis PL/SQL & SQL Coding Guidelines are licensed under the Apache License, Version 2.0. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 . Trademarks All terms that are known trademarks or service marks have been capitalized. All trademarks are the property of their respective owners. Disclaimer The authors and publisher shall have neither liability nor responsibility to any person or entity with respect to the loss or damages arising from the information contained in this work. This work may include inaccuracies or typographical errors and solely represent the opinions of the authors. Changes are periodically made to this document without notice. The authors reserve the right to revise this document at any time without notice. Revision History The first version of these guidelines was compiled by Roger Troller on March 17, 2009. J\u00f6rn Kulessa, Daniela Reiner, Richard Bushnell, Andreas Flubacher and Thomas Mauch helped Roger complete version 1.2 until August 21, 2009. This was the first GA version. The handy printed version in A5 format was distributed free of charge at the DOAG Annual Conference and on other occasions. Since then Roger updated the guidelines regularily. Philipp Salvisberg was involved in the review process for version 3.0 which was a major update. Philipp took the lead, after Roger left Trivadis in 2016. In 2020 Kim Berg Hansen started handling guidelines maintenance, letting Philipp concentrate on the related Trivadis db* CODECOP tool suite. After Kim left in September 2022, Philipp took over again until August 2024. Since July, 7 2018 these guidelines are hosted on GitHub. Ready to be enhanced by the community and forked to fit specific needs. On https://github.com/Trivadis/plsql-and-sql-coding-guidelines/releases you find the release information for every version since 1.2.","title":"About"},{"location":"#about","text":"","title":"About"},{"location":"#foreword","text":"In the I.T. world of today, robust and secure applications are becoming more and more important. Many business processes no longer work without I.T. and the dependence of businesses on their I.T. has grown tremendously, meaning we need robust and maintainable applications. An important requirement is to have standards and guidelines, which make it possible to maintain source code created by a number of people quickly and easily. This forms the basis of well functioning off- or on-shoring strategy, as it allows quality assurance to be carried out efficiently at the source. Good standards and guidelines are based on the wealth of experience and knowledge gained from past (and future?) problems, such as those, which can arise in a cloud environment, for example. Urban Lankes Chairman biGENIUS AG The Oracle Database Developer community is made stronger by resources freely shared by experts around the world, such as the Trivadis Coding Guidelines. If you have not yet adopted standards for writing SQL and PL/SQL in your applications, this is a great place to start. Steven Feuerstein Senior Advisor Insum Solutions Coding Guidelines are a crucial part of software development. It is a matter of fact, that code is more often read than written \u2013 therefore we should take efforts to ease the work of the reader, which is not necessarily the author. I am convinced that this standard may be a good starting point for your own guidelines. Roger Troller Senior Consultant finnova AG Bankware","title":"Foreword"},{"location":"#license","text":"The Trivadis PL/SQL & SQL Coding Guidelines are licensed under the Apache License, Version 2.0. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 .","title":"License"},{"location":"#trademarks","text":"All terms that are known trademarks or service marks have been capitalized. All trademarks are the property of their respective owners.","title":"Trademarks"},{"location":"#disclaimer","text":"The authors and publisher shall have neither liability nor responsibility to any person or entity with respect to the loss or damages arising from the information contained in this work. This work may include inaccuracies or typographical errors and solely represent the opinions of the authors. Changes are periodically made to this document without notice. The authors reserve the right to revise this document at any time without notice.","title":"Disclaimer"},{"location":"#revision-history","text":"The first version of these guidelines was compiled by Roger Troller on March 17, 2009. J\u00f6rn Kulessa, Daniela Reiner, Richard Bushnell, Andreas Flubacher and Thomas Mauch helped Roger complete version 1.2 until August 21, 2009. This was the first GA version. The handy printed version in A5 format was distributed free of charge at the DOAG Annual Conference and on other occasions. Since then Roger updated the guidelines regularily. Philipp Salvisberg was involved in the review process for version 3.0 which was a major update. Philipp took the lead, after Roger left Trivadis in 2016. In 2020 Kim Berg Hansen started handling guidelines maintenance, letting Philipp concentrate on the related Trivadis db* CODECOP tool suite. After Kim left in September 2022, Philipp took over again until August 2024. Since July, 7 2018 these guidelines are hosted on GitHub. Ready to be enhanced by the community and forked to fit specific needs. On https://github.com/Trivadis/plsql-and-sql-coding-guidelines/releases you find the release information for every version since 1.2.","title":"Revision History"},{"location":"1-introduction/introduction/","text":"Introduction This document describes rules and recommendations for developing applications using the PL/SQL & SQL Language. Scope This document applies to the PL/SQL and SQL language as used within Oracle Databases and tools, which access Oracle Databases version 11g Release 2 or later. Document Conventions SQALE (Software Quality Assessment based on Lifecycle Expectations) is a method to support the evaluation of a software application source code. It is a generic method, independent of the language and source code analysis tools. SQALE characteristics and subcharacteristics Characteristic Description and Subcharacteristics Changeability The capability of the software product to enable a specified modification to be implemented. Architecture related changeability Logic related changeability Data related changeability Efficiency The capability of the software product to provide appropriate performance, relative to the amount of resources used, under stated conditions. Memory use Processor use Network use Maintainability The capability of the software product to be modified. Modifications may include corrections, improvements or adaptation of the software to changes in environment, and in requirements and functional specifications. Understandability Readability Portability The capability of the software product to be transferred from one environment to another. Compiler related portability Hardware related portability Language related portability OS related portability Software related portability Time zone related portability. Reliability The capability of the software product to maintain a specified level of performance when used under specified conditions. Architecture related reliability Data related reliability Exception handling Fault tolerance Instruction related reliability Logic related reliability Resource related reliability Synchronization related reliability Unit tests coverage. Reusability The capability of the software product to be reused within the development process. Modularity Transportability. Security The capability of the software product to protect information and data so that unauthorized persons or systems cannot read or modify them and authorized persons or systems are not denied access to them. API abuse Errors (e.g. leaving a system in a vulnerable state) Input validatation and representation Security features. Testability The capability of the software product to enable modified software to be validated. Integration level testability Unit level testability. Severity of the rule Blocker Will or may result in a bug; for example, an incorrect result or a runtime exception. Critical Will have a high/direct impact on the maintenance cost. May have an impact on runtime behavior; for example, incomplete audit data or slower runtime performance. Major Will have a medium/potential impact on the maintenance cost. May have an impact on runtime behavior; for example, higher memory consumption. Minor Will have a low impact on the maintenance cost. No impact on the runtime behavior. Info Very low impact; it is just a remediation cost report. No impact on runtime behavior. For example, a NOSONAR marker comment. Keywords used Keyword Meaning Always Emphasizes this rule must be enforced. Never Emphasizes this action must not happen. Avoid Emphasizes that the action should be prevented, but some exceptions may exist. Try Emphasizes that the rule should be attempted whenever possible and appropriate. Example Precedes text used to illustrate a rule or a recommendation. Reason Explains the thoughts and purpose behind a rule or a recommendation. Restriction Describes the circumstances to be fulfilled to make use of a rule. Validator support The tool db* CODECOP (see the \"Tool Support\" chapter) cannot support all the guidelines in this document. Those guidelines that are not supported by db* CODECOP validators are marked like this: Unsupported in db* CODECOP Validators Reason why the specific guideline is not supported by the validators. The db* CODECOP repository documents the details of validator limitations . Why are standards important For a machine executing a program, code formatting is of no importance. However, for the human eye, well-formatted code is much easier to read. Modern tools can help to implement format and coding rules. Implementing formatting and coding standards has the following advantages for PL/SQL development: Well-formatted code is easier to read, analyze and maintain (not only for the author but also for other developers). The developers do not have to define their own guidelines - it is already defined. The code has a structure that makes it easier to avoid making errors. The code is more efficient concerning performance and organization of the whole application. The code is more modular and thus easier to use for other applications. We have other standards This document only defines possible standards. These standards are not written in stone, but are meant as guidelines. If standards already exist, and they are different from those in this document, it makes no sense to change them. We do not agree with all your standards There are basically two types of standards. Non-controversial These standards make sense. There is no reason not to follow them. An example of this category is G-2150 : Avoid comparisons with NULL value, consider using IS [NOT] NULL. Controversial Almost every rule/guideline falls into this category. An example of this category is 3 space indention . - Why not 2 or 4 or even 8? Why not use tabs? You can argue in favor of all these options. In most cases it does not really matter which option you choose. Being consistent is more important. In this case it will make the code easier to read. For very controversial rules, we have started to include the reasoning either as a footnote or directly in the text. Usually it is not helpful to open an issue on GitHub to request to change a highly controversial rule such as the one mentioned. For example, use 2 spaces instead of 3 spaces for an indentation. This leads to a discussion where the people in favor of 4 spaces start to argument as well. There is no right or wrong here. You just have to agree on a standard. More effective is to fork this repository and amend the standards to fit your needs/expectations.","title":"Introduction"},{"location":"1-introduction/introduction/#introduction","text":"This document describes rules and recommendations for developing applications using the PL/SQL & SQL Language.","title":"Introduction"},{"location":"1-introduction/introduction/#scope","text":"This document applies to the PL/SQL and SQL language as used within Oracle Databases and tools, which access Oracle Databases version 11g Release 2 or later.","title":"Scope"},{"location":"1-introduction/introduction/#document-conventions","text":"SQALE (Software Quality Assessment based on Lifecycle Expectations) is a method to support the evaluation of a software application source code. It is a generic method, independent of the language and source code analysis tools.","title":"Document Conventions"},{"location":"1-introduction/introduction/#sqale-characteristics-and-subcharacteristics","text":"Characteristic Description and Subcharacteristics Changeability The capability of the software product to enable a specified modification to be implemented. Architecture related changeability Logic related changeability Data related changeability Efficiency The capability of the software product to provide appropriate performance, relative to the amount of resources used, under stated conditions. Memory use Processor use Network use Maintainability The capability of the software product to be modified. Modifications may include corrections, improvements or adaptation of the software to changes in environment, and in requirements and functional specifications. Understandability Readability Portability The capability of the software product to be transferred from one environment to another. Compiler related portability Hardware related portability Language related portability OS related portability Software related portability Time zone related portability. Reliability The capability of the software product to maintain a specified level of performance when used under specified conditions. Architecture related reliability Data related reliability Exception handling Fault tolerance Instruction related reliability Logic related reliability Resource related reliability Synchronization related reliability Unit tests coverage. Reusability The capability of the software product to be reused within the development process. Modularity Transportability. Security The capability of the software product to protect information and data so that unauthorized persons or systems cannot read or modify them and authorized persons or systems are not denied access to them. API abuse Errors (e.g. leaving a system in a vulnerable state) Input validatation and representation Security features. Testability The capability of the software product to enable modified software to be validated. Integration level testability Unit level testability.","title":"SQALE characteristics and subcharacteristics"},{"location":"1-introduction/introduction/#severity-of-the-rule","text":"Blocker Will or may result in a bug; for example, an incorrect result or a runtime exception. Critical Will have a high/direct impact on the maintenance cost. May have an impact on runtime behavior; for example, incomplete audit data or slower runtime performance. Major Will have a medium/potential impact on the maintenance cost. May have an impact on runtime behavior; for example, higher memory consumption. Minor Will have a low impact on the maintenance cost. No impact on the runtime behavior. Info Very low impact; it is just a remediation cost report. No impact on runtime behavior. For example, a NOSONAR marker comment.","title":"Severity of the rule"},{"location":"1-introduction/introduction/#keywords-used","text":"Keyword Meaning Always Emphasizes this rule must be enforced. Never Emphasizes this action must not happen. Avoid Emphasizes that the action should be prevented, but some exceptions may exist. Try Emphasizes that the rule should be attempted whenever possible and appropriate. Example Precedes text used to illustrate a rule or a recommendation. Reason Explains the thoughts and purpose behind a rule or a recommendation. Restriction Describes the circumstances to be fulfilled to make use of a rule.","title":"Keywords used"},{"location":"1-introduction/introduction/#validator-support","text":"The tool db* CODECOP (see the \"Tool Support\" chapter) cannot support all the guidelines in this document. Those guidelines that are not supported by db* CODECOP validators are marked like this: Unsupported in db* CODECOP Validators Reason why the specific guideline is not supported by the validators. The db* CODECOP repository documents the details of validator limitations .","title":"Validator support"},{"location":"1-introduction/introduction/#why-are-standards-important","text":"For a machine executing a program, code formatting is of no importance. However, for the human eye, well-formatted code is much easier to read. Modern tools can help to implement format and coding rules. Implementing formatting and coding standards has the following advantages for PL/SQL development: Well-formatted code is easier to read, analyze and maintain (not only for the author but also for other developers). The developers do not have to define their own guidelines - it is already defined. The code has a structure that makes it easier to avoid making errors. The code is more efficient concerning performance and organization of the whole application. The code is more modular and thus easier to use for other applications.","title":"Why are standards important"},{"location":"1-introduction/introduction/#we-have-other-standards","text":"This document only defines possible standards. These standards are not written in stone, but are meant as guidelines. If standards already exist, and they are different from those in this document, it makes no sense to change them.","title":"We have other standards"},{"location":"1-introduction/introduction/#we-do-not-agree-with-all-your-standards","text":"There are basically two types of standards. Non-controversial These standards make sense. There is no reason not to follow them. An example of this category is G-2150 : Avoid comparisons with NULL value, consider using IS [NOT] NULL. Controversial Almost every rule/guideline falls into this category. An example of this category is 3 space indention . - Why not 2 or 4 or even 8? Why not use tabs? You can argue in favor of all these options. In most cases it does not really matter which option you choose. Being consistent is more important. In this case it will make the code easier to read. For very controversial rules, we have started to include the reasoning either as a footnote or directly in the text. Usually it is not helpful to open an issue on GitHub to request to change a highly controversial rule such as the one mentioned. For example, use 2 spaces instead of 3 spaces for an indentation. This leads to a discussion where the people in favor of 4 spaces start to argument as well. There is no right or wrong here. You just have to agree on a standard. More effective is to fork this repository and amend the standards to fit your needs/expectations.","title":"We do not agree with all your standards"},{"location":"2-naming-conventions/naming-conventions/","text":"Naming Conventions General Guidelines Never use names with a leading numeric character. Always choose meaningful and specific names. Avoid using abbreviations unless the full name is excessively long. Avoid long abbreviations. Abbreviations should be shorter than 5 characters. Any abbreviations must be widely known and accepted. Create a glossary with all accepted abbreviations. Never use keywords as names. A list of keywords may be found in the dictionary view v$reserved_words . Avoid adding redundant or meaningless prefixes and suffixes to identifiers. Example: create table emp_table . Always use one spoken language (e.g. English, German, French) for all objects in your application. Always use the same names for elements with the same meaning. Naming Conventions for PL/SQL In general, the Oracle Database is not case sensitive with names. A variable named personname is equal to one named PersonName, as well as to one named PERSONNAME. Some products (e.g. TMDA by Trivadis, APEX, OWB) put each name within double quotes (\") so the Oracle Database will treat these names to be case sensitive. Using case sensitive variable names force developers to use double quotes for each reference to the variable. Our recommendation is to write all names in lowercase and to avoid double quoted identifiers. A widely used convention is to follow a {prefix}variablecontent{suffix} pattern. The following table shows a possible set of naming conventions. Identifier Prefix Suffix Example Global Variable g_ g_version Local Variable l_ l_version Cursor c_ c_employees Record r_ r_employee Array / Table t_ t_employees Object o_ o_employee Cursor Parameter p_ p_empno In Parameter in_ in_empno Out Parameter out_ out_ename In/Out Parameter io_ io_employee Record Type Definitions r_ _type r_employee_type Array/Table Type Definitions t_ _type t_employees_type Exception e_ e_employee_exists Constants co_ co_empno Subtypes _type big_string_type Database Object Naming Conventions Never enclose object names (table names, column names, etc.) in double quotes to enforce mixed case or lower case object names in the data dictionary. Collection Type A collection type should include the name of the collected objects in their name. Furthermore, they should have the suffix _ct to identify it as a collection. Optionally prefixed by a project abbreviation. Examples: employees_ct orders_ct Column Singular name of what is stored in the column (unless the column data type is a collection, in this case you use plural 1 names) Add a comment to the database dictionary for every column. Check Constraint Table name or table abbreviation followed by the column and/or role of the check constraint, a _ck and an optional number suffix. Examples: employees_salary_min_ck orders_mode_ck DML / Instead of Trigger Choose a naming convention that includes: either the name of the object the trigger is added to, any of the triggering events: _br_iud for Before Row on Insert, Update and Delete _io_id for Instead of Insert and Delete or the name of the object the trigger is added to, the activity done by the trigger, the suffix _trg Examples: employees_br_iud orders_audit_trg orders_journal_trg Foreign Key Constraint Table abbreviation followed by referenced table abbreviation followed by a _fk and an optional number suffix. Examples: empl_dept_fk sct_icmd_ic_fk1 Function Name is built from a verb followed by a noun in general. Nevertheless, it is not sensible to call a function get_... as a function always gets something. The name of the function should answer the question \u201cWhat is the outcome of the function?\u201d Optionally prefixed by a project abbreviation. Example: employee_by_id If more than one function provides the same outcome, you have to be more specific with the name. Index Indexes serving a constraint (primary, unique or foreign key) are named accordingly. Other indexes should have the name of the table and columns (or their purpose) in their name and should also have _idx as a suffix. Object Type The name of an object type is built by its content (singular) followed by a _ot suffix. Optionally prefixed by a project abbreviation. Example: employee_ot Package Name is built from the content that is contained within the package. Optionally prefixed by a project abbreviation. Examples: employees_api - API for the employee table logging_up - Utilities including logging support Primary Key Constraint Table name or table abbreviation followed by the suffix _pk . Examples: employees_pk departments_pk sct_contracts_pk Procedure Name is built from a verb followed by a noun. The name of the procedure should answer the question \u201cWhat is done?\u201d Procedures and functions are often named with underscores between words because some editors write all letters in uppercase in the object tree, so it is difficult to read them. Optionally prefixed by a project abbreviation. Examples: calculate_salary set_hiredate check_order_state Sequence Name is built from the table name (or its abbreviation) the sequence serves as primary key generator and the suffix _seq or the purpose of the sequence followed by a _seq . Optionally prefixed by a project abbreviation. Examples: employees_seq order_number_seq Synonym Synonyms should be used to address an object in a foreign schema rather than to rename an object. Therefore, synonyms should share the name with the referenced object. System Trigger Name of the event the trigger is based on. Activity done by the trigger Suffix _trg Examples: ddl_audit_trg logon_trg Table Plural 1 name of what is contained in the table (unless the table is designed to always hold one row only \u2013 then you should use a singular name). Suffixed by _eb when protected by an editioning view. Add a comment to the database dictionary for every table and every column in the table. Optionally prefixed by a project abbreviation. Examples: employees departments countries_eb - table interfaced by an editioning view named countries sct_contracts sct_contract_lines sct_incentive_modules Temporary Table (Global Temporary Table) Naming as described for tables. Optionally suffixed by _tmp Optionally prefixed by a project abbreviation. Examples: employees_tmp contracts_tmp Unique Key Constraint Table name or table abbreviation followed by the role of the unique key constraint, a _uk and an optional number suffix. Examples: employees_name_uk departments_deptno_uk sct_contracts_uk sct_coli_uk sct_icmd_uk1 View Plural 1 name of what is contained in the view. Optionally suffixed by an indicator identifying the object as a view (mostly used, when a 1:1 view layer lies above the table layer) Editioning views are named like the original underlying table to avoid changing the existing application code when introducing edition based redefinition (EBR). Add a comment to the database dictionary for every view and every column. Optionally prefixed by a project abbreviation. Examples: active_orders orders_v - a view to the orders table countries - an editioning view for table countries_eb We see a table and a view as a collection. A jar containing beans is labeled \"beans\". In Java we call such a collection also \"beans\" ( List<Bean> beans ) and name an entry \"bean\" ( for (Bean bean : beans) {...} ). An entry of a table is a row (singular) and a table can contain an unbounded number of rows (plural). This and the fact that the Oracle Database uses the same concept for their tables and views lead to the decision to use the plural to name a table or a view. \u21a9 \u21a9 \u21a9","title":"Naming Conventions"},{"location":"2-naming-conventions/naming-conventions/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"2-naming-conventions/naming-conventions/#general-guidelines","text":"Never use names with a leading numeric character. Always choose meaningful and specific names. Avoid using abbreviations unless the full name is excessively long. Avoid long abbreviations. Abbreviations should be shorter than 5 characters. Any abbreviations must be widely known and accepted. Create a glossary with all accepted abbreviations. Never use keywords as names. A list of keywords may be found in the dictionary view v$reserved_words . Avoid adding redundant or meaningless prefixes and suffixes to identifiers. Example: create table emp_table . Always use one spoken language (e.g. English, German, French) for all objects in your application. Always use the same names for elements with the same meaning.","title":"General Guidelines"},{"location":"2-naming-conventions/naming-conventions/#naming-conventions-for-plsql","text":"In general, the Oracle Database is not case sensitive with names. A variable named personname is equal to one named PersonName, as well as to one named PERSONNAME. Some products (e.g. TMDA by Trivadis, APEX, OWB) put each name within double quotes (\") so the Oracle Database will treat these names to be case sensitive. Using case sensitive variable names force developers to use double quotes for each reference to the variable. Our recommendation is to write all names in lowercase and to avoid double quoted identifiers. A widely used convention is to follow a {prefix}variablecontent{suffix} pattern. The following table shows a possible set of naming conventions. Identifier Prefix Suffix Example Global Variable g_ g_version Local Variable l_ l_version Cursor c_ c_employees Record r_ r_employee Array / Table t_ t_employees Object o_ o_employee Cursor Parameter p_ p_empno In Parameter in_ in_empno Out Parameter out_ out_ename In/Out Parameter io_ io_employee Record Type Definitions r_ _type r_employee_type Array/Table Type Definitions t_ _type t_employees_type Exception e_ e_employee_exists Constants co_ co_empno Subtypes _type big_string_type","title":"Naming Conventions for PL/SQL"},{"location":"2-naming-conventions/naming-conventions/#database-object-naming-conventions","text":"Never enclose object names (table names, column names, etc.) in double quotes to enforce mixed case or lower case object names in the data dictionary.","title":"Database Object Naming Conventions"},{"location":"2-naming-conventions/naming-conventions/#collection-type","text":"A collection type should include the name of the collected objects in their name. Furthermore, they should have the suffix _ct to identify it as a collection. Optionally prefixed by a project abbreviation. Examples: employees_ct orders_ct","title":"Collection Type"},{"location":"2-naming-conventions/naming-conventions/#column","text":"Singular name of what is stored in the column (unless the column data type is a collection, in this case you use plural 1 names) Add a comment to the database dictionary for every column.","title":"Column"},{"location":"2-naming-conventions/naming-conventions/#check-constraint","text":"Table name or table abbreviation followed by the column and/or role of the check constraint, a _ck and an optional number suffix. Examples: employees_salary_min_ck orders_mode_ck","title":"Check Constraint"},{"location":"2-naming-conventions/naming-conventions/#dml-instead-of-trigger","text":"Choose a naming convention that includes: either the name of the object the trigger is added to, any of the triggering events: _br_iud for Before Row on Insert, Update and Delete _io_id for Instead of Insert and Delete or the name of the object the trigger is added to, the activity done by the trigger, the suffix _trg Examples: employees_br_iud orders_audit_trg orders_journal_trg","title":"DML / Instead of Trigger"},{"location":"2-naming-conventions/naming-conventions/#foreign-key-constraint","text":"Table abbreviation followed by referenced table abbreviation followed by a _fk and an optional number suffix. Examples: empl_dept_fk sct_icmd_ic_fk1","title":"Foreign Key Constraint"},{"location":"2-naming-conventions/naming-conventions/#function","text":"Name is built from a verb followed by a noun in general. Nevertheless, it is not sensible to call a function get_... as a function always gets something. The name of the function should answer the question \u201cWhat is the outcome of the function?\u201d Optionally prefixed by a project abbreviation. Example: employee_by_id If more than one function provides the same outcome, you have to be more specific with the name.","title":"Function"},{"location":"2-naming-conventions/naming-conventions/#index","text":"Indexes serving a constraint (primary, unique or foreign key) are named accordingly. Other indexes should have the name of the table and columns (or their purpose) in their name and should also have _idx as a suffix.","title":"Index"},{"location":"2-naming-conventions/naming-conventions/#object-type","text":"The name of an object type is built by its content (singular) followed by a _ot suffix. Optionally prefixed by a project abbreviation. Example: employee_ot","title":"Object Type"},{"location":"2-naming-conventions/naming-conventions/#package","text":"Name is built from the content that is contained within the package. Optionally prefixed by a project abbreviation. Examples: employees_api - API for the employee table logging_up - Utilities including logging support","title":"Package"},{"location":"2-naming-conventions/naming-conventions/#primary-key-constraint","text":"Table name or table abbreviation followed by the suffix _pk . Examples: employees_pk departments_pk sct_contracts_pk","title":"Primary Key Constraint"},{"location":"2-naming-conventions/naming-conventions/#procedure","text":"Name is built from a verb followed by a noun. The name of the procedure should answer the question \u201cWhat is done?\u201d Procedures and functions are often named with underscores between words because some editors write all letters in uppercase in the object tree, so it is difficult to read them. Optionally prefixed by a project abbreviation. Examples: calculate_salary set_hiredate check_order_state","title":"Procedure"},{"location":"2-naming-conventions/naming-conventions/#sequence","text":"Name is built from the table name (or its abbreviation) the sequence serves as primary key generator and the suffix _seq or the purpose of the sequence followed by a _seq . Optionally prefixed by a project abbreviation. Examples: employees_seq order_number_seq","title":"Sequence"},{"location":"2-naming-conventions/naming-conventions/#synonym","text":"Synonyms should be used to address an object in a foreign schema rather than to rename an object. Therefore, synonyms should share the name with the referenced object.","title":"Synonym"},{"location":"2-naming-conventions/naming-conventions/#system-trigger","text":"Name of the event the trigger is based on. Activity done by the trigger Suffix _trg Examples: ddl_audit_trg logon_trg","title":"System Trigger"},{"location":"2-naming-conventions/naming-conventions/#table","text":"Plural 1 name of what is contained in the table (unless the table is designed to always hold one row only \u2013 then you should use a singular name). Suffixed by _eb when protected by an editioning view. Add a comment to the database dictionary for every table and every column in the table. Optionally prefixed by a project abbreviation. Examples: employees departments countries_eb - table interfaced by an editioning view named countries sct_contracts sct_contract_lines sct_incentive_modules","title":"Table"},{"location":"2-naming-conventions/naming-conventions/#temporary-table-global-temporary-table","text":"Naming as described for tables. Optionally suffixed by _tmp Optionally prefixed by a project abbreviation. Examples: employees_tmp contracts_tmp","title":"Temporary Table (Global Temporary Table)"},{"location":"2-naming-conventions/naming-conventions/#unique-key-constraint","text":"Table name or table abbreviation followed by the role of the unique key constraint, a _uk and an optional number suffix. Examples: employees_name_uk departments_deptno_uk sct_contracts_uk sct_coli_uk sct_icmd_uk1","title":"Unique Key Constraint"},{"location":"2-naming-conventions/naming-conventions/#view","text":"Plural 1 name of what is contained in the view. Optionally suffixed by an indicator identifying the object as a view (mostly used, when a 1:1 view layer lies above the table layer) Editioning views are named like the original underlying table to avoid changing the existing application code when introducing edition based redefinition (EBR). Add a comment to the database dictionary for every view and every column. Optionally prefixed by a project abbreviation. Examples: active_orders orders_v - a view to the orders table countries - an editioning view for table countries_eb We see a table and a view as a collection. A jar containing beans is labeled \"beans\". In Java we call such a collection also \"beans\" ( List<Bean> beans ) and name an entry \"bean\" ( for (Bean bean : beans) {...} ). An entry of a table is a row (singular) and a table can contain an unbounded number of rows (plural). This and the fact that the Oracle Database uses the same concept for their tables and views lead to the decision to use the plural to name a table or a view. \u21a9 \u21a9 \u21a9","title":"View"},{"location":"3-coding-style/coding-style/","text":"Coding Style Formatting Rules Rule Description 1 Keywords and names are written in lowercase 1 . 2 3 space indention 2 . 3 One command per line. 4 Keywords loop , else , elsif , end if , when on a new line. 5 Commas in front of separated elements. 6 Call parameters aligned, operators aligned, values aligned. 7 SQL keywords are right aligned within a SQL command. 8 Within a program unit only line comments -- are used. 9 Brackets are used when needed or when helpful to clarify a construct. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 create or replace package body employee_api is procedure set_salary ( in_employee_id in integer ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; cursor c_employees ( p_employee_id in employees . employee_id % type ) is select last_name , first_name , salary from employees where employee_id = p_employee_id order by last_name , first_name ; r_employee c_employees % rowtype ; l_new_salary employees . salary % type ; begin open c_employees ( p_employee_id => co_employee_id ); fetch c_employees into r_employee ; close c_employees ; new_salary ( in_employee_id => in_employee_id , out_salary => l_new_salary ); -- Check whether salary has changed if r_employee . salary <> l_new_salary then update employees set salary = l_new_salary where employee_id = in_employee_id ; end if ; end set_salary ; end employee_api ; Code Commenting Conventions Inside a program unit only use the line commenting technique -- unless you temporarly deactivate code sections for testing. To comment the source code for later document generation, comments like /** ... */ are used. Within these documentation comments, tags may be used to define the documentation structure. Tools like Oracle SQL Developer or PL/SQL Developer include documentation functionality based on a javadoc-like tagging. Commenting Tags Tag Meaning Example param Description of a parameter. @param in_string input string return Description of the return value of a function. @return result of the calculation throws Describe errors that may be raised by the program unit. @throws NO_DATA_FOUND Example This is an example using the documentation capabilities of SQL Developer. 1 2 3 4 5 6 7 8 9 10 11 12 13 /** Check whether we passed a valid sql name @param in_name string to be checked @return in_name if the string represents a valid sql name @throws ORA-44003: invalid SQL name <b>Call Example:</b> <pre> select TVDAssert.valid_sql_name('TEST') from dual; select TVDAssert.valid_sql_name('123') from dual </pre> */ It used to be good practice to use uppercase keywords and lowercase names to help visualize code structure. But practically all editors support more or less advanced color highlighting of code, similar to the examples in these guidelines. Hence as of version 4.0 we are now recommending all lowercase, as this is easier and faster for the brain to process. You may choose to prefer the old rule - however, it is important to always be consistent, like for example keywords always in uppercase and names always in lowercase. \u21a9 Tabs are not used because the indentation depends on the editor configuration. We want to ensure that the code looks the same, independent of the editor used. Hence, no tabs. But why not use 8 spaces? That's the traditional value for a tab. When writing a package function the code in the body has an indentation of 3. That's 24 characters as a starting point for the code. We think it's too much. Especially if we try to keep a line below 100 or 80 characters. Other good options would be 2 or 4 spaces. We settled for 3 spaces as a compromise. The indentation is still good visible, but does not use too much space. \u21a9","title":"Coding Style"},{"location":"3-coding-style/coding-style/#coding-style","text":"","title":"Coding Style"},{"location":"3-coding-style/coding-style/#formatting","text":"","title":"Formatting"},{"location":"3-coding-style/coding-style/#rules","text":"Rule Description 1 Keywords and names are written in lowercase 1 . 2 3 space indention 2 . 3 One command per line. 4 Keywords loop , else , elsif , end if , when on a new line. 5 Commas in front of separated elements. 6 Call parameters aligned, operators aligned, values aligned. 7 SQL keywords are right aligned within a SQL command. 8 Within a program unit only line comments -- are used. 9 Brackets are used when needed or when helpful to clarify a construct.","title":"Rules"},{"location":"3-coding-style/coding-style/#example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 create or replace package body employee_api is procedure set_salary ( in_employee_id in integer ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; cursor c_employees ( p_employee_id in employees . employee_id % type ) is select last_name , first_name , salary from employees where employee_id = p_employee_id order by last_name , first_name ; r_employee c_employees % rowtype ; l_new_salary employees . salary % type ; begin open c_employees ( p_employee_id => co_employee_id ); fetch c_employees into r_employee ; close c_employees ; new_salary ( in_employee_id => in_employee_id , out_salary => l_new_salary ); -- Check whether salary has changed if r_employee . salary <> l_new_salary then update employees set salary = l_new_salary where employee_id = in_employee_id ; end if ; end set_salary ; end employee_api ;","title":"Example"},{"location":"3-coding-style/coding-style/#code-commenting","text":"","title":"Code Commenting"},{"location":"3-coding-style/coding-style/#conventions","text":"Inside a program unit only use the line commenting technique -- unless you temporarly deactivate code sections for testing. To comment the source code for later document generation, comments like /** ... */ are used. Within these documentation comments, tags may be used to define the documentation structure. Tools like Oracle SQL Developer or PL/SQL Developer include documentation functionality based on a javadoc-like tagging.","title":"Conventions"},{"location":"3-coding-style/coding-style/#commenting-tags","text":"Tag Meaning Example param Description of a parameter. @param in_string input string return Description of the return value of a function. @return result of the calculation throws Describe errors that may be raised by the program unit. @throws NO_DATA_FOUND","title":"Commenting Tags"},{"location":"3-coding-style/coding-style/#example_1","text":"This is an example using the documentation capabilities of SQL Developer. 1 2 3 4 5 6 7 8 9 10 11 12 13 /** Check whether we passed a valid sql name @param in_name string to be checked @return in_name if the string represents a valid sql name @throws ORA-44003: invalid SQL name <b>Call Example:</b> <pre> select TVDAssert.valid_sql_name('TEST') from dual; select TVDAssert.valid_sql_name('123') from dual </pre> */ It used to be good practice to use uppercase keywords and lowercase names to help visualize code structure. But practically all editors support more or less advanced color highlighting of code, similar to the examples in these guidelines. Hence as of version 4.0 we are now recommending all lowercase, as this is easier and faster for the brain to process. You may choose to prefer the old rule - however, it is important to always be consistent, like for example keywords always in uppercase and names always in lowercase. \u21a9 Tabs are not used because the indentation depends on the editor configuration. We want to ensure that the code looks the same, independent of the editor used. Hence, no tabs. But why not use 8 spaces? That's the traditional value for a tab. When writing a package function the code in the body has an indentation of 3. That's 24 characters as a starting point for the code. We think it's too much. Especially if we try to keep a line below 100 or 80 characters. Other good options would be 2 or 4 spaces. We settled for 3 spaces as a compromise. The indentation is still good visible, but does not use too much space. \u21a9","title":"Example"},{"location":"4-language-usage/1-general/g-1010/","text":"G-1010: Try to label your sub blocks. Minor Maintainability Reason It's a good alternative for comments to indicate the start and end of a named processing. Example (bad) 1 2 3 4 5 6 7 8 9 10 begin begin null ; end ; begin null ; end ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 begin << prepare_data >> begin null ; end prepare_data ; << process_data >> begin null ; end process_data ; end good ; /","title":"G-1010: Try to label your sub blocks."},{"location":"4-language-usage/1-general/g-1010/#g-1010-try-to-label-your-sub-blocks","text":"Minor Maintainability","title":"G-1010: Try to label your sub blocks."},{"location":"4-language-usage/1-general/g-1010/#reason","text":"It's a good alternative for comments to indicate the start and end of a named processing.","title":"Reason"},{"location":"4-language-usage/1-general/g-1010/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 begin begin null ; end ; begin null ; end ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/1-general/g-1010/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 begin << prepare_data >> begin null ; end prepare_data ; << process_data >> begin null ; end process_data ; end good ; /","title":"Example (good)"},{"location":"4-language-usage/1-general/g-1020/","text":"G-1020: Always have a matching loop or block label. Minor Maintainability Reason Use a label directly in front of loops and nested anonymous blocks: To give a name to that portion of code and thereby self-document what it is doing. So that you can repeat that name with the end statement of that block or loop. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 declare i integer ; co_min_value constant integer : = 1 ; co_max_value constant integer : = 10 ; co_increment constant integer : = 1 ; begin << prepare_data >> begin null ; end ; << process_data >> begin null ; end ; i : = co_min_value ; << while_loop >> while ( i <= co_max_value ) loop i : = i + co_increment ; end loop ; << basic_loop >> loop exit basic_loop when true ; end loop ; << for_loop >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 declare i integer ; co_min_value constant integer : = 1 ; co_max_value constant integer : = 10 ; co_increment constant integer : = 1 ; begin << prepare_data >> begin null ; end prepare_data ; << process_data >> begin null ; end process_data ; i : = co_min_value ; << while_loop >> while ( i <= co_max_value ) loop i : = i + co_increment ; end loop while_loop ; << basic_loop >> loop exit basic_loop when true ; end loop basic_loop ; << for_loop >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop for_loop ; end ; /","title":"G-1020: Always have a matching loop or block label."},{"location":"4-language-usage/1-general/g-1020/#g-1020-always-have-a-matching-loop-or-block-label","text":"Minor Maintainability","title":"G-1020: Always have a matching loop or block label."},{"location":"4-language-usage/1-general/g-1020/#reason","text":"Use a label directly in front of loops and nested anonymous blocks: To give a name to that portion of code and thereby self-document what it is doing. So that you can repeat that name with the end statement of that block or loop.","title":"Reason"},{"location":"4-language-usage/1-general/g-1020/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 declare i integer ; co_min_value constant integer : = 1 ; co_max_value constant integer : = 10 ; co_increment constant integer : = 1 ; begin << prepare_data >> begin null ; end ; << process_data >> begin null ; end ; i : = co_min_value ; << while_loop >> while ( i <= co_max_value ) loop i : = i + co_increment ; end loop ; << basic_loop >> loop exit basic_loop when true ; end loop ; << for_loop >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/1-general/g-1020/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 declare i integer ; co_min_value constant integer : = 1 ; co_max_value constant integer : = 10 ; co_increment constant integer : = 1 ; begin << prepare_data >> begin null ; end prepare_data ; << process_data >> begin null ; end process_data ; i : = co_min_value ; << while_loop >> while ( i <= co_max_value ) loop i : = i + co_increment ; end loop while_loop ; << basic_loop >> loop exit basic_loop when true ; end loop basic_loop ; << for_loop >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop for_loop ; end ; /","title":"Example (good)"},{"location":"4-language-usage/1-general/g-1030/","text":"G-1030: Avoid defining variables that are not used. Major Efficiency, Maintainability Reason Unused variables decrease the maintainability and readability of your code. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create or replace package body my_package is procedure my_proc is l_last_name employees . last_name % type ; l_first_name employees . first_name % type ; co_department_id constant departments . department_id % type : = 10 ; e_good exception ; begin select e . last_name into l_last_name from employees e where e . department_id = co_department_id ; exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end my_proc ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body my_package is procedure my_proc is l_last_name employees . last_name % type ; co_department_id constant departments . department_id % type : = 10 ; e_good exception ; begin select e . last_name into l_last_name from employees e where e . department_id = co_department_id ; raise e_good ; exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end my_proc ; end my_package ; /","title":"G-1030: Avoid defining variables that are not used."},{"location":"4-language-usage/1-general/g-1030/#g-1030-avoid-defining-variables-that-are-not-used","text":"Major Efficiency, Maintainability","title":"G-1030: Avoid defining variables that are not used."},{"location":"4-language-usage/1-general/g-1030/#reason","text":"Unused variables decrease the maintainability and readability of your code.","title":"Reason"},{"location":"4-language-usage/1-general/g-1030/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create or replace package body my_package is procedure my_proc is l_last_name employees . last_name % type ; l_first_name employees . first_name % type ; co_department_id constant departments . department_id % type : = 10 ; e_good exception ; begin select e . last_name into l_last_name from employees e where e . department_id = co_department_id ; exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end my_proc ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/1-general/g-1030/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body my_package is procedure my_proc is l_last_name employees . last_name % type ; co_department_id constant departments . department_id % type : = 10 ; e_good exception ; begin select e . last_name into l_last_name from employees e where e . department_id = co_department_id ; raise e_good ; exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end my_proc ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/1-general/g-1040/","text":"G-1040: Avoid dead code. Major Maintainability Reason Any part of your code, which is no longer used or cannot be reached, should be eliminated from your programs to simplify the code. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 declare co_dept_purchasing constant departments . department_id % type : = 30 ; begin if 2 = 3 then -- dead code detection works with literals only null ; -- some dead code here end if ; null ; -- some enabled code here << my_loop >> loop exit my_loop when true ; null ; -- some dead code here end loop my_loop ; null ; -- some other enabled code here case when 1 = 1 and 'x' = 'y' then -- dead code detection works with literals only null ; -- some dead code here else null ; -- some further enabled code here end case ; << my_loop2 >> for r_emp in ( select last_name from employees where department_id = co_dept_purchasing or commission_pct is not null and 5 = 6 -- dead code detection works with literals only ) -- \"or commission_pct is not null\" is dead code loop sys . dbms_output . put_line ( r_emp . last_name ); end loop my_loop2 ; return ; null ; -- some dead code here end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 declare co_dept_admin constant dept . deptno % type : = 10 ; begin null ; -- some enabled code here null ; -- some other enabled code here null ; -- some further enabled code here << my_loop2 >> for r_emp in ( select last_name from employees where department_id = co_dept_admin or commission_pct is not null ) loop sys . dbms_output . put_line ( r_emp . last_name ); end loop my_loop2 ; end ; /","title":"G-1040: Avoid dead code."},{"location":"4-language-usage/1-general/g-1040/#g-1040-avoid-dead-code","text":"Major Maintainability","title":"G-1040: Avoid dead code."},{"location":"4-language-usage/1-general/g-1040/#reason","text":"Any part of your code, which is no longer used or cannot be reached, should be eliminated from your programs to simplify the code.","title":"Reason"},{"location":"4-language-usage/1-general/g-1040/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 declare co_dept_purchasing constant departments . department_id % type : = 30 ; begin if 2 = 3 then -- dead code detection works with literals only null ; -- some dead code here end if ; null ; -- some enabled code here << my_loop >> loop exit my_loop when true ; null ; -- some dead code here end loop my_loop ; null ; -- some other enabled code here case when 1 = 1 and 'x' = 'y' then -- dead code detection works with literals only null ; -- some dead code here else null ; -- some further enabled code here end case ; << my_loop2 >> for r_emp in ( select last_name from employees where department_id = co_dept_purchasing or commission_pct is not null and 5 = 6 -- dead code detection works with literals only ) -- \"or commission_pct is not null\" is dead code loop sys . dbms_output . put_line ( r_emp . last_name ); end loop my_loop2 ; return ; null ; -- some dead code here end ; /","title":"Example (bad)"},{"location":"4-language-usage/1-general/g-1040/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 declare co_dept_admin constant dept . deptno % type : = 10 ; begin null ; -- some enabled code here null ; -- some other enabled code here null ; -- some further enabled code here << my_loop2 >> for r_emp in ( select last_name from employees where department_id = co_dept_admin or commission_pct is not null ) loop sys . dbms_output . put_line ( r_emp . last_name ); end loop my_loop2 ; end ; /","title":"Example (good)"},{"location":"4-language-usage/1-general/g-1050/","text":"G-1050: Avoid using literals in your code. Minor Changeability Reason Literals are often used more than once in your code. Having them defined as a constant reduces typos in your code and improves the maintainability. All constants should be collated in just one package used as a library. If these constants should be used in SQL too it is good practice to write a deterministic package function for every constant. To avoid an extreme plethora of constants or false positives, a literal should not occur more than once within a file. Example (bad) 1 2 3 4 5 6 begin some_api . setup ( in_department_id => 10 ); some_api . process ( in_department_id => 10 ); some_api . teardown ( in_department_id => 10 ); end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 create or replace package constants_up is co_dept_admin constant departments . department_id % type : = 10 ; end constants_up ; / begin some_api . setup ( in_department_id => constants_up . co_dept_admin ); some_api . process ( in_department_id => constants_up . co_dept_admin ); some_api . teardown ( in_department_id => constants_up . co_dept_admin ); end ; /","title":"G-1050: Avoid using literals in your code."},{"location":"4-language-usage/1-general/g-1050/#g-1050-avoid-using-literals-in-your-code","text":"Minor Changeability","title":"G-1050: Avoid using literals in your code."},{"location":"4-language-usage/1-general/g-1050/#reason","text":"Literals are often used more than once in your code. Having them defined as a constant reduces typos in your code and improves the maintainability. All constants should be collated in just one package used as a library. If these constants should be used in SQL too it is good practice to write a deterministic package function for every constant. To avoid an extreme plethora of constants or false positives, a literal should not occur more than once within a file.","title":"Reason"},{"location":"4-language-usage/1-general/g-1050/#example-bad","text":"1 2 3 4 5 6 begin some_api . setup ( in_department_id => 10 ); some_api . process ( in_department_id => 10 ); some_api . teardown ( in_department_id => 10 ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/1-general/g-1050/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 create or replace package constants_up is co_dept_admin constant departments . department_id % type : = 10 ; end constants_up ; / begin some_api . setup ( in_department_id => constants_up . co_dept_admin ); some_api . process ( in_department_id => constants_up . co_dept_admin ); some_api . teardown ( in_department_id => constants_up . co_dept_admin ); end ; /","title":"Example (good)"},{"location":"4-language-usage/1-general/g-1060/","text":"G-1060: Avoid storing ROWIDs or UROWIDs in database tables. Blocker Reliability Reason It is an extremely dangerous practice to store rowid 's in a table, except for some very limited scenarios of runtime duration. Any manually explicit or system generated implicit table reorganization will reassign the row's rowid and break the data consistency. Instead of using rowid for later reference to the original row one should use the primary key column(s). Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 begin insert into employees_log ( employee_id , last_name , first_name , rid ) select employee_id , last_name , first_name , rowid from employees ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 begin insert into employees_log ( employee_id , last_name , first_name ) select employee_id , last_name , first_name from employees ; end ; /","title":"G-1060: Avoid storing ROWIDs or UROWIDs in database tables."},{"location":"4-language-usage/1-general/g-1060/#g-1060-avoid-storing-rowids-or-urowids-in-database-tables","text":"Blocker Reliability","title":"G-1060: Avoid storing ROWIDs or UROWIDs in database tables."},{"location":"4-language-usage/1-general/g-1060/#reason","text":"It is an extremely dangerous practice to store rowid 's in a table, except for some very limited scenarios of runtime duration. Any manually explicit or system generated implicit table reorganization will reassign the row's rowid and break the data consistency. Instead of using rowid for later reference to the original row one should use the primary key column(s).","title":"Reason"},{"location":"4-language-usage/1-general/g-1060/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 begin insert into employees_log ( employee_id , last_name , first_name , rid ) select employee_id , last_name , first_name , rowid from employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/1-general/g-1060/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 begin insert into employees_log ( employee_id , last_name , first_name ) select employee_id , last_name , first_name from employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/1-general/g-1070/","text":"G-1070: Avoid nesting comment blocks. Minor Maintainability Reason Having an end-of-comment within a block comment will end that block-comment. This does not only influence your code but is also very hard to read. Example (bad) 1 2 3 4 5 6 7 begin /* comment one -- nested comment two */ null ; -- comment three /* nested comment four */ null ; end ; / Example (good) 1 2 3 4 5 6 7 begin /* comment one, comment two */ null ; -- comment three, comment four null ; end ; /","title":"G-1070: Avoid nesting comment blocks."},{"location":"4-language-usage/1-general/g-1070/#g-1070-avoid-nesting-comment-blocks","text":"Minor Maintainability","title":"G-1070: Avoid nesting comment blocks."},{"location":"4-language-usage/1-general/g-1070/#reason","text":"Having an end-of-comment within a block comment will end that block-comment. This does not only influence your code but is also very hard to read.","title":"Reason"},{"location":"4-language-usage/1-general/g-1070/#example-bad","text":"1 2 3 4 5 6 7 begin /* comment one -- nested comment two */ null ; -- comment three /* nested comment four */ null ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/1-general/g-1070/#example-good","text":"1 2 3 4 5 6 7 begin /* comment one, comment two */ null ; -- comment three, comment four null ; end ; /","title":"Example (good)"},{"location":"4-language-usage/1-general/g-1080/","text":"G-1080: Avoid using the same expression on both sides of a relational comparison operator or a logical operator. Blocker Maintainability, Efficiency, Testability Reason Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste error and therefore a bug, or it is simply wasted code and should be simplified. This rule ignores operators + , * and || , and expressions: 1=1 , 1<>1 , 1!=1 , 1~=1 and 1^=1 . Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_max_salary constant emp . salary % type : = 3000 ; begin select emp . first_name , emp . last_name , emp . salary , emp . hire_date from employees emp where emp . salary > co_max_salary or emp . salary > co_max_salary order by emp . last_name , emp . first_name ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 declare co_max_salary constant emp . salary % type : = 3000 ; begin select emp . first_name , emp . last_name , emp . salary , emp . hire_date from employees emp where emp . salary > co_max_salary order by emp . last_name , emp . first_name ; end ; /","title":"G-1080: Avoid using the same expression on both sides of a relational comparison operator or a logical operator."},{"location":"4-language-usage/1-general/g-1080/#g-1080-avoid-using-the-same-expression-on-both-sides-of-a-relational-comparison-operator-or-a-logical-operator","text":"Blocker Maintainability, Efficiency, Testability","title":"G-1080: Avoid using the same expression on both sides of a relational comparison operator or a logical operator."},{"location":"4-language-usage/1-general/g-1080/#reason","text":"Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste error and therefore a bug, or it is simply wasted code and should be simplified. This rule ignores operators + , * and || , and expressions: 1=1 , 1<>1 , 1!=1 , 1~=1 and 1^=1 .","title":"Reason"},{"location":"4-language-usage/1-general/g-1080/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_max_salary constant emp . salary % type : = 3000 ; begin select emp . first_name , emp . last_name , emp . salary , emp . hire_date from employees emp where emp . salary > co_max_salary or emp . salary > co_max_salary order by emp . last_name , emp . first_name ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/1-general/g-1080/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 declare co_max_salary constant emp . salary % type : = 3000 ; begin select emp . first_name , emp . last_name , emp . salary , emp . hire_date from employees emp where emp . salary > co_max_salary order by emp . last_name , emp . first_name ; end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2110/","text":"G-2110: Try to use anchored declarations for variables, constants and types. Major Maintainability, Reliability Reason Changing the size of the database column last_name in the employees table from varchar2(20) to varchar2(30) will result in an error within your code whenever a value larger than the hard coded size is read from the table. This can be avoided using anchored declarations. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body my_package is procedure my_proc is l_last_name varchar2 ( 20 char ); co_first_row constant integer : = 1 ; begin select e . last_name into l_last_name from employees e where rownum = co_first_row ; exception when no_data_found then null ; -- handle no_data_found when too_many_rows then null ; -- handle too_many_rows (impossible) end my_proc ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body my_package is procedure my_proc is l_last_name employees . last_name % type ; co_first_row constant integer : = 1 ; begin select e . last_name into l_last_name from employees e where rownum = co_first_row ; exception when no_data_found then null ; -- handle no_data_found when too_many_rows then null ; -- handle too_many_rows (impossible) end my_proc ; end my_package ; /","title":"G-2110: Try to use anchored declarations for variables, constants and types."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2110/#g-2110-try-to-use-anchored-declarations-for-variables-constants-and-types","text":"Major Maintainability, Reliability","title":"G-2110: Try to use anchored declarations for variables, constants and types."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2110/#reason","text":"Changing the size of the database column last_name in the employees table from varchar2(20) to varchar2(30) will result in an error within your code whenever a value larger than the hard coded size is read from the table. This can be avoided using anchored declarations.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2110/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body my_package is procedure my_proc is l_last_name varchar2 ( 20 char ); co_first_row constant integer : = 1 ; begin select e . last_name into l_last_name from employees e where rownum = co_first_row ; exception when no_data_found then null ; -- handle no_data_found when too_many_rows then null ; -- handle too_many_rows (impossible) end my_proc ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2110/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body my_package is procedure my_proc is l_last_name employees . last_name % type ; co_first_row constant integer : = 1 ; begin select e . last_name into l_last_name from employees e where rownum = co_first_row ; exception when no_data_found then null ; -- handle no_data_found when too_many_rows then null ; -- handle too_many_rows (impossible) end my_proc ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2120/","text":"G-2120: Try to have a single location to define your types. Minor Changeability Reason Single point of change when changing the data type. No need to argue where to define types or where to look for existing definitions. A single location could be either a type specification package or the database (database-defined types). Example (bad) 1 2 3 4 5 6 7 8 9 10 create or replace package body my_package is procedure my_proc is subtype big_string_type is varchar2 ( 1000 char ); l_note big_string_type ; begin l_note : = some_function (); do_something ( l_note ); end my_proc ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package types_up is subtype big_string_type is varchar2 ( 1000 char ); end types_up ; / create or replace package body my_package is procedure my_proc is l_note types_up . big_string_type ; begin l_note : = some_function (); do_something ( l_note ); end my_proc ; end my_package ; /","title":"G-2120: Try to have a single location to define your types."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2120/#g-2120-try-to-have-a-single-location-to-define-your-types","text":"Minor Changeability","title":"G-2120: Try to have a single location to define your types."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2120/#reason","text":"Single point of change when changing the data type. No need to argue where to define types or where to look for existing definitions. A single location could be either a type specification package or the database (database-defined types).","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2120/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 create or replace package body my_package is procedure my_proc is subtype big_string_type is varchar2 ( 1000 char ); l_note big_string_type ; begin l_note : = some_function (); do_something ( l_note ); end my_proc ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2120/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package types_up is subtype big_string_type is varchar2 ( 1000 char ); end types_up ; / create or replace package body my_package is procedure my_proc is l_note types_up . big_string_type ; begin l_note : = some_function (); do_something ( l_note ); end my_proc ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2130/","text":"G-2130: Try to use subtypes for constructs used often in your code. Minor Changeability Reason Single point of change when changing the data type. Your code will be easier to read as the usage of a variable/constant may be derived from its definition. Examples of possible subtype definitions: Type Usage ora_name_type Object corresponding to the Oracle Database naming conventions (table, variable, column, package, etc.). max_vc2_type String variable with maximal VARCHAR2 size. array_index_type Best fitting data type for array navigation. id_type Data type used for all primary key (id) columns. Example (bad) 1 2 3 4 5 6 7 8 9 create or replace package body my_package is procedure my_proc is l_note varchar2 ( 1000 char ); begin l_note : = some_function (); do_something ( l_note ); end my_proc ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package types_up is subtype big_string_type is varchar2 ( 1000 char ); end types_up ; / create or replace package body my_package is procedure my_proc is l_note types_up . big_string_type ; begin l_note : = some_function (); do_something ( l_note ); end my_proc ; end my_package ; /","title":"G-2130: Try to use subtypes for constructs used often in your code."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2130/#g-2130-try-to-use-subtypes-for-constructs-used-often-in-your-code","text":"Minor Changeability","title":"G-2130: Try to use subtypes for constructs used often in your code."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2130/#reason","text":"Single point of change when changing the data type. Your code will be easier to read as the usage of a variable/constant may be derived from its definition. Examples of possible subtype definitions: Type Usage ora_name_type Object corresponding to the Oracle Database naming conventions (table, variable, column, package, etc.). max_vc2_type String variable with maximal VARCHAR2 size. array_index_type Best fitting data type for array navigation. id_type Data type used for all primary key (id) columns.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2130/#example-bad","text":"1 2 3 4 5 6 7 8 9 create or replace package body my_package is procedure my_proc is l_note varchar2 ( 1000 char ); begin l_note : = some_function (); do_something ( l_note ); end my_proc ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2130/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package types_up is subtype big_string_type is varchar2 ( 1000 char ); end types_up ; / create or replace package body my_package is procedure my_proc is l_note types_up . big_string_type ; begin l_note : = some_function (); do_something ( l_note ); end my_proc ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2135/","text":"G-2135: Avoid assigning values to local variables that are not used by a subsequent statement. Major Efficiency, Maintainability, Testability Reason Expending resources calculating and assigning values to a local variable and never use the value subsequently is at best a waste, at worst indicative of a mistake that leads to a bug. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 create or replace package body my_package is procedure my_proc is co_employee_id constant employees . employee_id % type : = 1042 ; co_hello constant type_up . text : = 'Hello, ' ; l_last_name employees . last_name % type ; l_message types_up . text ; begin select emp . last_name into l_last_name from employees emp where emp . employee_id = co_employee_id ; l_message : = co_hello || l_last_name ; exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end my_proc ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create or replace package body my_package is procedure my_proc is co_employee_id constant employees . employee_id % type : = 1042 ; co_hello constant type_up . text : = 'Hello, ' ; l_last_name employees . last_name % type ; l_message types_up . text ; begin select emp . last_name into l_last_name from employees emp where emp . employee_id = co_employee_id ; l_message : = co_hello || l_last_name ; message_api . send_message ( l_message ); exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end my_proc ; end my_package ; /","title":"G-2135: Avoid assigning values to local variables that are not used by a subsequent statement."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2135/#g-2135-avoid-assigning-values-to-local-variables-that-are-not-used-by-a-subsequent-statement","text":"Major Efficiency, Maintainability, Testability","title":"G-2135: Avoid assigning values to local variables that are not used by a subsequent statement."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2135/#reason","text":"Expending resources calculating and assigning values to a local variable and never use the value subsequently is at best a waste, at worst indicative of a mistake that leads to a bug.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2135/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 create or replace package body my_package is procedure my_proc is co_employee_id constant employees . employee_id % type : = 1042 ; co_hello constant type_up . text : = 'Hello, ' ; l_last_name employees . last_name % type ; l_message types_up . text ; begin select emp . last_name into l_last_name from employees emp where emp . employee_id = co_employee_id ; l_message : = co_hello || l_last_name ; exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end my_proc ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2135/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create or replace package body my_package is procedure my_proc is co_employee_id constant employees . employee_id % type : = 1042 ; co_hello constant type_up . text : = 'Hello, ' ; l_last_name employees . last_name % type ; l_message types_up . text ; begin select emp . last_name into l_last_name from employees emp where emp . employee_id = co_employee_id ; l_message : = co_hello || l_last_name ; message_api . send_message ( l_message ); exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end my_proc ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2140/","text":"G-2140: Never initialize variables with NULL. Minor Maintainability Reason Variables are initialized to null by default. Example (bad) 1 2 3 4 5 6 declare l_note big_string_type : = null ; begin sys . dbms_output . put_line ( l_note ); end ; / Example (good) 1 2 3 4 5 6 declare l_note big_string_type ; begin sys . dbms_output . put_line ( l_note ); end ; /","title":"G-2140: Never initialize variables with NULL."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2140/#g-2140-never-initialize-variables-with-null","text":"Minor Maintainability","title":"G-2140: Never initialize variables with NULL."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2140/#reason","text":"Variables are initialized to null by default.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2140/#example-bad","text":"1 2 3 4 5 6 declare l_note big_string_type : = null ; begin sys . dbms_output . put_line ( l_note ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2140/#example-good","text":"1 2 3 4 5 6 declare l_note big_string_type ; begin sys . dbms_output . put_line ( l_note ); end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2145/","text":"G-2145: Never self-assign a variable. Blocker Maintainability Reason There is no reason to assign a variable to itself. It is either a redundant statement that should be removed, or it is a mistake where some other value was intended in the assignment. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 declare co_parallel_degree constant types_up . name % type : = 'parallel_degree' ; l_function_result pls_integer ; l_parallel_degree pls_integer ; begin l_function_result : = maintenance . get_config ( co_parallel_degree ); if l_function_result is not null then l_parallel_degree : = l_parallel_degree ; do_something ( l_parallel_degree ); end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 declare co_parallel_degree constant types_up . name % type : = 'parallel_degree' ; l_function_result pls_integer ; l_parallel_degree pls_integer ; begin l_function_result : = maintenance . get_config ( co_parallel_degree ); if l_function_result is not null then l_parallel_degree : = l_function_result ; do_something ( l_parallel_degree ); end if ; end ; /","title":"G-2145: Never self-assign a variable."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2145/#g-2145-never-self-assign-a-variable","text":"Blocker Maintainability","title":"G-2145: Never self-assign a variable."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2145/#reason","text":"There is no reason to assign a variable to itself. It is either a redundant statement that should be removed, or it is a mistake where some other value was intended in the assignment.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2145/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 declare co_parallel_degree constant types_up . name % type : = 'parallel_degree' ; l_function_result pls_integer ; l_parallel_degree pls_integer ; begin l_function_result : = maintenance . get_config ( co_parallel_degree ); if l_function_result is not null then l_parallel_degree : = l_parallel_degree ; do_something ( l_parallel_degree ); end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2145/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 declare co_parallel_degree constant types_up . name % type : = 'parallel_degree' ; l_function_result pls_integer ; l_parallel_degree pls_integer ; begin l_function_result : = maintenance . get_config ( co_parallel_degree ); if l_function_result is not null then l_parallel_degree : = l_function_result ; do_something ( l_parallel_degree ); end if ; end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2150/","text":"G-2150: Avoid comparisons with NULL value, consider using IS [NOT] NULL. Blocker Portability, Reliability Reason The null value can cause confusion both from the standpoint of code review and code execution. You must always use the is null or is not null syntax when you need to check if a value is or is not null . Example (bad) 1 2 3 4 5 6 7 8 declare l_value integer ; begin if l_value = null then null ; end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 declare l_value integer ; begin if l_value is null then null ; end if ; end ; /","title":"G-2150: Avoid comparisons with NULL value, consider using IS [NOT] NULL."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2150/#g-2150-avoid-comparisons-with-null-value-consider-using-is-not-null","text":"Blocker Portability, Reliability","title":"G-2150: Avoid comparisons with NULL value, consider using IS [NOT] NULL."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2150/#reason","text":"The null value can cause confusion both from the standpoint of code review and code execution. You must always use the is null or is not null syntax when you need to check if a value is or is not null .","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2150/#example-bad","text":"1 2 3 4 5 6 7 8 declare l_value integer ; begin if l_value = null then null ; end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2150/#example-good","text":"1 2 3 4 5 6 7 8 declare l_value integer ; begin if l_value is null then null ; end if ; end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2160/","text":"G-2160: Avoid initializing variables using functions in the declaration section. Critical Reliability Reason If your initialization fails, you will not be able to handle the error in your exceptions block. Example (bad) 1 2 3 4 5 6 7 8 declare co_department_id constant integer : = 100 ; l_department_name departments . department_name % type : = department_api . name_by_id ( in_id => co_department_id ); begin sys . dbms_output . put_line ( l_department_name ); end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 declare co_department_id constant integer : = 100 ; co_unkown_name constant departments . department_name % type : = 'unknown' ; l_department_name departments . department_name % type ; begin << init >> begin l_department_name : = department_api . name_by_id ( in_id => co_department_id ); exception when value_error then l_department_name : = co_unkown_name ; end init ; sys . dbms_output . put_line ( l_department_name ); end ; /","title":"G-2160: Avoid initializing variables using functions in the declaration section."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2160/#g-2160-avoid-initializing-variables-using-functions-in-the-declaration-section","text":"Critical Reliability","title":"G-2160: Avoid initializing variables using functions in the declaration section."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2160/#reason","text":"If your initialization fails, you will not be able to handle the error in your exceptions block.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2160/#example-bad","text":"1 2 3 4 5 6 7 8 declare co_department_id constant integer : = 100 ; l_department_name departments . department_name % type : = department_api . name_by_id ( in_id => co_department_id ); begin sys . dbms_output . put_line ( l_department_name ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2160/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 declare co_department_id constant integer : = 100 ; co_unkown_name constant departments . department_name % type : = 'unknown' ; l_department_name departments . department_name % type ; begin << init >> begin l_department_name : = department_api . name_by_id ( in_id => co_department_id ); exception when value_error then l_department_name : = co_unkown_name ; end init ; sys . dbms_output . put_line ( l_department_name ); end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2170/","text":"G-2170: Never overload variables. Major Reliability Reason The readability of your code will be higher when you do not overload variables. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 begin << main >> declare co_main constant user_objects . object_name % type : = 'test_main' ; co_sub constant user_objects . object_name % type : = 'test_sub' ; co_sep constant user_objects . object_name % type : = ' - ' ; l_variable user_objects . object_name % type : = co_main ; begin << sub >> declare l_variable user_objects . object_name % type : = co_sub ; begin sys . dbms_output . put_line ( l_variable || co_sep || main . l_variable ); end sub ; end main ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 begin << main >> declare co_main constant user_objects . object_name % type : = 'test_main' ; co_sub constant user_objects . object_name % type : = 'test_sub' ; co_sep constant user_objects . object_name % type : = ' - ' ; l_main_variable user_objects . object_name % type : = co_main ; begin << sub >> declare l_sub_variable user_objects . object_name % type : = co_sub ; begin sys . dbms_output . put_line ( l_sub_variable || co_sep || l_main_variable ); end sub ; end main ; end ; /","title":"G-2170: Never overload variables."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2170/#g-2170-never-overload-variables","text":"Major Reliability","title":"G-2170: Never overload variables."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2170/#reason","text":"The readability of your code will be higher when you do not overload variables.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2170/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 begin << main >> declare co_main constant user_objects . object_name % type : = 'test_main' ; co_sub constant user_objects . object_name % type : = 'test_sub' ; co_sep constant user_objects . object_name % type : = ' - ' ; l_variable user_objects . object_name % type : = co_main ; begin << sub >> declare l_variable user_objects . object_name % type : = co_sub ; begin sys . dbms_output . put_line ( l_variable || co_sep || main . l_variable ); end sub ; end main ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2170/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 begin << main >> declare co_main constant user_objects . object_name % type : = 'test_main' ; co_sub constant user_objects . object_name % type : = 'test_sub' ; co_sep constant user_objects . object_name % type : = ' - ' ; l_main_variable user_objects . object_name % type : = co_main ; begin << sub >> declare l_sub_variable user_objects . object_name % type : = co_sub ; begin sys . dbms_output . put_line ( l_sub_variable || co_sep || l_main_variable ); end sub ; end main ; end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2180/","text":"G-2180: Never use quoted identifiers. Major Maintainability Reason Quoted identifiers make your code hard to read and maintain. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 declare \"sal+comm\" integer ; -- violates also naming conventions (G-9102) \"my constant\" constant integer : = 1 ; -- violates also naming conventions (G-9114) \"my exception\" exception ; -- violates also naming conventsion (G-9113) begin \"sal+comm\" : = \"my constant\" ; do_something ( \"sal+comm\" ); exception when \"my exception\" then null ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 declare l_sal_comm integer ; co_my_constant constant integer : = 1 ; e_my_exception exception ; begin l_sal_comm : = co_my_constant ; do_something ( l_sal_comm ); exception when e_my_exception then null ; end ; /","title":"G-2180: Never use quoted identifiers."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2180/#g-2180-never-use-quoted-identifiers","text":"Major Maintainability","title":"G-2180: Never use quoted identifiers."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2180/#reason","text":"Quoted identifiers make your code hard to read and maintain.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2180/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 declare \"sal+comm\" integer ; -- violates also naming conventions (G-9102) \"my constant\" constant integer : = 1 ; -- violates also naming conventions (G-9114) \"my exception\" exception ; -- violates also naming conventsion (G-9113) begin \"sal+comm\" : = \"my constant\" ; do_something ( \"sal+comm\" ); exception when \"my exception\" then null ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2180/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 declare l_sal_comm integer ; co_my_constant constant integer : = 1 ; e_my_exception exception ; begin l_sal_comm : = co_my_constant ; do_something ( l_sal_comm ); exception when e_my_exception then null ; end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2185/","text":"G-2185: Avoid using overly short names for explicitly or implicitly declared identifiers. Major Maintainability Reason You should ensure that the name you have chosen well defines its purpose and usage. While you can save a few keystrokes typing very short names, the resulting code is obscure and hard for anyone besides the author to understand. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 declare i integer ; c constant integer : = 1 ; -- violates also naming conventions (G-9114) e exception ; -- violates also naming conventions (G-9113) begin i : = c ; do_something ( i ); exception when e then null ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 declare l_sal_comm integer ; co_my_constant constant integer : = 1 ; e_my_exception exception ; begin l_sal_comm : = co_my_constant ; do_something ( l_sal_comm ); exception when e_my_exception then null ; end ; /","title":"G-2185: Avoid using overly short names for explicitly or implicitly declared identifiers."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2185/#g-2185-avoid-using-overly-short-names-for-explicitly-or-implicitly-declared-identifiers","text":"Major Maintainability","title":"G-2185: Avoid using overly short names for explicitly or implicitly declared identifiers."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2185/#reason","text":"You should ensure that the name you have chosen well defines its purpose and usage. While you can save a few keystrokes typing very short names, the resulting code is obscure and hard for anyone besides the author to understand.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2185/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 declare i integer ; c constant integer : = 1 ; -- violates also naming conventions (G-9114) e exception ; -- violates also naming conventions (G-9113) begin i : = c ; do_something ( i ); exception when e then null ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2185/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 declare l_sal_comm integer ; co_my_constant constant integer : = 1 ; e_my_exception exception ; begin l_sal_comm : = co_my_constant ; do_something ( l_sal_comm ); exception when e_my_exception then null ; end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2190/","text":"G-2190: Avoid using ROWID or UROWID. Blocker Portability, Reliability Reason Be careful about your use of Oracle Database specific data types like rowid and urowid . They might offer a slight improvement in performance over other means of identifying a single row (primary key or unique index value), but that is by no means guaranteed. Use of rowid or urowid means that your SQL statement will not be portable to other SQL databases. Many developers are also not familiar with these data types, which can make the code harder to maintain. Example (bad) 1 2 3 4 5 6 7 8 9 declare l_department_name departments . department_name % type ; l_rowid rowid ; begin update departments set department_name = l_department_name where rowid = l_rowid ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 declare l_department_name departments . department_name % type ; l_department_id departments . department_id % type ; begin update departments set department_name = l_department_name where department_id = l_department_id ; end ; /","title":"G-2190: Avoid using ROWID or UROWID."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2190/#g-2190-avoid-using-rowid-or-urowid","text":"Blocker Portability, Reliability","title":"G-2190: Avoid using ROWID or UROWID."},{"location":"4-language-usage/2-variables-and-types/1-general/g-2190/#reason","text":"Be careful about your use of Oracle Database specific data types like rowid and urowid . They might offer a slight improvement in performance over other means of identifying a single row (primary key or unique index value), but that is by no means guaranteed. Use of rowid or urowid means that your SQL statement will not be portable to other SQL databases. Many developers are also not familiar with these data types, which can make the code harder to maintain.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2190/#example-bad","text":"1 2 3 4 5 6 7 8 9 declare l_department_name departments . department_name % type ; l_rowid rowid ; begin update departments set department_name = l_department_name where rowid = l_rowid ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/1-general/g-2190/#example-good","text":"1 2 3 4 5 6 7 8 9 declare l_department_name departments . department_name % type ; l_department_id departments . department_id % type ; begin update departments set department_name = l_department_name where department_id = l_department_id ; end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2210/","text":"G-2210: Avoid declaring NUMBER variables, constants or subtypes with no precision. Critical Efficiency Reason If you do not specify precision number is defaulted to 38 or the maximum supported by your system, whichever is less. You may well need all this precision, but if you know you do not, you should specify whatever matches your needs. Also, consider using a simpler data type that uses fewer resources, such as pls_integer . Example (bad) 1 2 3 4 create or replace package types_up is subtype salary_type is number ; end types_up ; / Example (good) 1 2 3 4 create or replace package types_up is subtype salary_type is number ( 5 , 1 ); end types_up ; /","title":"G-2210: Avoid declaring NUMBER variables, constants or subtypes with no precision."},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2210/#g-2210-avoid-declaring-number-variables-constants-or-subtypes-with-no-precision","text":"Critical Efficiency","title":"G-2210: Avoid declaring NUMBER variables, constants or subtypes with no precision."},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2210/#reason","text":"If you do not specify precision number is defaulted to 38 or the maximum supported by your system, whichever is less. You may well need all this precision, but if you know you do not, you should specify whatever matches your needs. Also, consider using a simpler data type that uses fewer resources, such as pls_integer .","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2210/#example-bad","text":"1 2 3 4 create or replace package types_up is subtype salary_type is number ; end types_up ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2210/#example-good","text":"1 2 3 4 create or replace package types_up is subtype salary_type is number ( 5 , 1 ); end types_up ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2220/","text":"G-2220: Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values. Critical Efficiency Reason pls_integer having a length of -2,147,483,648 to 2,147,483,647, on a 32bit system. There are many reasons to use pls_integer instead of number : pls_integer uses less memory pls_integer uses machine arithmetic, which is up to three times faster than library arithmetic, which is used by number . Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 declare l_result number ( 9 , 0 ) : = 0 ; -- violates also G-2130, G-2230 co_upper_bound constant pls_integer : = 1 e8 ; begin << burning_cpu >> for i in 1 .. co_upper_bound loop if i > 0 then l_result : = l_result + 1 ; end if ; end loop burning_cpu ; sys . dbms_output . put_line ( l_result ); end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 declare l_result pls_integer : = 0 ; co_upper_bound constant pls_integer : = 1 e8 ; begin << burning_less_cpu >> for i in 1 .. co_upper_bound loop if i > 0 then l_result : = l_result + 1 ; end if ; end loop burning_less_cpu ; sys . dbms_output . put_line ( l_result ); end ; /","title":"G-2220: Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values."},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#g-2220-try-to-use-pls_integer-instead-of-number-for-arithmetic-operations-with-integer-values","text":"Critical Efficiency","title":"G-2220: Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values."},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#reason","text":"pls_integer having a length of -2,147,483,648 to 2,147,483,647, on a 32bit system. There are many reasons to use pls_integer instead of number : pls_integer uses less memory pls_integer uses machine arithmetic, which is up to three times faster than library arithmetic, which is used by number .","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 declare l_result number ( 9 , 0 ) : = 0 ; -- violates also G-2130, G-2230 co_upper_bound constant pls_integer : = 1 e8 ; begin << burning_cpu >> for i in 1 .. co_upper_bound loop if i > 0 then l_result : = l_result + 1 ; end if ; end loop burning_cpu ; sys . dbms_output . put_line ( l_result ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 declare l_result pls_integer : = 0 ; co_upper_bound constant pls_integer : = 1 e8 ; begin << burning_less_cpu >> for i in 1 .. co_upper_bound loop if i > 0 then l_result : = l_result + 1 ; end if ; end loop burning_less_cpu ; sys . dbms_output . put_line ( l_result ); end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/","text":"G-2230: Try to use SIMPLE_INTEGER datatype when appropriate. Critical Efficiency Reason simple_integer does no checks on numeric overflow, which results in better performance compared to the other numeric datatypes. With Oracle Database 11g, the new data type simple_integer has been introduced. It is a sub-type of pls_integer and covers the same range. The basic difference is that simple_integer is always not null . When the value of the declared variable is never going to be null then you can declare it as simple_integer . Another major difference is that you will never face a numeric overflow using simple_integer as this data type wraps around without giving any error. simple_integer data type gives major performance boost over pls_integer when code is compiled in native mode, because arithmetic operations on simple_integer type are performed directly at the hardware level. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 declare l_result number ( 9 , 0 ) : = 0 ; -- violates also G-2130, G-2220 co_upper_bound constant pls_integer : = 1 e8 ; begin << burning_cpu >> for i in 1 .. co_upper_bound loop if i > 0 then l_result : = l_result + 1 ; end if ; end loop burning_cpu ; sys . dbms_output . put_line ( l_result ); end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 declare l_result simple_integer : = 0 ; co_upper_bound constant pls_integer : = 1 e8 ; begin << burning_cpu >> for i in 1 .. co_upper_bound loop if i > 0 then l_result : = l_result + 1 ; end if ; end loop burning_cpu ; sys . dbms_output . put_line ( l_result ); end ; /","title":"G-2230: Try to use SIMPLE_INTEGER datatype when appropriate."},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#g-2230-try-to-use-simple_integer-datatype-when-appropriate","text":"Critical Efficiency","title":"G-2230: Try to use SIMPLE_INTEGER datatype when appropriate."},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#reason","text":"simple_integer does no checks on numeric overflow, which results in better performance compared to the other numeric datatypes. With Oracle Database 11g, the new data type simple_integer has been introduced. It is a sub-type of pls_integer and covers the same range. The basic difference is that simple_integer is always not null . When the value of the declared variable is never going to be null then you can declare it as simple_integer . Another major difference is that you will never face a numeric overflow using simple_integer as this data type wraps around without giving any error. simple_integer data type gives major performance boost over pls_integer when code is compiled in native mode, because arithmetic operations on simple_integer type are performed directly at the hardware level.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 declare l_result number ( 9 , 0 ) : = 0 ; -- violates also G-2130, G-2220 co_upper_bound constant pls_integer : = 1 e8 ; begin << burning_cpu >> for i in 1 .. co_upper_bound loop if i > 0 then l_result : = l_result + 1 ; end if ; end loop burning_cpu ; sys . dbms_output . put_line ( l_result ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 declare l_result simple_integer : = 0 ; co_upper_bound constant pls_integer : = 1 e8 ; begin << burning_cpu >> for i in 1 .. co_upper_bound loop if i > 0 then l_result : = l_result + 1 ; end if ; end loop burning_cpu ; sys . dbms_output . put_line ( l_result ); end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2310/","text":"G-2310: Avoid using CHAR data type. Blocker Reliability Reason char is a fixed length data type, which should only be used when appropriate. char columns/variables are always filled to its specified lengths; this may lead to unwanted side effects and undesired results. Example (bad) 1 2 3 4 5 create or replace package types_up is subtype description_type is char ( 200 ); end types_up ; / Unexpected trailing spaces can lead to wrong results. 1 2 3 4 5 6 7 8 9 with dept as ( select cast ( department_name as varchar2 ( 30 char )) as dname_vc2 , cast ( department_name as char ( 30 char )) as dname_char from departments ) select count ( * ) from dept where dname_vc2 = dname_char ; 1 2 3 COUNT(*) ---------- 0 Example (good) 1 2 3 4 5 create or replace package types_up is subtype description_type is varchar2 ( 200 char ); end types_up ; /","title":"G-2310: Avoid using CHAR data type."},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2310/#g-2310-avoid-using-char-data-type","text":"Blocker Reliability","title":"G-2310: Avoid using CHAR data type."},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2310/#reason","text":"char is a fixed length data type, which should only be used when appropriate. char columns/variables are always filled to its specified lengths; this may lead to unwanted side effects and undesired results.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2310/#example-bad","text":"1 2 3 4 5 create or replace package types_up is subtype description_type is char ( 200 ); end types_up ; / Unexpected trailing spaces can lead to wrong results. 1 2 3 4 5 6 7 8 9 with dept as ( select cast ( department_name as varchar2 ( 30 char )) as dname_vc2 , cast ( department_name as char ( 30 char )) as dname_char from departments ) select count ( * ) from dept where dname_vc2 = dname_char ; 1 2 3 COUNT(*) ---------- 0","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2310/#example-good","text":"1 2 3 4 5 create or replace package types_up is subtype description_type is varchar2 ( 200 char ); end types_up ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2320/","text":"G-2320: Never use VARCHAR data type. Blocker Portability, Reliability Reason Do not use the varchar data type. Use the varchar2 data type instead. Although the varchar data type is currently synonymous with varchar2 , the varchar data type is scheduled to be redefined as a separate data type used for variable-length character strings compared with different comparison semantics. Example (bad) 1 2 3 4 create or replace package types_up is subtype description_type is varchar ( 200 ); end types_up ; / Example (good) 1 2 3 4 create or replace package types_up is subtype description_type is varchar2 ( 200 char ); end types_up ; /","title":"G-2320: Never use VARCHAR data type."},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2320/#g-2320-never-use-varchar-data-type","text":"Blocker Portability, Reliability","title":"G-2320: Never use VARCHAR data type."},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2320/#reason","text":"Do not use the varchar data type. Use the varchar2 data type instead. Although the varchar data type is currently synonymous with varchar2 , the varchar data type is scheduled to be redefined as a separate data type used for variable-length character strings compared with different comparison semantics.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2320/#example-bad","text":"1 2 3 4 create or replace package types_up is subtype description_type is varchar ( 200 ); end types_up ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2320/#example-good","text":"1 2 3 4 create or replace package types_up is subtype description_type is varchar2 ( 200 char ); end types_up ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2330/","text":"G-2330: Never use zero-length strings to substitute NULL. Blocker Portability, Reliability Reason Today zero-length strings and null are currently handled identical by the Oracle Database. There is no guarantee that this will still be the case in future releases, therefore if you mean null use null . Example (bad) 1 2 3 4 5 6 7 8 9 10 11 create or replace package body constants_up is co_null_string constant types_up . text : = '' ; function null_string return varchar2 deterministic is begin return co_null_string ; end null_string ; end constants_up ; / Example (good) 1 2 3 4 5 6 7 8 9 create or replace package body constants_up is function empty_string return varchar2 deterministic is begin return null ; end empty_string ; end constants_up ; /","title":"G-2330: Never use zero-length strings to substitute NULL."},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2330/#g-2330-never-use-zero-length-strings-to-substitute-null","text":"Blocker Portability, Reliability","title":"G-2330: Never use zero-length strings to substitute NULL."},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2330/#reason","text":"Today zero-length strings and null are currently handled identical by the Oracle Database. There is no guarantee that this will still be the case in future releases, therefore if you mean null use null .","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2330/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 create or replace package body constants_up is co_null_string constant types_up . text : = '' ; function null_string return varchar2 deterministic is begin return co_null_string ; end null_string ; end constants_up ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2330/#example-good","text":"1 2 3 4 5 6 7 8 9 create or replace package body constants_up is function empty_string return varchar2 deterministic is begin return null ; end empty_string ; end constants_up ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2340/","text":"G-2340: Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored). Blocker Reliability Reason Changes to the nls_length_semantic will only be picked up by your code after a recompilation. In a multibyte environment a varchar2(10) definition may not necessarily hold 10 characters when multibyte characters are part of the value that should be stored, unless the definition was done using the char semantic. Example (bad) 1 2 3 4 create or replace package types_up is subtype description_type is varchar2 ( 200 ); end types_up ; / Example (good) 1 2 3 4 create or replace package types_up is subtype description_type is varchar2 ( 200 char ); end types_up ; /","title":"G-2340: Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored)."},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2340/#g-2340-always-define-your-varchar2-variables-using-char-semantic-if-not-defined-anchored","text":"Blocker Reliability","title":"G-2340: Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored)."},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2340/#reason","text":"Changes to the nls_length_semantic will only be picked up by your code after a recompilation. In a multibyte environment a varchar2(10) definition may not necessarily hold 10 characters when multibyte characters are part of the value that should be stored, unless the definition was done using the char semantic.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2340/#example-bad","text":"1 2 3 4 create or replace package types_up is subtype description_type is varchar2 ( 200 ); end types_up ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/3-character-data-types/g-2340/#example-good","text":"1 2 3 4 create or replace package types_up is subtype description_type is varchar2 ( 200 char ); end types_up ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/","text":"G-2410: Try to use boolean data type for values with dual meaning. Minor Maintainability Reason The use of true and false clarifies that this is a boolean value and makes the code easier to read. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_newfile constant pls_integer : = 1000 ; co_oldfile constant pls_integer : = 500 ; l_bigger pls_integer ; begin if co_newfile < co_oldfile then l_bigger : = constants_up . co_numeric_true ; else l_bigger : = constants_up . co_numeric_false ; end if ; do_something ( l_bigger ); end ; / Example (better) 1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_newfile constant pls_integer : = 1000 ; co_oldfile constant pls_integer : = 500 ; l_bigger boolean ; begin if co_newfile < co_oldfile then l_bigger : = true ; else l_bigger : = false ; end if ; do_something ( l_bigger ); end ; / Example (good) 1 2 3 4 5 6 7 8 9 declare co_newfile constant pls_integer : = 1000 ; co_oldfile constant pls_integer : = 500 ; l_bigger boolean ; begin l_bigger : = nvl ( co_newfile < co_oldfile , false ); do_something ( l_bigger ); end ; /","title":"G-2410: Try to use boolean data type for values with dual meaning."},{"location":"4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#g-2410-try-to-use-boolean-data-type-for-values-with-dual-meaning","text":"Minor Maintainability","title":"G-2410: Try to use boolean data type for values with dual meaning."},{"location":"4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#reason","text":"The use of true and false clarifies that this is a boolean value and makes the code easier to read.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_newfile constant pls_integer : = 1000 ; co_oldfile constant pls_integer : = 500 ; l_bigger pls_integer ; begin if co_newfile < co_oldfile then l_bigger : = constants_up . co_numeric_true ; else l_bigger : = constants_up . co_numeric_false ; end if ; do_something ( l_bigger ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#example-better","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_newfile constant pls_integer : = 1000 ; co_oldfile constant pls_integer : = 500 ; l_bigger boolean ; begin if co_newfile < co_oldfile then l_bigger : = true ; else l_bigger : = false ; end if ; do_something ( l_bigger ); end ; /","title":"Example (better)"},{"location":"4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#example-good","text":"1 2 3 4 5 6 7 8 9 declare co_newfile constant pls_integer : = 1000 ; co_oldfile constant pls_integer : = 500 ; l_bigger boolean ; begin l_bigger : = nvl ( co_newfile < co_oldfile , false ); do_something ( l_bigger ); end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/5-large-objects/g-2510/","text":"G-2510: Avoid using the LONG and LONG RAW data types. Major Portability Reason long and long raw data types have been deprecated by the Oracle Database since version 8i - support might be discontinued in future Oracle Database releases. There are many constraints to long datatypes in comparison to the lob types. Example (bad) 1 2 3 4 5 6 7 8 declare l_long long ; -- violates also G-2130 l_raw long raw ; -- violates also G-2130 begin do_something ( l_long ); do_something ( l_raw ); end ; / Example (good) 1 2 3 4 5 6 7 8 declare l_long clob ; l_raw blob ; begin do_something ( l_long ); do_something ( l_raw ); end ; /","title":"G-2510: Avoid using the LONG and LONG RAW data types."},{"location":"4-language-usage/2-variables-and-types/5-large-objects/g-2510/#g-2510-avoid-using-the-long-and-long-raw-data-types","text":"Major Portability","title":"G-2510: Avoid using the LONG and LONG RAW data types."},{"location":"4-language-usage/2-variables-and-types/5-large-objects/g-2510/#reason","text":"long and long raw data types have been deprecated by the Oracle Database since version 8i - support might be discontinued in future Oracle Database releases. There are many constraints to long datatypes in comparison to the lob types.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/5-large-objects/g-2510/#example-bad","text":"1 2 3 4 5 6 7 8 declare l_long long ; -- violates also G-2130 l_raw long raw ; -- violates also G-2130 begin do_something ( l_long ); do_something ( l_raw ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/5-large-objects/g-2510/#example-good","text":"1 2 3 4 5 6 7 8 declare l_long clob ; l_raw blob ; begin do_something ( l_long ); do_something ( l_raw ); end ; /","title":"Example (good)"},{"location":"4-language-usage/2-variables-and-types/6-cursor-variables/g-2610/","text":"G-2610: Never use self-defined weak ref cursor types. Minor Changeability, Maintainability, Portability, Reusability Reason There is no reason to define your own weak ref cursor types, as they are not different from the built-in sys_refcursor . Introducing your own types just gives you unnecessary maintenance to perform. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare type local_weak_cursor_type is ref cursor ; c_data local_weak_cursor_type ; begin if configuration . use_employee then open c_data for select e . employee_id , e . first_name , e . last_name from employees e ; else open c_data for select e . emp_id , e . name from emp e ; end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 declare c_data sys_refcursor ; begin if configuration . use_employee then open c_data for select e . employee_id , e . first_name , e . last_name from employees e ; else open c_data for select e . emp_id , e . name from emp e ; end if ; end ; /","title":"G-2610: Never use self-defined weak ref cursor types."},{"location":"4-language-usage/2-variables-and-types/6-cursor-variables/g-2610/#g-2610-never-use-self-defined-weak-ref-cursor-types","text":"Minor Changeability, Maintainability, Portability, Reusability","title":"G-2610: Never use self-defined weak ref cursor types."},{"location":"4-language-usage/2-variables-and-types/6-cursor-variables/g-2610/#reason","text":"There is no reason to define your own weak ref cursor types, as they are not different from the built-in sys_refcursor . Introducing your own types just gives you unnecessary maintenance to perform.","title":"Reason"},{"location":"4-language-usage/2-variables-and-types/6-cursor-variables/g-2610/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare type local_weak_cursor_type is ref cursor ; c_data local_weak_cursor_type ; begin if configuration . use_employee then open c_data for select e . employee_id , e . first_name , e . last_name from employees e ; else open c_data for select e . emp_id , e . name from emp e ; end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/2-variables-and-types/6-cursor-variables/g-2610/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 declare c_data sys_refcursor ; begin if configuration . use_employee then open c_data for select e . employee_id , e . first_name , e . last_name from employees e ; else open c_data for select e . emp_id , e . name from emp e ; end if ; end ; /","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3110/","text":"G-3110: Always specify the target columns when coding an insert statement. Blocker Maintainability, Reliability Reason Data structures often change. Having the target columns in your insert statements will lead to change-resistant code. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 create or replace package body dept_api is procedure ins_dept ( in_dept_row in dept % rowtype ) is begin insert into departments values ( departments_seq . nextval , in_dept_row . department_name , in_dept_row . manager_id , in_dept_row . location_id ); end ins_dept ; end dept_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create or replace package body dept_api is procedure ins_dept ( in_dept_row in dept % rowtype ) is begin insert into departments ( department_id , department_name , manager_id , location_id ) values ( departments_seq . nextval , in_dept_row . department_name , in_dept_row . manager_id , in_dept_row . location_id ); end ins_dept ; end dept_api ; /","title":"G-3110: Always specify the target columns when coding an insert statement."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3110/#g-3110-always-specify-the-target-columns-when-coding-an-insert-statement","text":"Blocker Maintainability, Reliability","title":"G-3110: Always specify the target columns when coding an insert statement."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3110/#reason","text":"Data structures often change. Having the target columns in your insert statements will lead to change-resistant code.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3110/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 create or replace package body dept_api is procedure ins_dept ( in_dept_row in dept % rowtype ) is begin insert into departments values ( departments_seq . nextval , in_dept_row . department_name , in_dept_row . manager_id , in_dept_row . location_id ); end ins_dept ; end dept_api ; /","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3110/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create or replace package body dept_api is procedure ins_dept ( in_dept_row in dept % rowtype ) is begin insert into departments ( department_id , department_name , manager_id , location_id ) values ( departments_seq . nextval , in_dept_row . department_name , in_dept_row . manager_id , in_dept_row . location_id ); end ins_dept ; end dept_api ; /","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3115/","text":"G-3115: Avoid self-assigning a column. Blocker Maintainability Reason There is normally no reason to assign a column to itself. It is either a redundant statement that should be removed, or it is a mistake where some other value was intended in the assignment. One exception to this rule can be when you attempt to fire cross edition triggers when using Edition Based Redefinition. Example (bad) 1 2 update employees set first_name = first_name ; Example (good) 1 2 update employees set first_name = initcap ( first_name );","title":"G-3115: Avoid self-assigning a column."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3115/#g-3115-avoid-self-assigning-a-column","text":"Blocker Maintainability","title":"G-3115: Avoid self-assigning a column."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3115/#reason","text":"There is normally no reason to assign a column to itself. It is either a redundant statement that should be removed, or it is a mistake where some other value was intended in the assignment. One exception to this rule can be when you attempt to fire cross edition triggers when using Edition Based Redefinition.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3115/#example-bad","text":"1 2 update employees set first_name = first_name ;","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3115/#example-good","text":"1 2 update employees set first_name = initcap ( first_name );","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3120/","text":"G-3120: Always use table aliases when your SQL statement involves more than one source. Blocker Maintainability Reason It is more human readable to use aliases instead of writing columns with no table information. Especially when using subqueries the omission of table aliases may end in unexpected behavior and result. Example (bad) 1 2 3 4 5 6 7 select last_name , first_name , department_name from employees join departments using ( department_id ) where extract ( month from hire_date ) = extract ( month from sysdate ); If the jobs table has no employee_id column and employees has one this query will not raise an error but return all rows of the employees table as a subquery is allowed to access columns of all its parent tables - this construct is known as correlated subquery. 1 2 3 4 5 6 7 8 select last_name , first_name from employees where employee_id in ( select employee_id from jobs where job_title like '%Manager%' -- NOSONAR: G-1050 literal is ok for a standalone query ); Example (better) 1 2 3 4 5 6 7 select e . last_name , e . first_name , d . department_name from employees e join departments d on ( e . department_id = d . department_id ) where extract ( month from e . hire_date ) = extract ( month from sysdate ); Example (good) Using meaningful aliases improves the readability of your code. 1 2 3 4 5 6 7 select emp . last_name , emp . first_name , dept . department_name from employees emp join departments dept on ( emp . department_id = dept . department_id ) where extract ( month from emp . hire_date ) = extract ( month from sysdate ); If the jobs table has no employee_id column this query will return an error due to the directive (given by adding the table alias to the column) to read the employee_id column from the jobs table. 1 2 3 4 5 6 7 8 select emp . last_name , emp . first_name from employees emp where emp . employee_id in ( select job . employee_id from jobs job where job . job_title like '%Manager%' -- NOSONAR: G-1050 literal is ok for a standalone query );","title":"G-3120: Always use table aliases when your SQL statement involves more than one source."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3120/#g-3120-always-use-table-aliases-when-your-sql-statement-involves-more-than-one-source","text":"Blocker Maintainability","title":"G-3120: Always use table aliases when your SQL statement involves more than one source."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3120/#reason","text":"It is more human readable to use aliases instead of writing columns with no table information. Especially when using subqueries the omission of table aliases may end in unexpected behavior and result.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3120/#example-bad","text":"1 2 3 4 5 6 7 select last_name , first_name , department_name from employees join departments using ( department_id ) where extract ( month from hire_date ) = extract ( month from sysdate ); If the jobs table has no employee_id column and employees has one this query will not raise an error but return all rows of the employees table as a subquery is allowed to access columns of all its parent tables - this construct is known as correlated subquery. 1 2 3 4 5 6 7 8 select last_name , first_name from employees where employee_id in ( select employee_id from jobs where job_title like '%Manager%' -- NOSONAR: G-1050 literal is ok for a standalone query );","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3120/#example-better","text":"1 2 3 4 5 6 7 select e . last_name , e . first_name , d . department_name from employees e join departments d on ( e . department_id = d . department_id ) where extract ( month from e . hire_date ) = extract ( month from sysdate );","title":"Example (better)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3120/#example-good","text":"Using meaningful aliases improves the readability of your code. 1 2 3 4 5 6 7 select emp . last_name , emp . first_name , dept . department_name from employees emp join departments dept on ( emp . department_id = dept . department_id ) where extract ( month from emp . hire_date ) = extract ( month from sysdate ); If the jobs table has no employee_id column this query will return an error due to the directive (given by adding the table alias to the column) to read the employee_id column from the jobs table. 1 2 3 4 5 6 7 8 select emp . last_name , emp . first_name from employees emp where emp . employee_id in ( select job . employee_id from jobs job where job . job_title like '%Manager%' -- NOSONAR: G-1050 literal is ok for a standalone query );","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3130/","text":"G-3130: Try to use ANSI SQL-92 join syntax. Major Maintainability, Portability Reason ANSI SQL-92 join syntax supports the full outer join. A further advantage of the ANSI SQL-92 join syntax is the separation of the join condition from the query filters. Example (bad) 1 2 3 4 5 6 7 8 select e . employee_id , e . last_name , e . first_name , d . department_name from employees e , departments d where e . department_id = d . department_id and extract ( month from e . hire_date ) = extract ( month from sysdate ); Example (good) 1 2 3 4 5 6 7 8 select emp . employee_id , emp . last_name , emp . first_name , dept . department_name from employees emp join departments dept on dept . department_id = emp . department_id where extract ( month from emp . hire_date ) = extract ( month from sysdate );","title":"G-3130: Try to use ANSI SQL-92 join syntax."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3130/#g-3130-try-to-use-ansi-sql-92-join-syntax","text":"Major Maintainability, Portability","title":"G-3130: Try to use ANSI SQL-92 join syntax."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3130/#reason","text":"ANSI SQL-92 join syntax supports the full outer join. A further advantage of the ANSI SQL-92 join syntax is the separation of the join condition from the query filters.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3130/#example-bad","text":"1 2 3 4 5 6 7 8 select e . employee_id , e . last_name , e . first_name , d . department_name from employees e , departments d where e . department_id = d . department_id and extract ( month from e . hire_date ) = extract ( month from sysdate );","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3130/#example-good","text":"1 2 3 4 5 6 7 8 select emp . employee_id , emp . last_name , emp . first_name , dept . department_name from employees emp join departments dept on dept . department_id = emp . department_id where extract ( month from emp . hire_date ) = extract ( month from sysdate );","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3140/","text":"G-3140: Try to use anchored records as targets for your cursors. Major Maintainability, Reliability Reason Using cursor-anchored records as targets for your cursors results enables the possibility of changing the structure of the cursor without regard to the target structure. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 declare cursor c_employees is select employee_id , first_name , last_name from employees ; l_employee_id employees . employee_id % type ; l_first_name employees . first_name % type ; l_last_name employees . last_name % type ; begin open c_employees ; fetch c_employees into l_employee_id , l_first_name , l_last_name ; << process_employees >> while c_employees % found loop -- do something with the data fetch c_employees into l_employee_id , l_first_name , l_last_name ; end loop process_employees ; close c_employees ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 declare cursor c_employees is select employee_id , first_name , last_name from employees ; r_employee c_employees % rowtype ; begin open c_employees ; fetch c_employees into r_employee ; << process_employees >> while c_employees % found loop -- do something with the data fetch c_employees into r_employee ; end loop process_employees ; close c_employees ; end ; /","title":"G-3140: Try to use anchored records as targets for your cursors."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3140/#g-3140-try-to-use-anchored-records-as-targets-for-your-cursors","text":"Major Maintainability, Reliability","title":"G-3140: Try to use anchored records as targets for your cursors."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3140/#reason","text":"Using cursor-anchored records as targets for your cursors results enables the possibility of changing the structure of the cursor without regard to the target structure.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3140/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 declare cursor c_employees is select employee_id , first_name , last_name from employees ; l_employee_id employees . employee_id % type ; l_first_name employees . first_name % type ; l_last_name employees . last_name % type ; begin open c_employees ; fetch c_employees into l_employee_id , l_first_name , l_last_name ; << process_employees >> while c_employees % found loop -- do something with the data fetch c_employees into l_employee_id , l_first_name , l_last_name ; end loop process_employees ; close c_employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3140/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 declare cursor c_employees is select employee_id , first_name , last_name from employees ; r_employee c_employees % rowtype ; begin open c_employees ; fetch c_employees into r_employee ; << process_employees >> while c_employees % found loop -- do something with the data fetch c_employees into r_employee ; end loop process_employees ; close c_employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3145/","text":"G-3145: Avoid using SELECT * directly from a table or view. Blocker Efficiency, Maintainability, Reliability, Testability Reason Use of SELECT * when querying a table or view makes it impossible for the optimizer to take into account which columns will actually be used by the application, potentially leading to sub-optimal execution plans (for example full scanning the table where a full scan of an index might have sufficed.) Also SELECT * possibly can break your code in the future in case of changes to the table structure (for example new or invisible columns.) Exceptions to the rule can be when querying an inline view (where the SELECT * is just to avoid repeating same columns as inside the inline view), or when fetching into records defined as MYTABLE%ROWTYPE for the purpose of processing all columns of the record. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 begin << raise_salary >> for r_employee in ( select * from employees ) loop employee_api . calculate_raise_by_seniority ( id_in => r_employee . id , salary_in => r_employee . salary , hiredate_in => r_employee . hiredate ); end loop raise_salary ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 begin << raise_salary >> for r_employee in ( select id , salary , hiredate from employees ) loop employee_api . calculate_raise_by_seniority ( id_in => r_employee . id , salary_in => r_employee . salary , hiredate_in => r_employee . hiredate ); end loop raise_salary ; end ; /","title":"G-3145: Avoid using SELECT * directly from a table or view."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3145/#g-3145-avoid-using-select-directly-from-a-table-or-view","text":"Blocker Efficiency, Maintainability, Reliability, Testability","title":"G-3145: Avoid using SELECT * directly from a table or view."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3145/#reason","text":"Use of SELECT * when querying a table or view makes it impossible for the optimizer to take into account which columns will actually be used by the application, potentially leading to sub-optimal execution plans (for example full scanning the table where a full scan of an index might have sufficed.) Also SELECT * possibly can break your code in the future in case of changes to the table structure (for example new or invisible columns.) Exceptions to the rule can be when querying an inline view (where the SELECT * is just to avoid repeating same columns as inside the inline view), or when fetching into records defined as MYTABLE%ROWTYPE for the purpose of processing all columns of the record.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3145/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 begin << raise_salary >> for r_employee in ( select * from employees ) loop employee_api . calculate_raise_by_seniority ( id_in => r_employee . id , salary_in => r_employee . salary , hiredate_in => r_employee . hiredate ); end loop raise_salary ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3145/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 begin << raise_salary >> for r_employee in ( select id , salary , hiredate from employees ) loop employee_api . calculate_raise_by_seniority ( id_in => r_employee . id , salary_in => r_employee . salary , hiredate_in => r_employee . hiredate ); end loop raise_salary ; end ; /","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3150/","text":"G-3150: Try to use identity columns for surrogate keys. Critical Maintainability, Reliability Restriction Oracle Database 12c Reason An identity column is a surrogate key by design \u2013 there is no reason why we should not take advantage of this natural implementation when the keys are generated on database level. Using identity column (and therefore assigning sequences as default values on columns) has a huge performance advantage over a trigger solution. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create table locations ( location_id number ( 10 ) not null , location_name varchar2 ( 60 char ) not null , city varchar2 ( 30 char ) not null , constraint locations_pk primary key ( location_id ) ) / create sequence location_seq start with 1 cache 20 / create or replace trigger location_br_i before insert on locations for each row begin : new . location_id : = location_seq . nextval ; end ; / Example (good) 1 2 3 4 5 6 create table locations ( location_id number ( 10 ) generated always as identity , location_name varchar2 ( 60 char ) not null , city varchar2 ( 30 char ) not null , constraint locations_pk primary key ( location_id )) / generated always as identity ensures that the location_id is populated by a sequence. It is not possible to override the behavior in the application. However, if you use a framework that produces an insert statement including the surrogate key column, and you cannot change this behavior, then you have to use the generated by default on null as identity option. This has the downside that the application may pass a value, which might lead to an immediate or delayed ORA-00001: unique constraint violated error.","title":"G-3150: Try to use identity columns for surrogate keys."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3150/#g-3150-try-to-use-identity-columns-for-surrogate-keys","text":"Critical Maintainability, Reliability","title":"G-3150: Try to use identity columns for surrogate keys."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3150/#restriction","text":"Oracle Database 12c","title":"Restriction"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3150/#reason","text":"An identity column is a surrogate key by design \u2013 there is no reason why we should not take advantage of this natural implementation when the keys are generated on database level. Using identity column (and therefore assigning sequences as default values on columns) has a huge performance advantage over a trigger solution.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3150/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create table locations ( location_id number ( 10 ) not null , location_name varchar2 ( 60 char ) not null , city varchar2 ( 30 char ) not null , constraint locations_pk primary key ( location_id ) ) / create sequence location_seq start with 1 cache 20 / create or replace trigger location_br_i before insert on locations for each row begin : new . location_id : = location_seq . nextval ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3150/#example-good","text":"1 2 3 4 5 6 create table locations ( location_id number ( 10 ) generated always as identity , location_name varchar2 ( 60 char ) not null , city varchar2 ( 30 char ) not null , constraint locations_pk primary key ( location_id )) / generated always as identity ensures that the location_id is populated by a sequence. It is not possible to override the behavior in the application. However, if you use a framework that produces an insert statement including the surrogate key column, and you cannot change this behavior, then you have to use the generated by default on null as identity option. This has the downside that the application may pass a value, which might lead to an immediate or delayed ORA-00001: unique constraint violated error.","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3160/","text":"G-3160: Avoid visible virtual columns. Blocker Maintainability, Reliability Unsupported in db* CODECOP Validators We cannot identify the type of a column. Requires create table and alter table parser support or access to the Oracle Data Dictionary. Restriction Oracle Database 12c Reason In contrast to visible columns, invisible columns are not part of a record defined using %rowtype construct. This is helpful as a virtual column may not be programmatically populated. If your virtual column is visible you have to manually define the record types used in API packages to be able to exclude them from being part of the record definition. Invisible columns may be accessed by explicitly adding them to the column list in a select statement. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 declare r_employee employees % rowtype ; co_id constant employees . employee_id % type : = 107 ; begin r_employee : = employee_api . employee_by_id ( l_id ); r_employee . salary : = r_employee . salary * constants_up . small_increase (); update employees set row = r_employee where employee_id = co_id ; end ; / 1 2 3 Error report - ORA-54017: update operation disallowed on virtual columns ORA-06512: at line 9 Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 alter table employees add total_salary invisible generated always as ( salary + nvl ( commission_pct , 0 ) * salary ) / declare r_employee employees % rowtype ; co_id constant employees . employee_id % type : = 107 ; begin r_employee : = employee_api . employee_by_id ( co_id ); r_employee . salary : = r_employee . salary * constants_up . small_increase (); update employees set row = r_employee where employee_id = co_id ; end ; /","title":"G-3160: Avoid visible virtual columns."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3160/#g-3160-avoid-visible-virtual-columns","text":"Blocker Maintainability, Reliability Unsupported in db* CODECOP Validators We cannot identify the type of a column. Requires create table and alter table parser support or access to the Oracle Data Dictionary.","title":"G-3160: Avoid visible virtual columns."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3160/#restriction","text":"Oracle Database 12c","title":"Restriction"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3160/#reason","text":"In contrast to visible columns, invisible columns are not part of a record defined using %rowtype construct. This is helpful as a virtual column may not be programmatically populated. If your virtual column is visible you have to manually define the record types used in API packages to be able to exclude them from being part of the record definition. Invisible columns may be accessed by explicitly adding them to the column list in a select statement.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3160/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 declare r_employee employees % rowtype ; co_id constant employees . employee_id % type : = 107 ; begin r_employee : = employee_api . employee_by_id ( l_id ); r_employee . salary : = r_employee . salary * constants_up . small_increase (); update employees set row = r_employee where employee_id = co_id ; end ; / 1 2 3 Error report - ORA-54017: update operation disallowed on virtual columns ORA-06512: at line 9","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3160/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 alter table employees add total_salary invisible generated always as ( salary + nvl ( commission_pct , 0 ) * salary ) / declare r_employee employees % rowtype ; co_id constant employees . employee_id % type : = 107 ; begin r_employee : = employee_api . employee_by_id ( co_id ); r_employee . salary : = r_employee . salary * constants_up . small_increase (); update employees set row = r_employee where employee_id = co_id ; end ; /","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3170/","text":"G-3170: Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values. Blocker Reliability Unsupported in db* CODECOP Validators We cannot identify column default values. Requires create table and alter table parser support or access to the Oracle Data Dictionary. Restriction Oracle Database 12c Reason Default values have been nullifiable until Oracle Database 12c. Meaning any tool sending null as a value for a column having a default value bypassed the default value. Starting with Oracle Database 12c default definitions may have an on null definition in addition, which will assign the default value in case of a null value too. Example (bad) 1 2 3 4 5 6 7 8 9 create table null_test ( test_case number ( 2 ) not null , column_defaulted varchar2 ( 10 char ) default 'Default' ) / insert into null_test ( test_case , column_defaulted ) values ( 1 , 'Value' ); -- NOSONAR: G-1050 literal is ok for a standalone insert insert into null_test ( test_case , column_defaulted ) values ( 2 , default ); -- NOSONAR: G-1050 literal is ok for a standalone insert insert into null_test ( test_case , column_defaulted ) values ( 3 , null ); -- NOSONAR: G-1050 literal is ok for a standalone insert select test_case , column_defaulted from null_test ; 1 2 3 4 5 TEST_CASE COLUMN_DEF --------- ----------- 1 Value 2 Default 3 Example (good) 1 2 3 4 5 6 7 8 9 create table null_test ( test_case number ( 2 ) not null , column_defaulted varchar2 ( 10 char ) default on null 'Default' ) / insert into null_test ( test_case , column_defaulted ) values ( 1 , 'Value' ); -- NOSONAR: G-1050 literal is ok for a standalone insert insert into null_test ( test_case , column_defaulted ) values ( 2 , default ); -- NOSONAR: G-1050 literal is ok for a standalone insert insert into null_test ( test_case , column_defaulted ) values ( 3 , null ); -- NOSONAR: G-1050 literal is ok for a standalone insert select test_case , column_defaulted from null_test ; 1 2 3 4 5 TEST_CASE COLUMN_DEF ---------- ---------- 1 Value 2 Default 3 Default","title":"G-3170: Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3170/#g-3170-always-use-default-on-null-declarations-to-assign-default-values-to-table-columns-if-you-refuse-to-store-null-values","text":"Blocker Reliability Unsupported in db* CODECOP Validators We cannot identify column default values. Requires create table and alter table parser support or access to the Oracle Data Dictionary.","title":"G-3170: Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3170/#restriction","text":"Oracle Database 12c","title":"Restriction"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3170/#reason","text":"Default values have been nullifiable until Oracle Database 12c. Meaning any tool sending null as a value for a column having a default value bypassed the default value. Starting with Oracle Database 12c default definitions may have an on null definition in addition, which will assign the default value in case of a null value too.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3170/#example-bad","text":"1 2 3 4 5 6 7 8 9 create table null_test ( test_case number ( 2 ) not null , column_defaulted varchar2 ( 10 char ) default 'Default' ) / insert into null_test ( test_case , column_defaulted ) values ( 1 , 'Value' ); -- NOSONAR: G-1050 literal is ok for a standalone insert insert into null_test ( test_case , column_defaulted ) values ( 2 , default ); -- NOSONAR: G-1050 literal is ok for a standalone insert insert into null_test ( test_case , column_defaulted ) values ( 3 , null ); -- NOSONAR: G-1050 literal is ok for a standalone insert select test_case , column_defaulted from null_test ; 1 2 3 4 5 TEST_CASE COLUMN_DEF --------- ----------- 1 Value 2 Default 3","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3170/#example-good","text":"1 2 3 4 5 6 7 8 9 create table null_test ( test_case number ( 2 ) not null , column_defaulted varchar2 ( 10 char ) default on null 'Default' ) / insert into null_test ( test_case , column_defaulted ) values ( 1 , 'Value' ); -- NOSONAR: G-1050 literal is ok for a standalone insert insert into null_test ( test_case , column_defaulted ) values ( 2 , default ); -- NOSONAR: G-1050 literal is ok for a standalone insert insert into null_test ( test_case , column_defaulted ) values ( 3 , null ); -- NOSONAR: G-1050 literal is ok for a standalone insert select test_case , column_defaulted from null_test ; 1 2 3 4 5 TEST_CASE COLUMN_DEF ---------- ---------- 1 Value 2 Default 3 Default","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3180/","text":"G-3180: Always specify column names instead of positional references in ORDER BY clauses. Major Changeability, Reliability Reason If you change your select list afterwards the order by will still work but order your rows differently, when not changing the positional number. Furthermore, it is not comfortable to the readers of the code, if they have to count the columns in the select list to know the way the result is ordered. Example (bad) 1 2 3 4 5 6 select upper ( first_name ) , last_name , salary , hire_date from employees order by 4 , 1 , 3 ; Example (good) 1 2 3 4 5 6 7 8 select upper ( first_name ) as first_name , last_name , salary , hire_date from employees order by hire_date , first_name , salary ;","title":"G-3180: Always specify column names instead of positional references in ORDER BY clauses."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3180/#g-3180-always-specify-column-names-instead-of-positional-references-in-order-by-clauses","text":"Major Changeability, Reliability","title":"G-3180: Always specify column names instead of positional references in ORDER BY clauses."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3180/#reason","text":"If you change your select list afterwards the order by will still work but order your rows differently, when not changing the positional number. Furthermore, it is not comfortable to the readers of the code, if they have to count the columns in the select list to know the way the result is ordered.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3180/#example-bad","text":"1 2 3 4 5 6 select upper ( first_name ) , last_name , salary , hire_date from employees order by 4 , 1 , 3 ;","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3180/#example-good","text":"1 2 3 4 5 6 7 8 select upper ( first_name ) as first_name , last_name , salary , hire_date from employees order by hire_date , first_name , salary ;","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3182/","text":"G-3182: Always specify column names/aliases instead of positional references in GROUP BY clauses. Blocker Reliability Restriction Oracle Database 23c Reason If you use a numeric literal in the group by clause in an Oracle Database prior to version 23c, then this literal is not required. It is simply a constant. Starting with Oracle Database 23c, it is possible to use a literal in the group by clause to refer to a column name or column alias in the select list. However, this only works if the group_by_position_enabled parameter is set to true . In any case, it is not convenient for the readers of the code to have to count the columns in the select list to know how the result is grouped. Since the meaning of a literal depends on the configuration and database version, the intention is unclear and might lead to an incorrect result. Example (bad) 1 2 3 4 5 select job_id , sum ( salary ) as sum_salary from employees group by job_id , 2 order by job_id ; Example (good) 1 2 3 4 5 select job_id , sum ( salary ) as sum_salary from employees group by job_id order by job_id ;","title":"G-3182: Always specify column names/aliases instead of positional references in GROUP BY clauses."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3182/#g-3182-always-specify-column-namesaliases-instead-of-positional-references-in-group-by-clauses","text":"Blocker Reliability","title":"G-3182: Always specify column names/aliases instead of positional references in GROUP BY clauses."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3182/#restriction","text":"Oracle Database 23c","title":"Restriction"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3182/#reason","text":"If you use a numeric literal in the group by clause in an Oracle Database prior to version 23c, then this literal is not required. It is simply a constant. Starting with Oracle Database 23c, it is possible to use a literal in the group by clause to refer to a column name or column alias in the select list. However, this only works if the group_by_position_enabled parameter is set to true . In any case, it is not convenient for the readers of the code to have to count the columns in the select list to know how the result is grouped. Since the meaning of a literal depends on the configuration and database version, the intention is unclear and might lead to an incorrect result.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3182/#example-bad","text":"1 2 3 4 5 select job_id , sum ( salary ) as sum_salary from employees group by job_id , 2 order by job_id ;","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3182/#example-good","text":"1 2 3 4 5 select job_id , sum ( salary ) as sum_salary from employees group by job_id order by job_id ;","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3183/","text":"G-3183: Always specify column aliases instead of expressions in GROUP BY clauses. Minor Maintainability Restriction Oracle Database 23c Reason Starting with Oracle Database 23c, it is possible to use a column alias in the group by clause instead of repeating the expression used in the select list. Unless you use rollup , cube or grouping sets , it is not necessary to use expressions in the group by clause. Example (bad) 1 2 3 4 5 select lower ( job_id ) as job , sum ( salary ) as sum_salary from employees group by lower ( job_id ) order by job ; Example (good) 1 2 3 4 5 select lower ( job_id ) as job , sum ( salary ) as sum_salary from employees group by job order by job ;","title":"G-3183: Always specify column aliases instead of expressions in GROUP BY clauses."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3183/#g-3183-always-specify-column-aliases-instead-of-expressions-in-group-by-clauses","text":"Minor Maintainability","title":"G-3183: Always specify column aliases instead of expressions in GROUP BY clauses."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3183/#restriction","text":"Oracle Database 23c","title":"Restriction"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3183/#reason","text":"Starting with Oracle Database 23c, it is possible to use a column alias in the group by clause instead of repeating the expression used in the select list. Unless you use rollup , cube or grouping sets , it is not necessary to use expressions in the group by clause.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3183/#example-bad","text":"1 2 3 4 5 select lower ( job_id ) as job , sum ( salary ) as sum_salary from employees group by lower ( job_id ) order by job ;","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3183/#example-good","text":"1 2 3 4 5 select lower ( job_id ) as job , sum ( salary ) as sum_salary from employees group by job order by job ;","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3185/","text":"G-3185: Never use ROWNUM at the same query level as ORDER BY. Blocker Reliability, Testability Reason The rownum pseudo-column is assigned before the order by clause is used, so using rownum on the same query level as order by will not assign numbers in the desired ordering. Instead you should move the order by into an inline view and use rownum in the outer query. Example (bad) 1 2 3 4 5 6 7 8 select first_name , last_name , salary , hire_date , rownum as salary_rank from employees where rownum <= 5 -- violates also G-1050 literal is ok for a standalone query order by salary desc ; Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 select first_name , last_name , salary , hire_date , rownum as salary_rank from ( select first_name , last_name , salary , hire_date from employees order by salary desc ) where rownum <= 5 ; -- NOSONAR: G-1050 literal is ok for a standalone query Example (best) (Assuming you are using Oracle Database 12c or later.) 1 2 3 4 5 6 7 8 select first_name , last_name , salary , hire_date , rank () over ( order by salary desc ) as salary_rank from employees order by salary desc fetch first 5 rows only ; -- NOSONAR: G-1050 literal is ok for a standalone query","title":"G-3185: Never use ROWNUM at the same query level as ORDER BY."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3185/#g-3185-never-use-rownum-at-the-same-query-level-as-order-by","text":"Blocker Reliability, Testability","title":"G-3185: Never use ROWNUM at the same query level as ORDER BY."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3185/#reason","text":"The rownum pseudo-column is assigned before the order by clause is used, so using rownum on the same query level as order by will not assign numbers in the desired ordering. Instead you should move the order by into an inline view and use rownum in the outer query.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3185/#example-bad","text":"1 2 3 4 5 6 7 8 select first_name , last_name , salary , hire_date , rownum as salary_rank from employees where rownum <= 5 -- violates also G-1050 literal is ok for a standalone query order by salary desc ;","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3185/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 select first_name , last_name , salary , hire_date , rownum as salary_rank from ( select first_name , last_name , salary , hire_date from employees order by salary desc ) where rownum <= 5 ; -- NOSONAR: G-1050 literal is ok for a standalone query","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3185/#example-best","text":"(Assuming you are using Oracle Database 12c or later.) 1 2 3 4 5 6 7 8 select first_name , last_name , salary , hire_date , rank () over ( order by salary desc ) as salary_rank from employees order by salary desc fetch first 5 rows only ; -- NOSONAR: G-1050 literal is ok for a standalone query","title":"Example (best)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3190/","text":"G-3190: Avoid using NATURAL JOIN. Blocker Changeability, Reliability Reason A natural join joins tables on equally named columns. This may comfortably fit on first sight, but adding logging columns to a table ( changed_by , changed_date ) will result in inappropriate join conditions. Example (bad) 1 2 3 4 5 6 7 select d . department_name , e . last_name , e . first_name from employees e natural join departments d order by d . department_name , e . last_name ; 1 2 3 4 5 DEPARTMENT_NAME LAST_NAME FIRST_NAME ------------------------------ ------------------------- -------------------- Accounting Gietz William Executive De Haan Lex ... 1 2 3 4 5 6 7 8 9 10 alter table departments add modified_at date default on null sysdate ; alter table employees add modified_at date default on null sysdate ; select d . department_name , e . last_name , e . first_name from employees e natural join departments d order by d . department_name , e . last_name ; 1 No data found Example (good) 1 2 3 4 5 6 7 8 select d . department_name , e . last_name , e . first_name from employees e join departments d on ( e . department_id = d . department_id ) order by d . department_name , e . last_name ; 1 2 3 4 5 DEPARTMENT_NAME LAST_NAME FIRST_NAME ------------------------------ ------------------------- -------------------- Accounting Gietz William Executive De Haan Lex ...","title":"G-3190: Avoid using NATURAL JOIN."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3190/#g-3190-avoid-using-natural-join","text":"Blocker Changeability, Reliability","title":"G-3190: Avoid using NATURAL JOIN."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3190/#reason","text":"A natural join joins tables on equally named columns. This may comfortably fit on first sight, but adding logging columns to a table ( changed_by , changed_date ) will result in inappropriate join conditions.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3190/#example-bad","text":"1 2 3 4 5 6 7 select d . department_name , e . last_name , e . first_name from employees e natural join departments d order by d . department_name , e . last_name ; 1 2 3 4 5 DEPARTMENT_NAME LAST_NAME FIRST_NAME ------------------------------ ------------------------- -------------------- Accounting Gietz William Executive De Haan Lex ... 1 2 3 4 5 6 7 8 9 10 alter table departments add modified_at date default on null sysdate ; alter table employees add modified_at date default on null sysdate ; select d . department_name , e . last_name , e . first_name from employees e natural join departments d order by d . department_name , e . last_name ; 1 No data found","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3190/#example-good","text":"1 2 3 4 5 6 7 8 select d . department_name , e . last_name , e . first_name from employees e join departments d on ( e . department_id = d . department_id ) order by d . department_name , e . last_name ; 1 2 3 4 5 DEPARTMENT_NAME LAST_NAME FIRST_NAME ------------------------------ ------------------------- -------------------- Accounting Gietz William Executive De Haan Lex ...","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3195/","text":"G-3195: Always use wildcards in a LIKE clause. Blocker Maintainability Reason Using like without at least one wildcard ( % or _ ) is unclear to a maintainer whether a wildcard is forgotten or it is meant as equality test. A common antipattern is also to forget that an underscore is a wildcard, so using like instead of equal can return unwanted rows. If the char datatype is involved, there is also the danger of like not using blank padded comparison where equal will. Depending on use case, you should either remember at least one wildcard or use normal equality operator. Example (bad) 1 2 3 4 select e . employee_id , e . last_name from employees e where e . last_name like 'Smith' ; -- violates also G-1050 literal is ok for a standalone query Example (good) Using a wildcard: 1 2 3 4 select e . employee_id , e . last_name from employees e where e . last_name like 'Smith%' ; Change to equality operator instead: 1 2 3 4 select e . employee_id , e . last_name from employees e where e . last_name = 'Smith' ; -- NOSONAR: G-1050 literal is ok for a standalone query","title":"G-3195: Always use wildcards in a LIKE clause."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3195/#g-3195-always-use-wildcards-in-a-like-clause","text":"Blocker Maintainability","title":"G-3195: Always use wildcards in a LIKE clause."},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3195/#reason","text":"Using like without at least one wildcard ( % or _ ) is unclear to a maintainer whether a wildcard is forgotten or it is meant as equality test. A common antipattern is also to forget that an underscore is a wildcard, so using like instead of equal can return unwanted rows. If the char datatype is involved, there is also the danger of like not using blank padded comparison where equal will. Depending on use case, you should either remember at least one wildcard or use normal equality operator.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3195/#example-bad","text":"1 2 3 4 select e . employee_id , e . last_name from employees e where e . last_name like 'Smith' ; -- violates also G-1050 literal is ok for a standalone query","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/1-general/g-3195/#example-good","text":"Using a wildcard: 1 2 3 4 select e . employee_id , e . last_name from employees e where e . last_name like 'Smith%' ; Change to equality operator instead: 1 2 3 4 select e . employee_id , e . last_name from employees e where e . last_name = 'Smith' ; -- NOSONAR: G-1050 literal is ok for a standalone query","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/2-bulk-operations/g-3210/","text":"G-3210: Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement for more than 4 times. Critical Efficiency Reason Context switches between PL/SQL and SQL are extremely costly. BULK Operations reduce the number of switches by passing an array to the SQL engine, which is used to execute the given statements repeatedly. (Depending on the PLSQL_OPTIMIZE_LEVEL parameter a conversion to BULK COLLECT will be done by the PL/SQL compiler automatically.) Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 declare t_employee_ids employee_api . t_employee_ids_type ; co_increase constant employees . salary % type : = 0 . 1 ; co_department_id constant departments . department_id % type : = 10 ; begin t_employee_ids : = employee_api . employee_ids_by_department ( id_in => co_department_id ); << process_employees >> for i in 1 .. t_employee_ids . count () loop update employees set salary = salary + ( salary * co_increase ) where employee_id = t_employee_ids ( i ); end loop process_employees ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare t_employee_ids employee_api . t_employee_ids_type ; co_increase constant employees . salary % type : = 0 . 1 ; co_department_id constant departments . department_id % type : = 10 ; begin t_employee_ids : = employee_api . employee_ids_by_department ( id_in => co_department_id ); << process_employees >> forall i in 1 .. t_employee_ids . count () update employees set salary = salary + ( salary * co_increase ) where employee_id = t_employee_ids ( i ); end ; /","title":"G-3210: Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement for more than 4 times."},{"location":"4-language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#g-3210-always-use-bulk-operations-bulk-collect-forall-whenever-you-have-to-execute-a-dml-statement-for-more-than-4-times","text":"Critical Efficiency","title":"G-3210: Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement for more than 4 times."},{"location":"4-language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#reason","text":"Context switches between PL/SQL and SQL are extremely costly. BULK Operations reduce the number of switches by passing an array to the SQL engine, which is used to execute the given statements repeatedly. (Depending on the PLSQL_OPTIMIZE_LEVEL parameter a conversion to BULK COLLECT will be done by the PL/SQL compiler automatically.)","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 declare t_employee_ids employee_api . t_employee_ids_type ; co_increase constant employees . salary % type : = 0 . 1 ; co_department_id constant departments . department_id % type : = 10 ; begin t_employee_ids : = employee_api . employee_ids_by_department ( id_in => co_department_id ); << process_employees >> for i in 1 .. t_employee_ids . count () loop update employees set salary = salary + ( salary * co_increase ) where employee_id = t_employee_ids ( i ); end loop process_employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare t_employee_ids employee_api . t_employee_ids_type ; co_increase constant employees . salary % type : = 0 . 1 ; co_department_id constant departments . department_id % type : = 10 ; begin t_employee_ids : = employee_api . employee_ids_by_department ( id_in => co_department_id ); << process_employees >> forall i in 1 .. t_employee_ids . count () update employees set salary = salary + ( salary * co_increase ) where employee_id = t_employee_ids ( i ); end ; /","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/2-bulk-operations/g-3220/","text":"G-3220: Always process saved exceptions from a FORALL statement. Critical Reliability, Testability Reason Using save exceptions in a forall statement without actually processing the saved exceptions is just wasted work. If your use of forall is meant to be atomic (all or nothing), don't use save exceptions . If you want to handle errors of individual rows and do use save exceptions , always include an exception handler block with a loop to process the saved exceptions. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 declare t_employee_ids employee_api . t_employee_ids_type ; co_increase constant employees . salary % type : = 0 . 1 ; co_department_id constant departments . department_id % type : = 10 ; e_bulk_errors exception ; pragma exception_init ( e_bulk_errors , - 24381 ); begin t_employee_ids : = employee_api . employee_ids_by_department ( id_in => co_department_id ); << process_employees >> forall i in 1 .. t_employee_ids . count () save exceptions update employees set salary = salary + ( salary * co_increase ) where employee_id = t_employee_ids ( i ); end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 declare t_employee_ids employee_api . t_employee_ids_type ; co_increase constant employees . salary % type : = 0 . 1 ; co_department_id constant departments . department_id % type : = 10 ; e_bulk_errors exception ; pragma exception_init ( e_bulk_errors , - 24381 ); begin t_employee_ids : = employee_api . employee_ids_by_department ( id_in => co_department_id ); << process_employees >> forall i in 1 .. t_employee_ids . count () save exceptions update employees set salary = salary + ( salary * co_increase ) where employee_id = t_employee_ids ( i ); exception when e_bulk_errors then << handle_bulk_exceptions >> for i in 1 .. sql % bulk_exceptions . count loop logger . log ( sql % bulk_exceptions ( i ). error_code ); end loop handle_bulk_exceptions ; end ; /","title":"G-3220: Always process saved exceptions from a FORALL statement."},{"location":"4-language-usage/3-dml-and-sql/2-bulk-operations/g-3220/#g-3220-always-process-saved-exceptions-from-a-forall-statement","text":"Critical Reliability, Testability","title":"G-3220: Always process saved exceptions from a FORALL statement."},{"location":"4-language-usage/3-dml-and-sql/2-bulk-operations/g-3220/#reason","text":"Using save exceptions in a forall statement without actually processing the saved exceptions is just wasted work. If your use of forall is meant to be atomic (all or nothing), don't use save exceptions . If you want to handle errors of individual rows and do use save exceptions , always include an exception handler block with a loop to process the saved exceptions.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/2-bulk-operations/g-3220/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 declare t_employee_ids employee_api . t_employee_ids_type ; co_increase constant employees . salary % type : = 0 . 1 ; co_department_id constant departments . department_id % type : = 10 ; e_bulk_errors exception ; pragma exception_init ( e_bulk_errors , - 24381 ); begin t_employee_ids : = employee_api . employee_ids_by_department ( id_in => co_department_id ); << process_employees >> forall i in 1 .. t_employee_ids . count () save exceptions update employees set salary = salary + ( salary * co_increase ) where employee_id = t_employee_ids ( i ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/2-bulk-operations/g-3220/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 declare t_employee_ids employee_api . t_employee_ids_type ; co_increase constant employees . salary % type : = 0 . 1 ; co_department_id constant departments . department_id % type : = 10 ; e_bulk_errors exception ; pragma exception_init ( e_bulk_errors , - 24381 ); begin t_employee_ids : = employee_api . employee_ids_by_department ( id_in => co_department_id ); << process_employees >> forall i in 1 .. t_employee_ids . count () save exceptions update employees set salary = salary + ( salary * co_increase ) where employee_id = t_employee_ids ( i ); exception when e_bulk_errors then << handle_bulk_exceptions >> for i in 1 .. sql % bulk_exceptions . count loop logger . log ( sql % bulk_exceptions ( i ). error_code ); end loop handle_bulk_exceptions ; end ; /","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3310/","text":"G-3310: Never commit within a cursor loop. Blocker Efficiency, Reliability Reason Doing frequent commits within a cursor loop (all types of loops over cursors, whether implicit cursor for loop or loop with explicit fetch from cursor or cursor variable) risks not being able to complete due to ORA-01555, gives bad performance, and risks that the work is left in an unknown half-finished state and cannot be restarted. If the work belongs together (an atomic transaction) the commit should be moved to after the loop. Or even better if the logic can be rewritten to a single DML statement on all relevant rows instead of a loop, committing after the single statement. If each loop iteration is a self-contained atomic transaction, consider instead to populate a collection of transactions to be done (taking restartability into account by collection population), loop over that collection (instead of looping over a cursor) and call a procedure (that contains the transaction logic and the commit ) in the loop (see also G-3320 ). Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 declare l_counter integer : = 0 ; l_discount discount . percentage % type ; co_status_new constant orders . order_status % type : = 'New' ; co_commit_interval constant integer : = 100 ; begin << new_orders >> for r_order in ( select o . order_id , o . customer_id from orders o where o . order_status = co_status_new ) loop l_discount : = sales_api . calculate_discount ( p_customer_id => r_order . customer_id ); update order_lines ol -- NOSONAR: violates G-3210 set ol . discount = l_discount where ol . order_id = r_order . order_id ; l_counter : = l_counter + 1 ; if l_counter = co_commit_interval then commit ; l_counter : = 0 ; end if ; end loop new_orders ; if l_counter > 0 then commit ; end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 declare l_discount discount . percentage % type ; co_status_new constant orders . order_status % type : = 'New' ; begin << new_orders >> for r_order in ( select o . order_id , o . customer_id from orders o where o . order_status = co_status_new ) loop l_discount : = sales_api . calculate_discount ( p_customer_id => r_order . customer_id ); update order_lines ol -- NOSONAR: violates G-3210 set ol . discount = l_discount where ol . order_id = r_order . order_id ; end loop new_orders ; commit ; end ; / Example (best) (Assuming suitable foreign key relationship exists to allow updating a join.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare co_status_new constant orders . order_status % type : = 'New' ; begin update ( select o . customer_id , ol . discount from orders o join order_lines ol on ol . order_id = o . order_id where o . order_status = co_status_new ) set discount = sales_api . calculate_discount ( p_customer_id => customer_id ); commit ; end ; /","title":"G-3310: Never commit within a cursor loop."},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3310/#g-3310-never-commit-within-a-cursor-loop","text":"Blocker Efficiency, Reliability","title":"G-3310: Never commit within a cursor loop."},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3310/#reason","text":"Doing frequent commits within a cursor loop (all types of loops over cursors, whether implicit cursor for loop or loop with explicit fetch from cursor or cursor variable) risks not being able to complete due to ORA-01555, gives bad performance, and risks that the work is left in an unknown half-finished state and cannot be restarted. If the work belongs together (an atomic transaction) the commit should be moved to after the loop. Or even better if the logic can be rewritten to a single DML statement on all relevant rows instead of a loop, committing after the single statement. If each loop iteration is a self-contained atomic transaction, consider instead to populate a collection of transactions to be done (taking restartability into account by collection population), loop over that collection (instead of looping over a cursor) and call a procedure (that contains the transaction logic and the commit ) in the loop (see also G-3320 ).","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3310/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 declare l_counter integer : = 0 ; l_discount discount . percentage % type ; co_status_new constant orders . order_status % type : = 'New' ; co_commit_interval constant integer : = 100 ; begin << new_orders >> for r_order in ( select o . order_id , o . customer_id from orders o where o . order_status = co_status_new ) loop l_discount : = sales_api . calculate_discount ( p_customer_id => r_order . customer_id ); update order_lines ol -- NOSONAR: violates G-3210 set ol . discount = l_discount where ol . order_id = r_order . order_id ; l_counter : = l_counter + 1 ; if l_counter = co_commit_interval then commit ; l_counter : = 0 ; end if ; end loop new_orders ; if l_counter > 0 then commit ; end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3310/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 declare l_discount discount . percentage % type ; co_status_new constant orders . order_status % type : = 'New' ; begin << new_orders >> for r_order in ( select o . order_id , o . customer_id from orders o where o . order_status = co_status_new ) loop l_discount : = sales_api . calculate_discount ( p_customer_id => r_order . customer_id ); update order_lines ol -- NOSONAR: violates G-3210 set ol . discount = l_discount where ol . order_id = r_order . order_id ; end loop new_orders ; commit ; end ; /","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3310/#example-best","text":"(Assuming suitable foreign key relationship exists to allow updating a join.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare co_status_new constant orders . order_status % type : = 'New' ; begin update ( select o . customer_id , ol . discount from orders o join order_lines ol on ol . order_id = o . order_id where o . order_status = co_status_new ) set discount = sales_api . calculate_discount ( p_customer_id => customer_id ); commit ; end ; /","title":"Example (best)"},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3320/","text":"G-3320: Try to move transactions within a non-cursor loop into procedures. Major Maintainability, Reusability, Testability Reason Commit inside a non-cursor loop (other loop types than loops over cursors - see also G-3310 ) is either a self-contained atomic transaction, or it is a chunk (with suitable restartability handling) of very large data manipulations. In either case encapsulating the transaction in a procedure is good modularity, enabling reuse and testing of a single call. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 declare co_upper_bound constant integer : = 5 ; co_max_level constant integer : = 3 ; co_number constant types_up . short_string : = 'Number' ; co_line constant types_up . short_string : = 'Line' ; co_space constant types_up . short_string : = ' ' ; l_counter integer : = 0 ; begin << create_headers >> loop insert into headers ( id , text ) values ( l_counter , co_number || co_space || l_counter ); insert into lines ( header_id , line_no , text ) select l_counter , rownum , co_line || co_space || rownum from dual connect by level <= co_max_level ; commit ; l_counter : = l_counter + 1 ; exit create_headers when l_counter > co_upper_bound ; end loop create_headers ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 declare co_upper_bound constant integer : = 5 ; co_max_level constant integer : = 3 ; co_number constant types_up . short_string : = 'Number' ; co_line constant types_up . short_string : = 'Line' ; co_space constant types_up . short_string : = ' ' ; procedure create_rows ( in_header_id in headers . id % type ) is co_header_id constant headers . id % type : = in_header_id ; begin insert into headers ( id , text ) values ( in_header_id , co_number || co_space || co_header_id ); insert into lines ( header_id , line_no , text ) select co_header_id , rownum , co_line || co_space || rownum from dual connect by level <= co_max_level ; commit ; end create_rows ; begin << create_headers >> for l_counter in 1 .. co_upper_bound loop create_rows ( l_counter ); end loop create_headers ; end ; /","title":"G-3320: Try to move transactions within a non-cursor loop into procedures."},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3320/#g-3320-try-to-move-transactions-within-a-non-cursor-loop-into-procedures","text":"Major Maintainability, Reusability, Testability","title":"G-3320: Try to move transactions within a non-cursor loop into procedures."},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3320/#reason","text":"Commit inside a non-cursor loop (other loop types than loops over cursors - see also G-3310 ) is either a self-contained atomic transaction, or it is a chunk (with suitable restartability handling) of very large data manipulations. In either case encapsulating the transaction in a procedure is good modularity, enabling reuse and testing of a single call.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3320/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 declare co_upper_bound constant integer : = 5 ; co_max_level constant integer : = 3 ; co_number constant types_up . short_string : = 'Number' ; co_line constant types_up . short_string : = 'Line' ; co_space constant types_up . short_string : = ' ' ; l_counter integer : = 0 ; begin << create_headers >> loop insert into headers ( id , text ) values ( l_counter , co_number || co_space || l_counter ); insert into lines ( header_id , line_no , text ) select l_counter , rownum , co_line || co_space || rownum from dual connect by level <= co_max_level ; commit ; l_counter : = l_counter + 1 ; exit create_headers when l_counter > co_upper_bound ; end loop create_headers ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3320/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 declare co_upper_bound constant integer : = 5 ; co_max_level constant integer : = 3 ; co_number constant types_up . short_string : = 'Number' ; co_line constant types_up . short_string : = 'Line' ; co_space constant types_up . short_string : = ' ' ; procedure create_rows ( in_header_id in headers . id % type ) is co_header_id constant headers . id % type : = in_header_id ; begin insert into headers ( id , text ) values ( in_header_id , co_number || co_space || co_header_id ); insert into lines ( header_id , line_no , text ) select co_header_id , rownum , co_line || co_space || rownum from dual connect by level <= co_max_level ; commit ; end create_rows ; begin << create_headers >> for l_counter in 1 .. co_upper_bound loop create_rows ( l_counter ); end loop create_headers ; end ; /","title":"Example (good)"},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3330/","text":"G-3330: Avoid autonomous transactions. Blocker Reliability, Testability Reason Before we take a look at how autonomous transactions work, I\u2019d like to emphasize that this type of transaction is a powerful and therefore dangerous tool when used improperly. The true need for an autonomous transaction is very rare indeed. I would be very suspicious of any code that makes use of them\u2014that code would get extra examination. It is far too easy to accidentally introduce logical data integrity issues into a system using them. (page 300) In my experience, that is the only truly valid use of an autonomous transaction\u2014to log errors or informational messages in a manner that can be committed independently of the parent transaction. (page 305) -- Kyte, Thomas (2013). Expert Oracle Database Architecture. Third Edition . Apress. It is most likely not possible to distinguish legitimate uses of autonomous transactions from illegitimate ones via static code analysis. However, since we expect exactly one autonomous transaction per application, the number of false positives is manageable. Example (bad) 1 2 3 4 5 6 7 8 9 10 create or replace package body dept_api is procedure ins_dept ( in_dept_row in dept % rowtype ) is pragma autonomous_transaction ; begin insert into dept values in_dept_row ; commit ; -- required by autonomous transaction end ins_dept ; end dept_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 create or replace package body dept_api is procedure ins_dept ( in_dept_row in dept % rowtype ) is begin insert into dept values in_dept_row ; -- transaction is commited in calling module -- after the completion of the unit of work end ins_dept ; end dept_api ; /","title":"G-3330: Avoid autonomous transactions."},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3330/#g-3330-avoid-autonomous-transactions","text":"Blocker Reliability, Testability","title":"G-3330: Avoid autonomous transactions."},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3330/#reason","text":"Before we take a look at how autonomous transactions work, I\u2019d like to emphasize that this type of transaction is a powerful and therefore dangerous tool when used improperly. The true need for an autonomous transaction is very rare indeed. I would be very suspicious of any code that makes use of them\u2014that code would get extra examination. It is far too easy to accidentally introduce logical data integrity issues into a system using them. (page 300) In my experience, that is the only truly valid use of an autonomous transaction\u2014to log errors or informational messages in a manner that can be committed independently of the parent transaction. (page 305) -- Kyte, Thomas (2013). Expert Oracle Database Architecture. Third Edition . Apress. It is most likely not possible to distinguish legitimate uses of autonomous transactions from illegitimate ones via static code analysis. However, since we expect exactly one autonomous transaction per application, the number of false positives is manageable.","title":"Reason"},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3330/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 create or replace package body dept_api is procedure ins_dept ( in_dept_row in dept % rowtype ) is pragma autonomous_transaction ; begin insert into dept values in_dept_row ; commit ; -- required by autonomous transaction end ins_dept ; end dept_api ; /","title":"Example (bad)"},{"location":"4-language-usage/3-dml-and-sql/3-transaction-control/g-3330/#example-good","text":"1 2 3 4 5 6 7 8 9 10 create or replace package body dept_api is procedure ins_dept ( in_dept_row in dept % rowtype ) is begin insert into dept values in_dept_row ; -- transaction is commited in calling module -- after the completion of the unit of work end ins_dept ; end dept_api ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4110/","text":"G-4110: Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data. Minor Maintainability Reason The readability of your code will be higher when you avoid negative sentences. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 declare cursor c_employees is select * from employees order by employee_id ; type t_employees_type is table of c_employees % rowtype ; t_employees t_employees_type ; co_bulk_size constant simple_integer : = 10 ; begin open c_employees ; << process_employees >> loop fetch c_employees bulk collect into t_employees limit co_bulk_size ; << display_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i ). last_name ); end loop display_employees ; exit process_employees when not c_employees % found ; end loop process_employees ; close c_employees ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 declare cursor c_employees is select * from employees order by employee_id ; type t_employees_type is table of c_employees % rowtype ; t_employees t_employees_type ; co_bulk_size constant simple_integer : = 10 ; begin open c_employees ; << process_employees >> loop fetch c_employees bulk collect into t_employees limit co_bulk_size ; << display_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i ). last_name ); end loop display_employees ; exit process_employees when c_employees % notfound ; end loop process_employees ; close c_employees ; end ; /","title":"G-4110: Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data."},{"location":"4-language-usage/4-control-structures/1-cursor/g-4110/#g-4110-always-use-notfound-instead-of-not-found-to-check-whether-a-cursor-returned-data","text":"Minor Maintainability","title":"G-4110: Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data."},{"location":"4-language-usage/4-control-structures/1-cursor/g-4110/#reason","text":"The readability of your code will be higher when you avoid negative sentences.","title":"Reason"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4110/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 declare cursor c_employees is select * from employees order by employee_id ; type t_employees_type is table of c_employees % rowtype ; t_employees t_employees_type ; co_bulk_size constant simple_integer : = 10 ; begin open c_employees ; << process_employees >> loop fetch c_employees bulk collect into t_employees limit co_bulk_size ; << display_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i ). last_name ); end loop display_employees ; exit process_employees when not c_employees % found ; end loop process_employees ; close c_employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4110/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 declare cursor c_employees is select * from employees order by employee_id ; type t_employees_type is table of c_employees % rowtype ; t_employees t_employees_type ; co_bulk_size constant simple_integer : = 10 ; begin open c_employees ; << process_employees >> loop fetch c_employees bulk collect into t_employees limit co_bulk_size ; << display_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i ). last_name ); end loop display_employees ; exit process_employees when c_employees % notfound ; end loop process_employees ; close c_employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4120/","text":"G-4120: Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause. Blocker Reliability Reason %notfound is set to true as soon as less than the number of rows defined by the limit clause has been read. Example (bad) The employees table holds 107 rows. The example below will only show 100 rows as the cursor attribute notfound is set to true as soon as the number of rows to be fetched defined by the limit clause is not fulfilled anymore. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 declare cursor c_employees is select * from employees order by employee_id ; type t_employees_type is table of c_employees % rowtype ; t_employees t_employees_type ; co_bulk_size constant simple_integer : = 10 ; begin open c_employees ; << process_employees >> loop fetch c_employees bulk collect into t_employees limit co_bulk_size ; exit process_employees when c_employees % notfound ; << display_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i ). last_name ); end loop display_employees ; end loop process_employees ; close c_employees ; end ; / Example (better) This example will show all 107 rows but execute one fetch too much (12 instead of 11). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 declare cursor c_employees is select * from employees order by employee_id ; type t_employees_type is table of c_employees % rowtype ; t_employees t_employees_type ; co_bulk_size constant simple_integer : = 10 ; begin open c_employees ; << process_employees >> loop fetch c_employees bulk collect into t_employees limit co_bulk_size ; exit process_employees when t_employees . count () = 0 ; << display_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i ). last_name ); end loop display_employees ; end loop process_employees ; close c_employees ; end ; / Example (good) This example does the trick (11 fetches only to process all rows) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 declare cursor c_employees is select * from employees order by employee_id ; type t_employees_type is table of c_employees % rowtype ; t_employees t_employees_type ; co_bulk_size constant simple_integer : = 10 ; begin open c_employees ; << process_employees >> loop fetch c_employees bulk collect into t_employees limit co_bulk_size ; << display_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i ). last_name ); end loop display_employees ; exit process_employees when t_employees . count () <> co_bulk_size ; end loop process_employees ; close c_employees ; end ; /","title":"G-4120: Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause."},{"location":"4-language-usage/4-control-structures/1-cursor/g-4120/#g-4120-avoid-using-notfound-directly-after-the-fetch-when-working-with-bulk-operations-and-limit-clause","text":"Blocker Reliability","title":"G-4120: Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause."},{"location":"4-language-usage/4-control-structures/1-cursor/g-4120/#reason","text":"%notfound is set to true as soon as less than the number of rows defined by the limit clause has been read.","title":"Reason"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4120/#example-bad","text":"The employees table holds 107 rows. The example below will only show 100 rows as the cursor attribute notfound is set to true as soon as the number of rows to be fetched defined by the limit clause is not fulfilled anymore. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 declare cursor c_employees is select * from employees order by employee_id ; type t_employees_type is table of c_employees % rowtype ; t_employees t_employees_type ; co_bulk_size constant simple_integer : = 10 ; begin open c_employees ; << process_employees >> loop fetch c_employees bulk collect into t_employees limit co_bulk_size ; exit process_employees when c_employees % notfound ; << display_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i ). last_name ); end loop display_employees ; end loop process_employees ; close c_employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4120/#example-better","text":"This example will show all 107 rows but execute one fetch too much (12 instead of 11). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 declare cursor c_employees is select * from employees order by employee_id ; type t_employees_type is table of c_employees % rowtype ; t_employees t_employees_type ; co_bulk_size constant simple_integer : = 10 ; begin open c_employees ; << process_employees >> loop fetch c_employees bulk collect into t_employees limit co_bulk_size ; exit process_employees when t_employees . count () = 0 ; << display_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i ). last_name ); end loop display_employees ; end loop process_employees ; close c_employees ; end ; /","title":"Example (better)"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4120/#example-good","text":"This example does the trick (11 fetches only to process all rows) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 declare cursor c_employees is select * from employees order by employee_id ; type t_employees_type is table of c_employees % rowtype ; t_employees t_employees_type ; co_bulk_size constant simple_integer : = 10 ; begin open c_employees ; << process_employees >> loop fetch c_employees bulk collect into t_employees limit co_bulk_size ; << display_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i ). last_name ); end loop display_employees ; exit process_employees when t_employees . count () <> co_bulk_size ; end loop process_employees ; close c_employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4130/","text":"G-4130: Always close locally opened cursors. Blocker Efficiency, Reliability Reason Any cursors left open can consume additional memory space (i.e. SGA) within the database instance, potentially in both the shared and private SQL pools. Furthermore, failure to explicitly close cursors may also cause the owning session to exceed its maximum limit of open cursors (as specified by the open_cursors database initialization parameter), potentially resulting in the Oracle Database error of \u201cORA-01000: maximum open cursors exceeded\u201d. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api as function department_salary ( in_dept_id in integer ) -- NOSONAR: non-deterministic return number is cursor c_department_salary ( p_dept_id in departments . department_id % type ) is select sum ( salary ) as sum_salary from employees where department_id = p_dept_id ; r_department_salary c_department_salary % rowtype ; co_dept_id constant departments . department_id % type : = in_dept_id ; begin open c_department_salary ( p_dept_id => co_dept_id ); fetch c_department_salary into r_department_salary ; return r_department_salary . sum_salary ; end department_salary ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api as function department_salary ( in_dept_id in integer ) -- NOSONAR: non-deterministic return number is cursor c_department_salary ( p_dept_id in departments . department_id % type ) is select sum ( salary ) as sum_salary from employees where department_id = p_dept_id ; r_department_salary c_department_salary % rowtype ; co_dept_id constant departments . department_id % type : = in_dept_id ; begin open c_department_salary ( p_dept_id => co_dept_id ); fetch c_department_salary into r_department_salary ; close c_department_salary ; return r_department_salary . sum_salary ; end department_salary ; end employee_api ; /","title":"G-4130: Always close locally opened cursors."},{"location":"4-language-usage/4-control-structures/1-cursor/g-4130/#g-4130-always-close-locally-opened-cursors","text":"Blocker Efficiency, Reliability","title":"G-4130: Always close locally opened cursors."},{"location":"4-language-usage/4-control-structures/1-cursor/g-4130/#reason","text":"Any cursors left open can consume additional memory space (i.e. SGA) within the database instance, potentially in both the shared and private SQL pools. Furthermore, failure to explicitly close cursors may also cause the owning session to exceed its maximum limit of open cursors (as specified by the open_cursors database initialization parameter), potentially resulting in the Oracle Database error of \u201cORA-01000: maximum open cursors exceeded\u201d.","title":"Reason"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4130/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api as function department_salary ( in_dept_id in integer ) -- NOSONAR: non-deterministic return number is cursor c_department_salary ( p_dept_id in departments . department_id % type ) is select sum ( salary ) as sum_salary from employees where department_id = p_dept_id ; r_department_salary c_department_salary % rowtype ; co_dept_id constant departments . department_id % type : = in_dept_id ; begin open c_department_salary ( p_dept_id => co_dept_id ); fetch c_department_salary into r_department_salary ; return r_department_salary . sum_salary ; end department_salary ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4130/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api as function department_salary ( in_dept_id in integer ) -- NOSONAR: non-deterministic return number is cursor c_department_salary ( p_dept_id in departments . department_id % type ) is select sum ( salary ) as sum_salary from employees where department_id = p_dept_id ; r_department_salary c_department_salary % rowtype ; co_dept_id constant departments . department_id % type : = in_dept_id ; begin open c_department_salary ( p_dept_id => co_dept_id ); fetch c_department_salary into r_department_salary ; close c_department_salary ; return r_department_salary . sum_salary ; end department_salary ; end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4140/","text":"G-4140: Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute. Blocker Reliability Reason The Oracle Database provides a variety of cursor attributes (like %found and %rowcount ) that can be used to obtain information about the status of a cursor, either implicit or explicit. You should avoid inserting any statements between the cursor operation and the use of an attribute against that cursor. Interposing such a statement can affect the value returned by the attribute, thereby potentially corrupting the logic of your program. In the following example, a procedure call is inserted between the delete statement and a check for the value of sql%rowcount , which returns the number of rows modified by that last SQL statement executed in the session. If this procedure includes a commit / rollback or another implicit cursor the value of sql%rowcount is affected. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 create or replace package body employee_api as co_one constant simple_integer : = 1 ; co_msg constant types_up . text : = 'Do something based on ' ; procedure process_dept ( in_dept_id in departments . department_id % type ) is co_dept_id constant departments . department_id % type : = in_dept_id ; begin sys . dbms_output . put_line ( co_msg || co_dept_id ); end process_dept ; procedure remove_employee ( in_employee_id in employees . employee_id % type ) is co_employee_id constant departments . department_id % type : = in_employee_id ; l_dept_id employees . department_id % type ; begin delete from employees where employee_id = co_employee_id returning department_id into l_dept_id ; process_dept ( in_dept_id => l_dept_id ); if sql % rowcount > co_one then -- too many rows deleted. rollback ; end if ; end remove_employee ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 create or replace package body employee_api as co_one constant simple_integer : = 1 ; co_msg constant types_up . text : = 'Do something based on ' ; procedure process_dept ( in_dept_id in departments . department_id % type ) is co_dept_id constant departments . department_id % type : = in_dept_id ; begin sys . dbms_output . put_line ( co_msg || co_dept_id ); end process_dept ; procedure remove_employee ( in_employee_id in employees . employee_id % type ) is co_employee_id constant departments . department_id % type : = in_employee_id ; l_dept_id employees . department_id % type ; l_deleted_emps simple_integer ; begin delete from employees where employee_id = co_employee_id returning department_id into l_dept_id ; l_deleted_emps : = sql % rowcount ; process_dept ( in_dept_id => l_dept_id ); if l_deleted_emps > co_one then -- too many rows deleted. rollback ; end if ; end remove_employee ; end employee_api ; /","title":"G-4140: Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute."},{"location":"4-language-usage/4-control-structures/1-cursor/g-4140/#g-4140-avoid-executing-any-statements-between-a-sql-operation-and-the-usage-of-an-implicit-cursor-attribute","text":"Blocker Reliability","title":"G-4140: Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute."},{"location":"4-language-usage/4-control-structures/1-cursor/g-4140/#reason","text":"The Oracle Database provides a variety of cursor attributes (like %found and %rowcount ) that can be used to obtain information about the status of a cursor, either implicit or explicit. You should avoid inserting any statements between the cursor operation and the use of an attribute against that cursor. Interposing such a statement can affect the value returned by the attribute, thereby potentially corrupting the logic of your program. In the following example, a procedure call is inserted between the delete statement and a check for the value of sql%rowcount , which returns the number of rows modified by that last SQL statement executed in the session. If this procedure includes a commit / rollback or another implicit cursor the value of sql%rowcount is affected.","title":"Reason"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4140/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 create or replace package body employee_api as co_one constant simple_integer : = 1 ; co_msg constant types_up . text : = 'Do something based on ' ; procedure process_dept ( in_dept_id in departments . department_id % type ) is co_dept_id constant departments . department_id % type : = in_dept_id ; begin sys . dbms_output . put_line ( co_msg || co_dept_id ); end process_dept ; procedure remove_employee ( in_employee_id in employees . employee_id % type ) is co_employee_id constant departments . department_id % type : = in_employee_id ; l_dept_id employees . department_id % type ; begin delete from employees where employee_id = co_employee_id returning department_id into l_dept_id ; process_dept ( in_dept_id => l_dept_id ); if sql % rowcount > co_one then -- too many rows deleted. rollback ; end if ; end remove_employee ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/1-cursor/g-4140/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 create or replace package body employee_api as co_one constant simple_integer : = 1 ; co_msg constant types_up . text : = 'Do something based on ' ; procedure process_dept ( in_dept_id in departments . department_id % type ) is co_dept_id constant departments . department_id % type : = in_dept_id ; begin sys . dbms_output . put_line ( co_msg || co_dept_id ); end process_dept ; procedure remove_employee ( in_employee_id in employees . employee_id % type ) is co_employee_id constant departments . department_id % type : = in_employee_id ; l_dept_id employees . department_id % type ; l_deleted_emps simple_integer ; begin delete from employees where employee_id = co_employee_id returning department_id into l_dept_id ; l_deleted_emps : = sql % rowcount ; process_dept ( in_dept_id => l_dept_id ); if l_deleted_emps > co_one then -- too many rows deleted. rollback ; end if ; end remove_employee ; end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/","text":"G-4210: Try to use CASE rather than an IF statement with multiple ELSIF paths. Minor Maintainability, Testability Reason if statements containing multiple elsif tend to become complex quickly. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 declare l_color types_up . color_code_type ; begin if l_color = constants_up . co_red then my_package . do_red (); elsif l_color = constants_up . co_blue then my_package . do_blue (); elsif l_color = constants_up . co_black then my_package . do_black (); end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 declare l_color types_up . color_code_type ; begin case l_color when constants_up . co_red then my_package . do_red (); when constants_up . co_blue then my_package . do_blue (); when constants_up . co_black then my_package . do_black (); end case ; end ; /","title":"G-4210: Try to use CASE rather than an IF statement with multiple ELSIF paths."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#g-4210-try-to-use-case-rather-than-an-if-statement-with-multiple-elsif-paths","text":"Minor Maintainability, Testability","title":"G-4210: Try to use CASE rather than an IF statement with multiple ELSIF paths."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#reason","text":"if statements containing multiple elsif tend to become complex quickly.","title":"Reason"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 declare l_color types_up . color_code_type ; begin if l_color = constants_up . co_red then my_package . do_red (); elsif l_color = constants_up . co_blue then my_package . do_blue (); elsif l_color = constants_up . co_black then my_package . do_black (); end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 declare l_color types_up . color_code_type ; begin case l_color when constants_up . co_red then my_package . do_red (); when constants_up . co_blue then my_package . do_blue (); when constants_up . co_black then my_package . do_black (); end case ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/","text":"G-4220: Try to use CASE rather than DECODE. Major Maintainability, Portability Reason decode is an Oracle Database specific function hard to understand and restricted to SQL only. The \u201cnewer\u201d case function is much more common, has a better readability and may be used within PL/SQL too. Be careful that decode can handle null values, which the simple case cannot - for such cases you must use the searched case and is null instead. Example (bad) 1 2 3 4 5 6 -- @formatter:off select decode ( ctry . country_code , constants_up . co_ctry_uk , constants_up . co_lang_english , constants_up . co_ctry_fr , constants_up . co_lang_french , constants_up . co_ctry_de , constants_up . co_lang_german , constants_up . co_lang_not_supported ) from countries ctry ; null values can be compared in decode : 1 2 3 4 5 6 -- @formatter:off select decode ( ctry . country_code , constants_up . co_ctry_uk , constants_up . co_lang_english , constants_up . co_ctry_fr , constants_up . co_lang_french , null , constants_up . co_lang_unknown , constants_up . co_lang_not_supported ) from countries ctry ; Example (good) 1 2 3 4 5 6 7 8 9 10 11 select case ctry . country_code when constants_up . co_ctry_uk then constants_up . co_lang_english when constants_up . co_ctry_fr then constants_up . co_lang_french when constants_up . co_ctry_de then constants_up . co_lang_german else constants_up . co_lang_not_supported end from countries ctry ; Simple case can not compare null values, instead the searched case expression must be used: 1 2 3 4 5 6 7 8 9 10 11 select case when ctry . country_code = constants_up . co_ctry_uk then constants_up . co_lang_english when ctry . country_code = constants_up . co_ctry_fr then constants_up . co_lang_french when ctry . country_code is null then constants_up . co_lang_unknown else constants_up . co_lang_not_supported end from countries ctry ;","title":"G-4220: Try to use CASE rather than DECODE."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#g-4220-try-to-use-case-rather-than-decode","text":"Major Maintainability, Portability","title":"G-4220: Try to use CASE rather than DECODE."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#reason","text":"decode is an Oracle Database specific function hard to understand and restricted to SQL only. The \u201cnewer\u201d case function is much more common, has a better readability and may be used within PL/SQL too. Be careful that decode can handle null values, which the simple case cannot - for such cases you must use the searched case and is null instead.","title":"Reason"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#example-bad","text":"1 2 3 4 5 6 -- @formatter:off select decode ( ctry . country_code , constants_up . co_ctry_uk , constants_up . co_lang_english , constants_up . co_ctry_fr , constants_up . co_lang_french , constants_up . co_ctry_de , constants_up . co_lang_german , constants_up . co_lang_not_supported ) from countries ctry ; null values can be compared in decode : 1 2 3 4 5 6 -- @formatter:off select decode ( ctry . country_code , constants_up . co_ctry_uk , constants_up . co_lang_english , constants_up . co_ctry_fr , constants_up . co_lang_french , null , constants_up . co_lang_unknown , constants_up . co_lang_not_supported ) from countries ctry ;","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 select case ctry . country_code when constants_up . co_ctry_uk then constants_up . co_lang_english when constants_up . co_ctry_fr then constants_up . co_lang_french when constants_up . co_ctry_de then constants_up . co_lang_german else constants_up . co_lang_not_supported end from countries ctry ; Simple case can not compare null values, instead the searched case expression must be used: 1 2 3 4 5 6 7 8 9 10 11 select case when ctry . country_code = constants_up . co_ctry_uk then constants_up . co_lang_english when ctry . country_code = constants_up . co_ctry_fr then constants_up . co_lang_french when ctry . country_code is null then constants_up . co_lang_unknown else constants_up . co_lang_not_supported end from countries ctry ;","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/","text":"G-4230: Always use a COALESCE instead of a NVL command, if parameter 2 of the NVL function is a function call or a SELECT statement. Critical Efficiency, Reliability Reason The nvl function always evaluates both parameters before deciding which one to use. This can be harmful if parameter 2 is either a function call or a select statement, as it will be executed regardless of whether parameter 1 contains a null value or not. The coalesce function does not have this drawback. Example (bad) 1 2 select nvl ( dummy , my_package . expensive_null ( value_in => dummy )) from dual ; Example (good) 1 2 select coalesce ( dummy , my_package . expensive_null ( value_in => dummy )) from dual ;","title":"G-4230: Always use a COALESCE instead of a NVL command, if parameter 2 of the NVL function is a function call or a SELECT statement."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#g-4230-always-use-a-coalesce-instead-of-a-nvl-command-if-parameter-2-of-the-nvl-function-is-a-function-call-or-a-select-statement","text":"Critical Efficiency, Reliability","title":"G-4230: Always use a COALESCE instead of a NVL command, if parameter 2 of the NVL function is a function call or a SELECT statement."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#reason","text":"The nvl function always evaluates both parameters before deciding which one to use. This can be harmful if parameter 2 is either a function call or a select statement, as it will be executed regardless of whether parameter 1 contains a null value or not. The coalesce function does not have this drawback.","title":"Reason"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#example-bad","text":"1 2 select nvl ( dummy , my_package . expensive_null ( value_in => dummy )) from dual ;","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#example-good","text":"1 2 select coalesce ( dummy , my_package . expensive_null ( value_in => dummy )) from dual ;","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/","text":"G-4240: Always use a CASE instead of a NVL2 command if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement. Critical Efficiency, Reliability Reason The nvl2 function always evaluates all parameters before deciding which one to use. This can be harmful, if parameter 2 or 3 is either a function call or a select statement, as they will be executed regardless of whether parameter 1 contains a null value or not. Example (bad) 1 2 3 select nvl2 ( dummy , my_package . expensive_nn ( value_in => dummy ) , my_package . expensive_null ( value_in => dummy )) from dual ; Example (good) 1 2 3 4 5 6 7 select case when dummy is null then my_package . expensive_null ( value_in => dummy ) else my_package . expensive_nn ( value_in => dummy ) end from dual ;","title":"G-4240: Always use a CASE instead of a NVL2 command if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#g-4240-always-use-a-case-instead-of-a-nvl2-command-if-parameter-2-or-3-of-nvl2-is-either-a-function-call-or-a-select-statement","text":"Critical Efficiency, Reliability","title":"G-4240: Always use a CASE instead of a NVL2 command if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#reason","text":"The nvl2 function always evaluates all parameters before deciding which one to use. This can be harmful, if parameter 2 or 3 is either a function call or a select statement, as they will be executed regardless of whether parameter 1 contains a null value or not.","title":"Reason"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#example-bad","text":"1 2 3 select nvl2 ( dummy , my_package . expensive_nn ( value_in => dummy ) , my_package . expensive_null ( value_in => dummy )) from dual ;","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#example-good","text":"1 2 3 4 5 6 7 select case when dummy is null then my_package . expensive_null ( value_in => dummy ) else my_package . expensive_nn ( value_in => dummy ) end from dual ;","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4250/","text":"G-4250: Avoid using identical conditions in different branches of the same IF or CASE statement. Blocker Maintainability, Reliability, Testability Reason Conditions are evaluated top to bottom in branches of a case statement or chain of if / elsif statements. The first condition to evaluate as true leads to that branch being executed, the rest will never execute. Having an identical duplicated condition in another branch will never be reached and will be dead code. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare l_color types_up . color_code_type ; begin case l_color when constants_up . co_red then my_package . do_red (); when constants_up . co_blue then my_package . do_blue (); when constants_up . co_red then -- never reached my_package . do_black (); -- dead code else null ; end case ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare l_color types_up . color_code_type ; begin case l_color when constants_up . co_red then my_package . do_red (); when constants_up . co_blue then my_package . do_blue (); when constants_up . co_black then my_package . do_black (); else null ; end case ; end ; /","title":"G-4250: Avoid using identical conditions in different branches of the same IF or CASE statement."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4250/#g-4250-avoid-using-identical-conditions-in-different-branches-of-the-same-if-or-case-statement","text":"Blocker Maintainability, Reliability, Testability","title":"G-4250: Avoid using identical conditions in different branches of the same IF or CASE statement."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4250/#reason","text":"Conditions are evaluated top to bottom in branches of a case statement or chain of if / elsif statements. The first condition to evaluate as true leads to that branch being executed, the rest will never execute. Having an identical duplicated condition in another branch will never be reached and will be dead code.","title":"Reason"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4250/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare l_color types_up . color_code_type ; begin case l_color when constants_up . co_red then my_package . do_red (); when constants_up . co_blue then my_package . do_blue (); when constants_up . co_red then -- never reached my_package . do_black (); -- dead code else null ; end case ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4250/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare l_color types_up . color_code_type ; begin case l_color when constants_up . co_red then my_package . do_red (); when constants_up . co_blue then my_package . do_blue (); when constants_up . co_black then my_package . do_black (); else null ; end case ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4260/","text":"G-4260: Avoid inverting boolean conditions with NOT. Minor Maintainability, Testability Reason It is more readable to use the opposite comparison operator instead of inverting the comparison with not . Example (bad) 1 2 3 4 5 6 7 8 declare l_color types_up . color_code_type ; begin if not l_color != constants_up . co_red then my_package . do_red (); end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 declare l_color types_up . color_code_type ; begin if l_color = constants_up . co_red then my_package . do_red (); end if ; end ; /","title":"G-4260: Avoid inverting boolean conditions with NOT."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4260/#g-4260-avoid-inverting-boolean-conditions-with-not","text":"Minor Maintainability, Testability","title":"G-4260: Avoid inverting boolean conditions with NOT."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4260/#reason","text":"It is more readable to use the opposite comparison operator instead of inverting the comparison with not .","title":"Reason"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4260/#example-bad","text":"1 2 3 4 5 6 7 8 declare l_color types_up . color_code_type ; begin if not l_color != constants_up . co_red then my_package . do_red (); end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4260/#example-good","text":"1 2 3 4 5 6 7 8 declare l_color types_up . color_code_type ; begin if l_color = constants_up . co_red then my_package . do_red (); end if ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4270/","text":"G-4270: Avoid comparing boolean values to boolean literals. Minor Maintainability, Testability Reason It is more readable to simply use the boolean value as a condition itself, rather than use a comparison condition comparing the boolean value to the literals true or false . Example (bad) 1 2 3 4 5 6 7 8 9 10 declare co_string constant types_up . text : = '42' ; l_is_valid boolean ; begin l_is_valid : = my_package . is_valid_number ( co_string ); if l_is_valid = true then my_package . convert_number ( l_string ); end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 declare co_string constant types_up . text : = '42' ; l_is_valid boolean ; begin l_is_valid : = my_package . is_valid_number ( co_string ); if l_is_valid then my_package . convert_number ( l_string ); end if ; end ; /","title":"G-4270: Avoid comparing boolean values to boolean literals."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4270/#g-4270-avoid-comparing-boolean-values-to-boolean-literals","text":"Minor Maintainability, Testability","title":"G-4270: Avoid comparing boolean values to boolean literals."},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4270/#reason","text":"It is more readable to simply use the boolean value as a condition itself, rather than use a comparison condition comparing the boolean value to the literals true or false .","title":"Reason"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4270/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 declare co_string constant types_up . text : = '42' ; l_is_valid boolean ; begin l_is_valid : = my_package . is_valid_number ( co_string ); if l_is_valid = true then my_package . convert_number ( l_string ); end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4270/#example-good","text":"1 2 3 4 5 6 7 8 9 10 declare co_string constant types_up . text : = '42' ; l_is_valid boolean ; begin l_is_valid : = my_package . is_valid_number ( co_string ); if l_is_valid then my_package . convert_number ( l_string ); end if ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4310/","text":"G-4310: Never use GOTO statements in your code. Major Maintainability, Testability Reason Code containing gotos is hard to format. Indentation should be used to show logical structure, and gotos have an effect on logical structure. Using indentation to show the logical structure of a goto and its target, however, is difficult or impossible. (...) Use of gotos is a matter of religion. My dogma is that in modern languages, you can easily replace nine out of ten gotos with equivalent sequential constructs. In these simple cases, you should replace gotos out of habit. In the hard cases, you can still exorcise the goto in nine out of ten cases: You can break the code into smaller routines, use try-finally, use nested ifs, test and retest a status variable, or restructure a conditional. Eliminating the goto is harder in these cases, but it\u2019s good mental exercise (...). -- McConnell, Steve C. (2004). Code Complete. Second Edition . Microsoft Press. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 create or replace package body my_package is procedure password_check ( in_password in varchar2 ) is co_password constant dba_users . password % type : = in_password ; co_digitarray constant string ( 10 char ) : = '0123456789' ; co_lower_bound constant simple_integer : = 1 ; co_errno constant simple_integer : = - 20501 ; co_errmsg constant string ( 100 char ) : = 'Password must contain a digit.' ; l_isdigit boolean : = false ; l_len_pw pls_integer ; l_len_array pls_integer ; begin l_len_pw : = length ( co_password ); l_len_array : = length ( co_digitarray ); << check_digit >> for i in co_lower_bound .. l_len_array loop << check_pw_char >> for j in co_lower_bound .. l_len_pw loop if substr ( co_password , j , 1 ) = substr ( co_digitarray , i , 1 ) then l_isdigit : = true ; goto check_other_things ; end if ; end loop check_pw_char ; end loop check_digit ; << check_other_things >> null ; if not l_isdigit then raise_application_error ( co_errno , co_errmsg ); end if ; end password_check ; end my_package ; / Example (better) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 create or replace package body my_package is procedure password_check ( in_password in varchar2 ) is co_password constant dba_users . password % type : = in_password ; co_digitarray constant string ( 10 char ) : = '0123456789' ; co_lower_bound constant simple_integer : = 1 ; co_errno constant simple_integer : = - 20501 ; co_errmsg constant string ( 100 char ) : = 'Password must contain a digit.' ; l_isdigit boolean : = false ; l_len_pw pls_integer ; l_len_array pls_integer ; begin l_len_pw : = length ( co_password ); l_len_array : = length ( co_digitarray ); << check_digit >> for i in co_lower_bound .. l_len_array loop << check_pw_char >> for j in co_lower_bound .. l_len_pw loop if substr ( co_password , j , 1 ) = substr ( co_digitarray , i , 1 ) then l_isdigit : = true ; end if ; end loop check_pw_char ; end loop check_digit ; << check_other_things >> null ; if not l_isdigit then raise_application_error ( co_errno , co_errmsg ); end if ; end password_check ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 create or replace package body my_package is procedure password_check ( in_password in varchar2 ) is co_password constant dba_users . password % type : = in_password ; co_digitpattern constant string ( 10 char ) : = '\\d' ; co_errno constant simple_integer : = - 20501 ; co_errmsg constant string ( 100 char ) : = 'Password must contain a digit.' ; begin if not regexp_like ( co_password , co_digitpattern ) then raise_application_error ( co_errno , co_errmsg ); end if ; end password_check ; end my_package ; /","title":"G-4310: Never use GOTO statements in your code."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4310/#g-4310-never-use-goto-statements-in-your-code","text":"Major Maintainability, Testability","title":"G-4310: Never use GOTO statements in your code."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4310/#reason","text":"Code containing gotos is hard to format. Indentation should be used to show logical structure, and gotos have an effect on logical structure. Using indentation to show the logical structure of a goto and its target, however, is difficult or impossible. (...) Use of gotos is a matter of religion. My dogma is that in modern languages, you can easily replace nine out of ten gotos with equivalent sequential constructs. In these simple cases, you should replace gotos out of habit. In the hard cases, you can still exorcise the goto in nine out of ten cases: You can break the code into smaller routines, use try-finally, use nested ifs, test and retest a status variable, or restructure a conditional. Eliminating the goto is harder in these cases, but it\u2019s good mental exercise (...). -- McConnell, Steve C. (2004). Code Complete. Second Edition . Microsoft Press.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4310/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 create or replace package body my_package is procedure password_check ( in_password in varchar2 ) is co_password constant dba_users . password % type : = in_password ; co_digitarray constant string ( 10 char ) : = '0123456789' ; co_lower_bound constant simple_integer : = 1 ; co_errno constant simple_integer : = - 20501 ; co_errmsg constant string ( 100 char ) : = 'Password must contain a digit.' ; l_isdigit boolean : = false ; l_len_pw pls_integer ; l_len_array pls_integer ; begin l_len_pw : = length ( co_password ); l_len_array : = length ( co_digitarray ); << check_digit >> for i in co_lower_bound .. l_len_array loop << check_pw_char >> for j in co_lower_bound .. l_len_pw loop if substr ( co_password , j , 1 ) = substr ( co_digitarray , i , 1 ) then l_isdigit : = true ; goto check_other_things ; end if ; end loop check_pw_char ; end loop check_digit ; << check_other_things >> null ; if not l_isdigit then raise_application_error ( co_errno , co_errmsg ); end if ; end password_check ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4310/#example-better","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 create or replace package body my_package is procedure password_check ( in_password in varchar2 ) is co_password constant dba_users . password % type : = in_password ; co_digitarray constant string ( 10 char ) : = '0123456789' ; co_lower_bound constant simple_integer : = 1 ; co_errno constant simple_integer : = - 20501 ; co_errmsg constant string ( 100 char ) : = 'Password must contain a digit.' ; l_isdigit boolean : = false ; l_len_pw pls_integer ; l_len_array pls_integer ; begin l_len_pw : = length ( co_password ); l_len_array : = length ( co_digitarray ); << check_digit >> for i in co_lower_bound .. l_len_array loop << check_pw_char >> for j in co_lower_bound .. l_len_pw loop if substr ( co_password , j , 1 ) = substr ( co_digitarray , i , 1 ) then l_isdigit : = true ; end if ; end loop check_pw_char ; end loop check_digit ; << check_other_things >> null ; if not l_isdigit then raise_application_error ( co_errno , co_errmsg ); end if ; end password_check ; end my_package ; /","title":"Example (better)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4310/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 create or replace package body my_package is procedure password_check ( in_password in varchar2 ) is co_password constant dba_users . password % type : = in_password ; co_digitpattern constant string ( 10 char ) : = '\\d' ; co_errno constant simple_integer : = - 20501 ; co_errmsg constant string ( 100 char ) : = 'Password must contain a digit.' ; begin if not regexp_like ( co_password , co_digitpattern ) then raise_application_error ( co_errno , co_errmsg ); end if ; end password_check ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4320/","text":"G-4320: Always label your loops. Minor Maintainability Reason It's a good alternative for comments to indicate the start and end of a named loop processing. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 declare i integer ; co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 10 ; co_increment constant simple_integer : = 1 ; begin i : = co_min_value ; while ( i <= co_max_value ) loop i : = i + co_increment ; end loop ; loop exit when true ; -- NOSONAR: G-4380 cannot use labelled exit here end loop ; for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop ; for r_employee in ( select last_name from employees ) loop sys . dbms_output . put_line ( r_employee . last_name ); end loop ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 declare i integer ; co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 10 ; co_increment constant simple_integer : = 1 ; begin i : = co_min_value ; << while_loop >> while ( i <= co_max_value ) loop i : = i + co_increment ; end loop while_loop ; << basic_loop >> loop exit basic_loop when true ; end loop basic_loop ; << for_loop >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop for_loop ; << process_employees >> for r_employee in ( select last_name from employees ) loop sys . dbms_output . put_line ( r_employee . last_name ); end loop process_employees ; end ; /","title":"G-4320: Always label your loops."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4320/#g-4320-always-label-your-loops","text":"Minor Maintainability","title":"G-4320: Always label your loops."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4320/#reason","text":"It's a good alternative for comments to indicate the start and end of a named loop processing.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4320/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 declare i integer ; co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 10 ; co_increment constant simple_integer : = 1 ; begin i : = co_min_value ; while ( i <= co_max_value ) loop i : = i + co_increment ; end loop ; loop exit when true ; -- NOSONAR: G-4380 cannot use labelled exit here end loop ; for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop ; for r_employee in ( select last_name from employees ) loop sys . dbms_output . put_line ( r_employee . last_name ); end loop ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4320/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 declare i integer ; co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 10 ; co_increment constant simple_integer : = 1 ; begin i : = co_min_value ; << while_loop >> while ( i <= co_max_value ) loop i : = i + co_increment ; end loop while_loop ; << basic_loop >> loop exit basic_loop when true ; end loop basic_loop ; << for_loop >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop for_loop ; << process_employees >> for r_employee in ( select last_name from employees ) loop sys . dbms_output . put_line ( r_employee . last_name ); end loop process_employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4325/","text":"G-4325: Never reuse labels in inner scopes. Major Maintainability, Reliability, Testability Reason Reusing labels inside the scope of another label with the same name leads to confusion, less chance of understanding the code, and could lead to bugs (for example if using exit my_label exits at a different nesting level than expected.) Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 << my_label >> declare co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 8 ; begin << my_label >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop my_label ; end my_label ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 << output_values >> declare co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 8 ; begin << process_values >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop process_values ; end output_values ; /","title":"G-4325: Never reuse labels in inner scopes."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4325/#g-4325-never-reuse-labels-in-inner-scopes","text":"Major Maintainability, Reliability, Testability","title":"G-4325: Never reuse labels in inner scopes."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4325/#reason","text":"Reusing labels inside the scope of another label with the same name leads to confusion, less chance of understanding the code, and could lead to bugs (for example if using exit my_label exits at a different nesting level than expected.)","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4325/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 << my_label >> declare co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 8 ; begin << my_label >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop my_label ; end my_label ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4325/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 << output_values >> declare co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 8 ; begin << process_values >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop process_values ; end output_values ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4330/","text":"G-4330: Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations. Major Maintainability Reason It is easier for the reader to see, that the complete data set is processed. Using SQL to define the data to be processed is easier to maintain and typically faster than using conditional processing within the loop. Since an exit statement is similar to a goto statement, it should be avoided, whenever possible. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 declare cursor c_employees is select employee_id , last_name from employees ; r_employee c_employees % rowtype ; begin open c_employees ; << read_employees >> loop fetch c_employees into r_employee ; exit read_employees when c_employees % notfound ; sys . dbms_output . put_line ( r_employee . last_name ); end loop read_employees ; close c_employees ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 declare cursor c_employees is select employee_id , last_name from employees ; begin << read_employees >> for r_employee in c_employees loop sys . dbms_output . put_line ( r_employee . last_name ); end loop read_employees ; end ; /","title":"G-4330: Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4330/#g-4330-always-use-a-cursor-for-loop-to-process-the-complete-cursor-results-unless-you-are-using-bulk-operations","text":"Major Maintainability","title":"G-4330: Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4330/#reason","text":"It is easier for the reader to see, that the complete data set is processed. Using SQL to define the data to be processed is easier to maintain and typically faster than using conditional processing within the loop. Since an exit statement is similar to a goto statement, it should be avoided, whenever possible.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4330/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 declare cursor c_employees is select employee_id , last_name from employees ; r_employee c_employees % rowtype ; begin open c_employees ; << read_employees >> loop fetch c_employees into r_employee ; exit read_employees when c_employees % notfound ; sys . dbms_output . put_line ( r_employee . last_name ); end loop read_employees ; close c_employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4330/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 declare cursor c_employees is select employee_id , last_name from employees ; begin << read_employees >> for r_employee in c_employees loop sys . dbms_output . put_line ( r_employee . last_name ); end loop read_employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4340/","text":"G-4340: Always use a NUMERIC FOR loop to process a dense array. Major Maintainability Reason It is easier for the reader to see, that the complete array is processed. Since an exit statement is similar to a goto statement, it should be avoided, whenever possible. Please note that: Varrays are always dense Associative arrays (or index-by tables) are either dense or sparse Nested tables start dense and may become sparse Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 declare type t_employee_type is varray ( 10 ) of employees . employee_id % type ; t_employees t_employee_type ; co_himuro constant integer : = 118 ; co_livingston constant integer : = 177 ; co_min_value constant simple_integer : = 1 ; co_increment constant simple_integer : = 1 ; i pls_integer ; begin t_employees : = t_employee_type ( co_himuro , co_livingston ); i : = co_min_value ; << process_employees >> loop exit process_employees when i > t_employees . count (); sys . dbms_output . put_line ( t_employees ( i )); i : = i + co_increment ; end loop process_employees ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare type t_employee_type is varray ( 10 ) of employees . employee_id % type ; t_employees t_employee_type ; co_himuro constant integer : = 118 ; co_livingston constant integer : = 177 ; begin t_employees : = t_employee_type ( co_himuro , co_livingston ); << process_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i )); end loop process_employees ; end ; /","title":"G-4340: Always use a NUMERIC FOR loop to process a dense array."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4340/#g-4340-always-use-a-numeric-for-loop-to-process-a-dense-array","text":"Major Maintainability","title":"G-4340: Always use a NUMERIC FOR loop to process a dense array."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4340/#reason","text":"It is easier for the reader to see, that the complete array is processed. Since an exit statement is similar to a goto statement, it should be avoided, whenever possible. Please note that: Varrays are always dense Associative arrays (or index-by tables) are either dense or sparse Nested tables start dense and may become sparse","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4340/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 declare type t_employee_type is varray ( 10 ) of employees . employee_id % type ; t_employees t_employee_type ; co_himuro constant integer : = 118 ; co_livingston constant integer : = 177 ; co_min_value constant simple_integer : = 1 ; co_increment constant simple_integer : = 1 ; i pls_integer ; begin t_employees : = t_employee_type ( co_himuro , co_livingston ); i : = co_min_value ; << process_employees >> loop exit process_employees when i > t_employees . count (); sys . dbms_output . put_line ( t_employees ( i )); i : = i + co_increment ; end loop process_employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4340/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare type t_employee_type is varray ( 10 ) of employees . employee_id % type ; t_employees t_employee_type ; co_himuro constant integer : = 118 ; co_livingston constant integer : = 177 ; begin t_employees : = t_employee_type ( co_himuro , co_livingston ); << process_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i )); end loop process_employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4350/","text":"G-4350: Always use 1 as lower and COUNT() as upper bound when looping through a dense array. Blocker Reliability Reason Doing so will not raise a value_error if the array you are looping through is empty. If you want to use first()..last() you need to check the array for emptiness beforehand to avoid the raise of value_error . Please note that: Varrays are always dense Associative arrays (or index-by tables) are either dense or sparse Nested tables start dense and may become sparse Example (bad) 1 2 3 4 5 6 7 8 9 10 11 declare type t_employee_type is table of employees . employee_id % type ; t_employees t_employee_type : = t_employee_type (); begin << process_employees >> for i in t_employees . first ().. t_employees . last () loop sys . dbms_output . put_line ( t_employees ( i )); -- some processing end loop process_employees ; end ; / Example (better) Raise an unitialized collection error if t_employees is not initialized. 1 2 3 4 5 6 7 8 9 10 11 declare type t_employee_type is table of employees . employee_id % type ; t_employees t_employee_type : = t_employee_type (); begin << process_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i )); -- some processing end loop process_employees ; end ; / Example (good) Raises neither an error nor checking whether the array is empty. t_employees.count() always returns a number (unless the array is not initialized). If the array is empty count() returns 0 and therefore the loop will not be entered. 1 2 3 4 5 6 7 8 9 10 11 12 13 declare type t_employee_type is table of employees . employee_id % type ; t_employees t_employee_type : = t_employee_type (); begin if t_employees is not null then << process_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i )); -- some processing end loop process_employees ; end if ; end ; /","title":"G-4350: Always use 1 as lower and COUNT() as upper bound when looping through a dense array."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4350/#g-4350-always-use-1-as-lower-and-count-as-upper-bound-when-looping-through-a-dense-array","text":"Blocker Reliability","title":"G-4350: Always use 1 as lower and COUNT() as upper bound when looping through a dense array."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4350/#reason","text":"Doing so will not raise a value_error if the array you are looping through is empty. If you want to use first()..last() you need to check the array for emptiness beforehand to avoid the raise of value_error . Please note that: Varrays are always dense Associative arrays (or index-by tables) are either dense or sparse Nested tables start dense and may become sparse","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4350/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 declare type t_employee_type is table of employees . employee_id % type ; t_employees t_employee_type : = t_employee_type (); begin << process_employees >> for i in t_employees . first ().. t_employees . last () loop sys . dbms_output . put_line ( t_employees ( i )); -- some processing end loop process_employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4350/#example-better","text":"Raise an unitialized collection error if t_employees is not initialized. 1 2 3 4 5 6 7 8 9 10 11 declare type t_employee_type is table of employees . employee_id % type ; t_employees t_employee_type : = t_employee_type (); begin << process_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i )); -- some processing end loop process_employees ; end ; /","title":"Example (better)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4350/#example-good","text":"Raises neither an error nor checking whether the array is empty. t_employees.count() always returns a number (unless the array is not initialized). If the array is empty count() returns 0 and therefore the loop will not be entered. 1 2 3 4 5 6 7 8 9 10 11 12 13 declare type t_employee_type is table of employees . employee_id % type ; t_employees t_employee_type : = t_employee_type (); begin if t_employees is not null then << process_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i )); -- some processing end loop process_employees ; end if ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4360/","text":"G-4360: Always use a WHILE loop to process a loose array. Critical Efficiency Reason When a loose (also called sparse) array is processed using a numeric for loop we have to check with all iterations whether the element exist to avoid a no_data_found exception. In addition, the number of iterations is not driven by the number of elements in the array but by the number of the lowest/highest element. The more gaps we have, the more superfluous iterations will be done. Please note that: Varrays are always dense Associative arrays (or index-by tables) are either dense or sparse Nested tables start dense and may become sparse Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 declare -- raises no_data_found when processing 2nd record type t_employee_type is table of employees . employee_id % type ; t_employees t_employee_type ; co_rogers constant integer : = 134 ; co_matos constant integer : = 143 ; co_mcewen constant integer : = 158 ; co_index_matos constant integer : = 2 ; begin t_employees : = t_employee_type ( co_rogers , co_matos , co_mcewen ); t_employees . delete ( co_index_matos ); if t_employees is not null then << process_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i )); end loop process_employees ; end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 declare type t_employee_type is table of employees . employee_id % type ; t_employees t_employee_type ; co_rogers constant integer : = 134 ; co_matos constant integer : = 143 ; co_mcewen constant integer : = 158 ; co_index_matos constant integer : = 2 ; l_index pls_integer ; begin t_employees : = t_employee_type ( co_rogers , co_matos , co_mcewen ); t_employees . delete ( co_index_matos ); l_index : = t_employees . first (); << process_employees >> while l_index is not null loop sys . dbms_output . put_line ( t_employees ( l_index )); l_index : = t_employees . next ( l_index ); end loop process_employees ; end ; /","title":"G-4360: Always use a WHILE loop to process a loose array."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4360/#g-4360-always-use-a-while-loop-to-process-a-loose-array","text":"Critical Efficiency","title":"G-4360: Always use a WHILE loop to process a loose array."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4360/#reason","text":"When a loose (also called sparse) array is processed using a numeric for loop we have to check with all iterations whether the element exist to avoid a no_data_found exception. In addition, the number of iterations is not driven by the number of elements in the array but by the number of the lowest/highest element. The more gaps we have, the more superfluous iterations will be done. Please note that: Varrays are always dense Associative arrays (or index-by tables) are either dense or sparse Nested tables start dense and may become sparse","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4360/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 declare -- raises no_data_found when processing 2nd record type t_employee_type is table of employees . employee_id % type ; t_employees t_employee_type ; co_rogers constant integer : = 134 ; co_matos constant integer : = 143 ; co_mcewen constant integer : = 158 ; co_index_matos constant integer : = 2 ; begin t_employees : = t_employee_type ( co_rogers , co_matos , co_mcewen ); t_employees . delete ( co_index_matos ); if t_employees is not null then << process_employees >> for i in 1 .. t_employees . count () loop sys . dbms_output . put_line ( t_employees ( i )); end loop process_employees ; end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4360/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 declare type t_employee_type is table of employees . employee_id % type ; t_employees t_employee_type ; co_rogers constant integer : = 134 ; co_matos constant integer : = 143 ; co_mcewen constant integer : = 158 ; co_index_matos constant integer : = 2 ; l_index pls_integer ; begin t_employees : = t_employee_type ( co_rogers , co_matos , co_mcewen ); t_employees . delete ( co_index_matos ); l_index : = t_employees . first (); << process_employees >> while l_index is not null loop sys . dbms_output . put_line ( t_employees ( l_index )); l_index : = t_employees . next ( l_index ); end loop process_employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4365/","text":"G-4365: Never use unconditional CONTINUE or EXIT in a loop. Major Maintainability, Testability Reason An unconditional continue is either redundant (a continue as the last statement before the end of the loop) or causes dead code. An unconditional exit causes no looping and may cause dead code as well. If continue or exit is needed, it should always have a condition. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 begin << process_employees >> loop my_package . some_processing (); continue process_employees ; my_package . some_further_processing (); -- Dead code end loop process_employees ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_first_year constant pls_integer : = 1900 ; begin << process_employees >> loop my_package . some_processing (); continue process_employees when extract ( year from sysdate ) > co_first_year ; my_package . some_further_processing (); end loop process_employees ; end ; /","title":"G-4365: Never use unconditional CONTINUE or EXIT in a loop."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4365/#g-4365-never-use-unconditional-continue-or-exit-in-a-loop","text":"Major Maintainability, Testability","title":"G-4365: Never use unconditional CONTINUE or EXIT in a loop."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4365/#reason","text":"An unconditional continue is either redundant (a continue as the last statement before the end of the loop) or causes dead code. An unconditional exit causes no looping and may cause dead code as well. If continue or exit is needed, it should always have a condition.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4365/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 begin << process_employees >> loop my_package . some_processing (); continue process_employees ; my_package . some_further_processing (); -- Dead code end loop process_employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4365/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_first_year constant pls_integer : = 1900 ; begin << process_employees >> loop my_package . some_processing (); continue process_employees when extract ( year from sysdate ) > co_first_year ; my_package . some_further_processing (); end loop process_employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4370/","text":"G-4370: Avoid using EXIT to stop loop processing unless you are in a basic loop. Major Maintainability Reason A numeric for loop as well as a while loop and a cursor for loop have defined loop boundaries. If you are not able to exit your loop using those loop boundaries, then a basic loop is the right loop to choose. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 declare i integer ; co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 10 ; co_increment constant simple_integer : = 1 ; begin i : = co_min_value ; << while_loop >> while ( i <= co_max_value ) loop i : = i + co_increment ; exit while_loop when i > co_max_value ; end loop while_loop ; << basic_loop >> loop exit basic_loop when true ; end loop basic_loop ; << for_loop >> for i in co_min_value .. co_max_value loop null ; exit for_loop when i = co_max_value ; end loop for_loop ; << process_employees >> for r_employee in ( select last_name from employees ) loop sys . dbms_output . put_line ( r_employee . last_name ); null ; -- some processing exit process_employees when true ; end loop process_employees ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 declare i integer ; co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 10 ; co_increment constant simple_integer : = 1 ; begin i : = co_min_value ; << while_loop >> while ( i <= co_max_value ) loop i : = i + co_increment ; end loop while_loop ; << basic_loop >> loop exit basic_loop when true ; end loop basic_loop ; << for_loop >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop for_loop ; << process_employees >> for r_employee in ( select last_name from employees ) loop sys . dbms_output . put_line ( r_employee . last_name ); -- some processing end loop process_employees ; end ; /","title":"G-4370: Avoid using EXIT to stop loop processing unless you are in a basic loop."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4370/#g-4370-avoid-using-exit-to-stop-loop-processing-unless-you-are-in-a-basic-loop","text":"Major Maintainability","title":"G-4370: Avoid using EXIT to stop loop processing unless you are in a basic loop."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4370/#reason","text":"A numeric for loop as well as a while loop and a cursor for loop have defined loop boundaries. If you are not able to exit your loop using those loop boundaries, then a basic loop is the right loop to choose.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4370/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 declare i integer ; co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 10 ; co_increment constant simple_integer : = 1 ; begin i : = co_min_value ; << while_loop >> while ( i <= co_max_value ) loop i : = i + co_increment ; exit while_loop when i > co_max_value ; end loop while_loop ; << basic_loop >> loop exit basic_loop when true ; end loop basic_loop ; << for_loop >> for i in co_min_value .. co_max_value loop null ; exit for_loop when i = co_max_value ; end loop for_loop ; << process_employees >> for r_employee in ( select last_name from employees ) loop sys . dbms_output . put_line ( r_employee . last_name ); null ; -- some processing exit process_employees when true ; end loop process_employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4370/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 declare i integer ; co_min_value constant simple_integer : = 1 ; co_max_value constant simple_integer : = 10 ; co_increment constant simple_integer : = 1 ; begin i : = co_min_value ; << while_loop >> while ( i <= co_max_value ) loop i : = i + co_increment ; end loop while_loop ; << basic_loop >> loop exit basic_loop when true ; end loop basic_loop ; << for_loop >> for i in co_min_value .. co_max_value loop sys . dbms_output . put_line ( i ); end loop for_loop ; << process_employees >> for r_employee in ( select last_name from employees ) loop sys . dbms_output . put_line ( r_employee . last_name ); -- some processing end loop process_employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4375/","text":"G-4375: Always use EXIT WHEN instead of an IF statement to exit from a loop. Minor Maintainability Reason If you need to use an exit statement use its full semantic to make the code easier to understand and maintain. There is simply no need for an additional if statement. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare co_first_year constant pls_integer : = 1900 ; begin << process_employees >> loop my_package . some_processing (); if extract ( year from sysdate ) > co_first_year then exit process_employees ; -- violates also G-4365 end if ; my_package . some_further_processing (); end loop process_employees ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_first_year constant pls_integer : = 1900 ; begin << process_employees >> loop my_package . some_processing (); exit process_employees when extract ( year from sysdate ) > co_first_year ; my_package . some_further_processing (); end loop process_employees ; end ; /","title":"G-4375: Always use EXIT WHEN instead of an IF statement to exit from a loop."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4375/#g-4375-always-use-exit-when-instead-of-an-if-statement-to-exit-from-a-loop","text":"Minor Maintainability","title":"G-4375: Always use EXIT WHEN instead of an IF statement to exit from a loop."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4375/#reason","text":"If you need to use an exit statement use its full semantic to make the code easier to understand and maintain. There is simply no need for an additional if statement.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4375/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare co_first_year constant pls_integer : = 1900 ; begin << process_employees >> loop my_package . some_processing (); if extract ( year from sysdate ) > co_first_year then exit process_employees ; -- violates also G-4365 end if ; my_package . some_further_processing (); end loop process_employees ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4375/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_first_year constant pls_integer : = 1900 ; begin << process_employees >> loop my_package . some_processing (); exit process_employees when extract ( year from sysdate ) > co_first_year ; my_package . some_further_processing (); end loop process_employees ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4380/","text":"G-4380: Try to label your EXIT WHEN statements. Minor Maintainability Reason It's a good alternative for comments, especially for nested loops to name the loop to exit. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 declare co_init_loop constant simple_integer : = 0 ; co_increment constant simple_integer : = 1 ; co_exit_value constant simple_integer : = 3 ; co_outer_text constant types_up . short_text_type : = 'Outer Loop counter is ' ; co_inner_text constant types_up . short_text_type : = ' Inner Loop counter is ' ; l_outerlp pls_integer ; l_innerlp pls_integer ; begin l_outerlp : = co_init_loop ; << outerloop >> loop l_innerlp : = co_init_loop ; l_outerlp : = nvl ( l_outerlp , co_init_loop ) + co_increment ; << innerloop >> loop l_innerlp : = nvl ( l_innerlp , co_init_loop ) + co_increment ; sys . dbms_output . put_line ( co_outer_text || l_outerlp || co_inner_text || l_innerlp ); exit when l_innerlp = co_exit_value ; end loop innerloop ; exit when l_innerlp = co_exit_value ; end loop outerloop ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 declare co_init_loop constant simple_integer : = 0 ; co_increment constant simple_integer : = 1 ; co_exit_value constant simple_integer : = 3 ; co_outer_text constant types_up . short_text_type : = 'Outer Loop counter is ' ; co_inner_text constant types_up . short_text_type : = ' Inner Loop counter is ' ; l_outerlp pls_integer ; l_innerlp pls_integer ; begin l_outerlp : = co_init_loop ; << outerloop >> loop l_innerlp : = co_init_loop ; l_outerlp : = nvl ( l_outerlp , co_init_loop ) + co_increment ; << innerloop >> loop l_innerlp : = nvl ( l_innerlp , co_init_loop ) + co_increment ; sys . dbms_output . put_line ( co_outer_text || l_outerlp || co_inner_text || l_innerlp ); exit outerloop when l_innerlp = co_exit_value ; end loop innerloop ; end loop outerloop ; end ; /","title":"G-4380: Try to label your EXIT WHEN statements."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4380/#g-4380-try-to-label-your-exit-when-statements","text":"Minor Maintainability","title":"G-4380: Try to label your EXIT WHEN statements."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4380/#reason","text":"It's a good alternative for comments, especially for nested loops to name the loop to exit.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4380/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 declare co_init_loop constant simple_integer : = 0 ; co_increment constant simple_integer : = 1 ; co_exit_value constant simple_integer : = 3 ; co_outer_text constant types_up . short_text_type : = 'Outer Loop counter is ' ; co_inner_text constant types_up . short_text_type : = ' Inner Loop counter is ' ; l_outerlp pls_integer ; l_innerlp pls_integer ; begin l_outerlp : = co_init_loop ; << outerloop >> loop l_innerlp : = co_init_loop ; l_outerlp : = nvl ( l_outerlp , co_init_loop ) + co_increment ; << innerloop >> loop l_innerlp : = nvl ( l_innerlp , co_init_loop ) + co_increment ; sys . dbms_output . put_line ( co_outer_text || l_outerlp || co_inner_text || l_innerlp ); exit when l_innerlp = co_exit_value ; end loop innerloop ; exit when l_innerlp = co_exit_value ; end loop outerloop ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4380/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 declare co_init_loop constant simple_integer : = 0 ; co_increment constant simple_integer : = 1 ; co_exit_value constant simple_integer : = 3 ; co_outer_text constant types_up . short_text_type : = 'Outer Loop counter is ' ; co_inner_text constant types_up . short_text_type : = ' Inner Loop counter is ' ; l_outerlp pls_integer ; l_innerlp pls_integer ; begin l_outerlp : = co_init_loop ; << outerloop >> loop l_innerlp : = co_init_loop ; l_outerlp : = nvl ( l_outerlp , co_init_loop ) + co_increment ; << innerloop >> loop l_innerlp : = nvl ( l_innerlp , co_init_loop ) + co_increment ; sys . dbms_output . put_line ( co_outer_text || l_outerlp || co_inner_text || l_innerlp ); exit outerloop when l_innerlp = co_exit_value ; end loop innerloop ; end loop outerloop ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4385/","text":"G-4385: Never use a cursor for loop to check whether a cursor returns data. Critical Efficiency Reason You might process more data than required, which leads to bad performance. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 declare l_employee_found boolean : = false ; cursor c_employees is select employee_id , last_name from employees ; begin << check_employees >> for r_employee in c_employees loop l_employee_found : = true ; end loop check_employees ; if l_employee_found then null ; -- some processing; end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 declare l_employee_found boolean : = false ; cursor c_employees is select employee_id , last_name from employees ; r_employee c_employees % rowtype ; begin open c_employees ; fetch c_employees into r_employee ; l_employee_found : = c_employees % found ; close c_employees ; if l_employee_found then null ; -- some processing; end if ; end ; /","title":"G-4385: Never use a cursor for loop to check whether a cursor returns data."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4385/#g-4385-never-use-a-cursor-for-loop-to-check-whether-a-cursor-returns-data","text":"Critical Efficiency","title":"G-4385: Never use a cursor for loop to check whether a cursor returns data."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4385/#reason","text":"You might process more data than required, which leads to bad performance.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4385/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 declare l_employee_found boolean : = false ; cursor c_employees is select employee_id , last_name from employees ; begin << check_employees >> for r_employee in c_employees loop l_employee_found : = true ; end loop check_employees ; if l_employee_found then null ; -- some processing; end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4385/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 declare l_employee_found boolean : = false ; cursor c_employees is select employee_id , last_name from employees ; r_employee c_employees % rowtype ; begin open c_employees ; fetch c_employees into r_employee ; l_employee_found : = c_employees % found ; close c_employees ; if l_employee_found then null ; -- some processing; end if ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4387/","text":"G-4387: Never use a FOR LOOP for a query that should return not more than one row. Blocker Reliability, Efficiency, Readability Unsupported in db* CODECOP Validators Without access to the Oracle Data Dictionary, we cannot determine the number of rows to be processed. Reason A for loop can hide a too_many_rows exception. The more complex a query is, the higher is the risk that more than one row will be processed. This affects performance and can lead to a wrong result. A for loop can also hide a no_data_found exception and the reader cannot determine whether this is intentional or not. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is function emp_name ( in_empno in integer ) return varchar2 is -- NOSONAR: non-deterministic l_ename emp . ename % type ; begin << fetch_name >> for r in ( select ename from emp where empno = in_empno ) loop l_ename : = r . ename ; end loop fetch_name ; return l_ename ; end emp_name ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is function emp_name ( in_empno in integer ) return varchar2 is -- NOSONAR: non-deterministic l_ename emp . ename % type ; begin select ename into l_ename from emp where empno = in_empno ; return l_ename ; exception when no_data_found then return null ; when too_many_rows then raise ; end emp_name ; end employee_api ; /","title":"G-4387: Never use a FOR LOOP for a query that should return not more than one row."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4387/#g-4387-never-use-a-for-loop-for-a-query-that-should-return-not-more-than-one-row","text":"Blocker Reliability, Efficiency, Readability Unsupported in db* CODECOP Validators Without access to the Oracle Data Dictionary, we cannot determine the number of rows to be processed.","title":"G-4387: Never use a FOR LOOP for a query that should return not more than one row."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4387/#reason","text":"A for loop can hide a too_many_rows exception. The more complex a query is, the higher is the risk that more than one row will be processed. This affects performance and can lead to a wrong result. A for loop can also hide a no_data_found exception and the reader cannot determine whether this is intentional or not.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4387/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is function emp_name ( in_empno in integer ) return varchar2 is -- NOSONAR: non-deterministic l_ename emp . ename % type ; begin << fetch_name >> for r in ( select ename from emp where empno = in_empno ) loop l_ename : = r . ename ; end loop fetch_name ; return l_ename ; end emp_name ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4387/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is function emp_name ( in_empno in integer ) return varchar2 is -- NOSONAR: non-deterministic l_ename emp . ename % type ; begin select ename into l_ename from emp where empno = in_empno ; return l_ename ; exception when no_data_found then return null ; when too_many_rows then raise ; end emp_name ; end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4390/","text":"G-4390: Avoid use of unreferenced FOR loop indexes. Major Efficiency Reason If the loop index is used for anything but traffic control inside the loop, this is one of the indicators that a numeric for loop is being used incorrectly. The actual body of executable statements completely ignores the loop index. When that is the case, there is a good chance that you do not need the loop at all. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 declare l_row pls_integer ; l_value pls_integer ; co_lower_bound constant simple_integer : = 1 ; co_upper_bound constant simple_integer : = 5 ; co_row_incr constant simple_integer : = 1 ; co_value_incr constant simple_integer : = 10 ; co_delimiter constant types_up . short_text_type : = ' ' ; co_first_value constant simple_integer : = 100 ; begin l_row : = co_lower_bound ; l_value : = co_first_value ; << for_loop >> for i in co_lower_bound .. co_upper_bound loop sys . dbms_output . put_line ( l_row || co_delimiter || l_value ); l_row : = l_row + co_row_incr ; l_value : = l_value + co_value_incr ; end loop for_loop ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 declare co_lower_bound constant simple_integer : = 1 ; co_upper_bound constant simple_integer : = 5 ; co_value_incr constant simple_integer : = 10 ; co_delimiter constant types_up . short_text_type : = ' ' ; co_first_value constant simple_integer : = 100 ; begin << for_loop >> for i in co_lower_bound .. co_upper_bound loop sys . dbms_output . put_line ( i || co_delimiter || to_char ( co_first_value + i * co_value_incr )); end loop for_loop ; end ; /","title":"G-4390: Avoid use of unreferenced FOR loop indexes."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4390/#g-4390-avoid-use-of-unreferenced-for-loop-indexes","text":"Major Efficiency","title":"G-4390: Avoid use of unreferenced FOR loop indexes."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4390/#reason","text":"If the loop index is used for anything but traffic control inside the loop, this is one of the indicators that a numeric for loop is being used incorrectly. The actual body of executable statements completely ignores the loop index. When that is the case, there is a good chance that you do not need the loop at all.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4390/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 declare l_row pls_integer ; l_value pls_integer ; co_lower_bound constant simple_integer : = 1 ; co_upper_bound constant simple_integer : = 5 ; co_row_incr constant simple_integer : = 1 ; co_value_incr constant simple_integer : = 10 ; co_delimiter constant types_up . short_text_type : = ' ' ; co_first_value constant simple_integer : = 100 ; begin l_row : = co_lower_bound ; l_value : = co_first_value ; << for_loop >> for i in co_lower_bound .. co_upper_bound loop sys . dbms_output . put_line ( l_row || co_delimiter || l_value ); l_row : = l_row + co_row_incr ; l_value : = l_value + co_value_incr ; end loop for_loop ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4390/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 declare co_lower_bound constant simple_integer : = 1 ; co_upper_bound constant simple_integer : = 5 ; co_value_incr constant simple_integer : = 10 ; co_delimiter constant types_up . short_text_type : = ' ' ; co_first_value constant simple_integer : = 100 ; begin << for_loop >> for i in co_lower_bound .. co_upper_bound loop sys . dbms_output . put_line ( i || co_delimiter || to_char ( co_first_value + i * co_value_incr )); end loop for_loop ; end ; /","title":"Example (good)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4395/","text":"G-4395: Avoid hard-coded upper or lower bound values with FOR loops. Minor Changeability, Maintainability Reason Your loop statement uses a hard-coded value for either its upper or lower bounds. This creates a \"weak link\" in your program because it assumes that this value will never change. A better practice is to create a named constant (or function) and reference this named element instead of the hard-coded value. Example (bad) 1 2 3 4 5 6 7 8 begin << for_loop >> for i in 1 .. 5 loop sys . dbms_output . put_line ( i ); end loop for_loop ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 declare co_lower_bound constant simple_integer : = 1 ; co_upper_bound constant simple_integer : = 5 ; begin << for_loop >> for i in co_lower_bound .. co_upper_bound loop sys . dbms_output . put_line ( i ); end loop for_loop ; end ; /","title":"G-4395: Avoid hard-coded upper or lower bound values with FOR loops."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4395/#g-4395-avoid-hard-coded-upper-or-lower-bound-values-with-for-loops","text":"Minor Changeability, Maintainability","title":"G-4395: Avoid hard-coded upper or lower bound values with FOR loops."},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4395/#reason","text":"Your loop statement uses a hard-coded value for either its upper or lower bounds. This creates a \"weak link\" in your program because it assumes that this value will never change. A better practice is to create a named constant (or function) and reference this named element instead of the hard-coded value.","title":"Reason"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4395/#example-bad","text":"1 2 3 4 5 6 7 8 begin << for_loop >> for i in 1 .. 5 loop sys . dbms_output . put_line ( i ); end loop for_loop ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/4-control-structures/3-flow-control/g-4395/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 declare co_lower_bound constant simple_integer : = 1 ; co_upper_bound constant simple_integer : = 5 ; begin << for_loop >> for i in co_lower_bound .. co_upper_bound loop sys . dbms_output . put_line ( i ); end loop for_loop ; end ; /","title":"Example (good)"},{"location":"4-language-usage/5-exception-handling/g-5010/","text":"G-5010: Try to use a error/logging framework for your application. Critical Reliability, Reusability, Testability Unsupported in db* CODECOP Validators We cannot identify logging framework and where it should be applied. Requires further definition regarding naming of the error/logging framework and its minimal use in PL/SQL code. Reason Having a framework to raise/handle/log your errors allows you to easily avoid duplicate application error numbers and having different error messages for the same type of error. This kind of framework should include Logging (different channels like table, mail, file, etc. if needed) Error Raising Multilanguage support if needed Translate Oracle Database error messages to a user friendly error text Error repository Example (bad) 1 2 3 4 5 6 7 8 9 declare co_start constant logger_logs . text % type : = 'start' ; co_end constant logger_logs . text % type : = 'end' ; begin sys . dbms_output . put_line ( co_start ); -- some processing sys . dbms_output . put_line ( co_end ); end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 declare -- see https://github.com/OraOpenSource/Logger co_start constant logger_logs . text % type : = 'start' ; co_end constant logger_logs . text % type : = 'end' ; co_scope constant logger_logs . scope % type : = 'demo' ; begin logger . log ( co_start , co_scope ); -- some processing logger . log ( co_end , co_scope ); end ; /","title":"G-5010: Try to use a error/logging framework for your application."},{"location":"4-language-usage/5-exception-handling/g-5010/#g-5010-try-to-use-a-errorlogging-framework-for-your-application","text":"Critical Reliability, Reusability, Testability Unsupported in db* CODECOP Validators We cannot identify logging framework and where it should be applied. Requires further definition regarding naming of the error/logging framework and its minimal use in PL/SQL code.","title":"G-5010: Try to use a error/logging framework for your application."},{"location":"4-language-usage/5-exception-handling/g-5010/#reason","text":"Having a framework to raise/handle/log your errors allows you to easily avoid duplicate application error numbers and having different error messages for the same type of error. This kind of framework should include Logging (different channels like table, mail, file, etc. if needed) Error Raising Multilanguage support if needed Translate Oracle Database error messages to a user friendly error text Error repository","title":"Reason"},{"location":"4-language-usage/5-exception-handling/g-5010/#example-bad","text":"1 2 3 4 5 6 7 8 9 declare co_start constant logger_logs . text % type : = 'start' ; co_end constant logger_logs . text % type : = 'end' ; begin sys . dbms_output . put_line ( co_start ); -- some processing sys . dbms_output . put_line ( co_end ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/5-exception-handling/g-5010/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 declare -- see https://github.com/OraOpenSource/Logger co_start constant logger_logs . text % type : = 'start' ; co_end constant logger_logs . text % type : = 'end' ; co_scope constant logger_logs . scope % type : = 'demo' ; begin logger . log ( co_start , co_scope ); -- some processing logger . log ( co_end , co_scope ); end ; /","title":"Example (good)"},{"location":"4-language-usage/5-exception-handling/g-5020/","text":"G-5020: Never handle unnamed exceptions using the error number. Critical Maintainability Reason When literals are used for error numbers the reader needs the error message manual to unterstand what is going on. Commenting the code or using constants is an option, but it is better to use named exceptions instead, because it ensures a certain level of consistency which makes maintenance easier. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_no_data_found constant integer : = - 1 ; begin my_package . some_processing (); -- some code which raises an exception exception when too_many_rows then my_package . some_further_processing (); when others then if sqlcode = co_no_data_found then null ; end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 begin my_package . some_processing (); -- some code which raises an exception exception when too_many_rows then my_package . some_further_processing (); when no_data_found then null ; -- handle no_data_found end ; /","title":"G-5020: Never handle unnamed exceptions using the error number."},{"location":"4-language-usage/5-exception-handling/g-5020/#g-5020-never-handle-unnamed-exceptions-using-the-error-number","text":"Critical Maintainability","title":"G-5020: Never handle unnamed exceptions using the error number."},{"location":"4-language-usage/5-exception-handling/g-5020/#reason","text":"When literals are used for error numbers the reader needs the error message manual to unterstand what is going on. Commenting the code or using constants is an option, but it is better to use named exceptions instead, because it ensures a certain level of consistency which makes maintenance easier.","title":"Reason"},{"location":"4-language-usage/5-exception-handling/g-5020/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 declare co_no_data_found constant integer : = - 1 ; begin my_package . some_processing (); -- some code which raises an exception exception when too_many_rows then my_package . some_further_processing (); when others then if sqlcode = co_no_data_found then null ; end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/5-exception-handling/g-5020/#example-good","text":"1 2 3 4 5 6 7 8 9 begin my_package . some_processing (); -- some code which raises an exception exception when too_many_rows then my_package . some_further_processing (); when no_data_found then null ; -- handle no_data_found end ; /","title":"Example (good)"},{"location":"4-language-usage/5-exception-handling/g-5030/","text":"G-5030: Never assign predefined exception names to user defined exceptions. Blocker Reliability, Testability Reason This is error-prone because your local declaration overrides the global declaration. While it is technically possible to use the same names, it causes confusion for others needing to read and maintain this code. Additionally, you will need to be very careful to use the prefix standard in front of any reference that needs to use the default exception behavior of the Oracle Database. Example (bad) Using the code below, we are not able to handle the no_data_found exception raised by the select statement as we have overwritten that exception handler. In addition, our exception handler doesn't have an exception number assigned, which should be raised when the select statement does not find any rows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 declare l_dummy dual . dummy % type ; no_data_found exception ; -- violates also naming convention G-9113 co_rownum constant simple_integer : = 0 ; co_no_data_found constant types_up . short_text_type : = 'no_data_found' ; begin select dummy into l_dummy from dual where rownum = co_rownum ; if l_dummy is null then raise no_data_found ; -- NOSONAR: consequential error, violates G-5070 end if ; exception when no_data_found then sys . dbms_output . put_line ( co_no_data_found ); end ; / 1 2 3 4 5 6 Error report - ORA-01403: no data found ORA-06512: at line 7 01403. 00000 - \"no data found\" *Cause: No data was found from the objects. *Action: There was no data from the objects which may be due to end of fetch. Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 declare l_dummy dual . dummy % type ; e_empty_value exception ; co_rownum constant simple_integer : = 0 ; co_empty_value constant types_up . short_text_type : = 'empty_value' ; co_no_data_found constant types_up . short_text_type : = 'no_data_found' ; begin select dummy into l_dummy from dual where rownum = co_rownum ; if l_dummy is null then raise e_empty_value ; end if ; exception when e_empty_value then sys . dbms_output . put_line ( co_empty_value ); when no_data_found then sys . dbms_output . put_line ( co_no_data_found ); end ; /","title":"G-5030: Never assign predefined exception names to user defined exceptions."},{"location":"4-language-usage/5-exception-handling/g-5030/#g-5030-never-assign-predefined-exception-names-to-user-defined-exceptions","text":"Blocker Reliability, Testability","title":"G-5030: Never assign predefined exception names to user defined exceptions."},{"location":"4-language-usage/5-exception-handling/g-5030/#reason","text":"This is error-prone because your local declaration overrides the global declaration. While it is technically possible to use the same names, it causes confusion for others needing to read and maintain this code. Additionally, you will need to be very careful to use the prefix standard in front of any reference that needs to use the default exception behavior of the Oracle Database.","title":"Reason"},{"location":"4-language-usage/5-exception-handling/g-5030/#example-bad","text":"Using the code below, we are not able to handle the no_data_found exception raised by the select statement as we have overwritten that exception handler. In addition, our exception handler doesn't have an exception number assigned, which should be raised when the select statement does not find any rows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 declare l_dummy dual . dummy % type ; no_data_found exception ; -- violates also naming convention G-9113 co_rownum constant simple_integer : = 0 ; co_no_data_found constant types_up . short_text_type : = 'no_data_found' ; begin select dummy into l_dummy from dual where rownum = co_rownum ; if l_dummy is null then raise no_data_found ; -- NOSONAR: consequential error, violates G-5070 end if ; exception when no_data_found then sys . dbms_output . put_line ( co_no_data_found ); end ; / 1 2 3 4 5 6 Error report - ORA-01403: no data found ORA-06512: at line 7 01403. 00000 - \"no data found\" *Cause: No data was found from the objects. *Action: There was no data from the objects which may be due to end of fetch.","title":"Example (bad)"},{"location":"4-language-usage/5-exception-handling/g-5030/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 declare l_dummy dual . dummy % type ; e_empty_value exception ; co_rownum constant simple_integer : = 0 ; co_empty_value constant types_up . short_text_type : = 'empty_value' ; co_no_data_found constant types_up . short_text_type : = 'no_data_found' ; begin select dummy into l_dummy from dual where rownum = co_rownum ; if l_dummy is null then raise e_empty_value ; end if ; exception when e_empty_value then sys . dbms_output . put_line ( co_empty_value ); when no_data_found then sys . dbms_output . put_line ( co_no_data_found ); end ; /","title":"Example (good)"},{"location":"4-language-usage/5-exception-handling/g-5040/","text":"G-5040: Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers. Critical Reliability Reason There is not necessarily anything wrong with using when others , but it can cause you to \"lose\" error information unless your handler code is relatively sophisticated. Generally, you should use when others to grab any and every error only after you have thought about your executable section and decided that you are not able to trap any specific exceptions. If you know, on the other hand, that a certain exception might be raised, include a handler for that error. By declaring two different exception handlers, the code more clearly states what we expect to have happen and how we want to handle the errors. That makes it easier to maintain and enhance. We also avoid hard-coding error numbers in checks against sqlcode . When using a logging framework like Logger, consider making an exception to this rule and allow a when others even without other specific handlers, but only if the when others exception handler calls a logging procedure that saves the error stack (that otherwise is lost) and the last statement of the handler is raise . Example (bad) 1 2 3 4 5 6 7 begin my_package . some_processing (); exception when others then my_package . some_further_processing (); end ; / Example (good) 1 2 3 4 5 6 7 begin my_package . some_processing (); exception when dup_val_on_index then my_package . some_further_processing (); end ; / An exception to the rule where when others can be good to log the error and then re-raise it: 1 2 3 4 5 6 7 8 begin my_package . some_processing (); exception when others then logger . log_error ( 'Unhandled Exception' ); raise ; end ; /","title":"G-5040: Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers."},{"location":"4-language-usage/5-exception-handling/g-5040/#g-5040-avoid-use-of-when-others-clause-in-an-exception-section-without-any-other-specific-handlers","text":"Critical Reliability","title":"G-5040: Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers."},{"location":"4-language-usage/5-exception-handling/g-5040/#reason","text":"There is not necessarily anything wrong with using when others , but it can cause you to \"lose\" error information unless your handler code is relatively sophisticated. Generally, you should use when others to grab any and every error only after you have thought about your executable section and decided that you are not able to trap any specific exceptions. If you know, on the other hand, that a certain exception might be raised, include a handler for that error. By declaring two different exception handlers, the code more clearly states what we expect to have happen and how we want to handle the errors. That makes it easier to maintain and enhance. We also avoid hard-coding error numbers in checks against sqlcode . When using a logging framework like Logger, consider making an exception to this rule and allow a when others even without other specific handlers, but only if the when others exception handler calls a logging procedure that saves the error stack (that otherwise is lost) and the last statement of the handler is raise .","title":"Reason"},{"location":"4-language-usage/5-exception-handling/g-5040/#example-bad","text":"1 2 3 4 5 6 7 begin my_package . some_processing (); exception when others then my_package . some_further_processing (); end ; /","title":"Example (bad)"},{"location":"4-language-usage/5-exception-handling/g-5040/#example-good","text":"1 2 3 4 5 6 7 begin my_package . some_processing (); exception when dup_val_on_index then my_package . some_further_processing (); end ; / An exception to the rule where when others can be good to log the error and then re-raise it: 1 2 3 4 5 6 7 8 begin my_package . some_processing (); exception when others then logger . log_error ( 'Unhandled Exception' ); raise ; end ; /","title":"Example (good)"},{"location":"4-language-usage/5-exception-handling/g-5050/","text":"G-5050: Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded 20nnn error number or hard-coded message. Major Changeability, Maintainability Reason If you are not very organized in the way you allocate, define and use the error numbers between 20999 and 20000 (those reserved by the Oracle Database for its user community), it is very easy to end up with conflicting usages. You should assign these error numbers to named constants and consolidate all definitions within a single package. When you call raise_application_error , you should reference these named elements and error message text stored in a table. Use your own raise procedure in place of explicit calls to raise_application_error . If you are raising a \"system\" exception like no_data_found , you must use raise . However, when you want to raise an application-specific error, you use raise_application_error . If you use the latter, you then have to provide an error number and message. This leads to unnecessary and damaging hard-coded values. A more fail-safe approach is to provide a predefined raise procedure that automatically checks the error number and determines the correct way to raise the error. Example (bad) 1 2 3 4 5 6 declare co_invalid_emp_text constant types_up . text : = 'Invalid employee_id' ; begin raise_application_error ( - 20501 /* violates also G-1010 */ , co_invalid_emp_text ); end ; / Example (good) 1 2 3 4 begin err_up . raise ( in_error => err . co_invalid_employee_id ); end ; /","title":"G-5050: Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded 20nnn error number or hard-coded message."},{"location":"4-language-usage/5-exception-handling/g-5050/#g-5050-avoid-use-of-the-raise_application_error-built-in-procedure-with-a-hard-coded-20nnn-error-number-or-hard-coded-message","text":"Major Changeability, Maintainability","title":"G-5050: Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded 20nnn error number or hard-coded message."},{"location":"4-language-usage/5-exception-handling/g-5050/#reason","text":"If you are not very organized in the way you allocate, define and use the error numbers between 20999 and 20000 (those reserved by the Oracle Database for its user community), it is very easy to end up with conflicting usages. You should assign these error numbers to named constants and consolidate all definitions within a single package. When you call raise_application_error , you should reference these named elements and error message text stored in a table. Use your own raise procedure in place of explicit calls to raise_application_error . If you are raising a \"system\" exception like no_data_found , you must use raise . However, when you want to raise an application-specific error, you use raise_application_error . If you use the latter, you then have to provide an error number and message. This leads to unnecessary and damaging hard-coded values. A more fail-safe approach is to provide a predefined raise procedure that automatically checks the error number and determines the correct way to raise the error.","title":"Reason"},{"location":"4-language-usage/5-exception-handling/g-5050/#example-bad","text":"1 2 3 4 5 6 declare co_invalid_emp_text constant types_up . text : = 'Invalid employee_id' ; begin raise_application_error ( - 20501 /* violates also G-1010 */ , co_invalid_emp_text ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/5-exception-handling/g-5050/#example-good","text":"1 2 3 4 begin err_up . raise ( in_error => err . co_invalid_employee_id ); end ; /","title":"Example (good)"},{"location":"4-language-usage/5-exception-handling/g-5060/","text":"G-5060: Avoid unhandled exceptions. Major Reliability Reason This may be your intention, but you should review the code to confirm this behavior. If you are raising an error in a program, then you are clearly predicting a situation in which that error will occur. You should consider including a handler in your code for predictable errors, allowing for a graceful and informative failure. After all, it is much more difficult for an enclosing block to be aware of the various errors you might raise and more importantly, what should be done in response to the error. The form that this failure takes does not necessarily need to be an exception. When writing functions, you may well decide that in the case of certain exceptions, you will want to return a value such as null , rather than allow an exception to propagate out of the function. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 create or replace package body department_api is function name_by_id ( in_id in departments . department_id % type ) -- NOSONAR: non-deterministic return departments . department_name % type is co_id constant departments . department_id % type : = in_id ; l_department_name departments . department_name % type ; begin select department_name into l_department_name from departments where department_id = co_id ; return l_department_name ; end name_by_id ; end department_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body department_api is function name_by_id ( in_id in departments . department_id % type ) -- NOSONAR: non-deterministic return departments . department_name % type is co_id constant departments . department_id % type : = in_id ; l_department_name departments . department_name % type ; begin select department_name into l_department_name from departments where department_id = co_id ; return l_department_name ; exception when no_data_found then return null ; when too_many_rows then raise ; end name_by_id ; end department_api ; /","title":"G-5060: Avoid unhandled exceptions."},{"location":"4-language-usage/5-exception-handling/g-5060/#g-5060-avoid-unhandled-exceptions","text":"Major Reliability","title":"G-5060: Avoid unhandled exceptions."},{"location":"4-language-usage/5-exception-handling/g-5060/#reason","text":"This may be your intention, but you should review the code to confirm this behavior. If you are raising an error in a program, then you are clearly predicting a situation in which that error will occur. You should consider including a handler in your code for predictable errors, allowing for a graceful and informative failure. After all, it is much more difficult for an enclosing block to be aware of the various errors you might raise and more importantly, what should be done in response to the error. The form that this failure takes does not necessarily need to be an exception. When writing functions, you may well decide that in the case of certain exceptions, you will want to return a value such as null , rather than allow an exception to propagate out of the function.","title":"Reason"},{"location":"4-language-usage/5-exception-handling/g-5060/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 create or replace package body department_api is function name_by_id ( in_id in departments . department_id % type ) -- NOSONAR: non-deterministic return departments . department_name % type is co_id constant departments . department_id % type : = in_id ; l_department_name departments . department_name % type ; begin select department_name into l_department_name from departments where department_id = co_id ; return l_department_name ; end name_by_id ; end department_api ; /","title":"Example (bad)"},{"location":"4-language-usage/5-exception-handling/g-5060/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body department_api is function name_by_id ( in_id in departments . department_id % type ) -- NOSONAR: non-deterministic return departments . department_name % type is co_id constant departments . department_id % type : = in_id ; l_department_name departments . department_name % type ; begin select department_name into l_department_name from departments where department_id = co_id ; return l_department_name ; exception when no_data_found then return null ; when too_many_rows then raise ; end name_by_id ; end department_api ; /","title":"Example (good)"},{"location":"4-language-usage/5-exception-handling/g-5070/","text":"G-5070: Avoid using Oracle predefined exceptions. Blocker Reliability Reason You have raised an exception whose name was defined by Oracle. While it is possible that you have a good reason for \"using\" one of Oracle's predefined exceptions, you should make sure that you would not be better off declaring your own exception and raising that instead. If you decide to change the exception you are using, you should apply the same consideration to your own exceptions. Specifically, do not \"re-use\" exceptions. You should define a separate exception for each error condition, rather than use the same exception for different circumstances. Being as specific as possible with the errors raised will allow developers to check for, and handle, the different kinds of errors the code might produce. Example (bad) 1 2 3 4 begin raise no_data_found ; end ; / Example (good) 1 2 3 4 5 6 declare e_my_exception exception ; begin raise e_my_exception ; end ; /","title":"G-5070: Avoid using Oracle predefined exceptions."},{"location":"4-language-usage/5-exception-handling/g-5070/#g-5070-avoid-using-oracle-predefined-exceptions","text":"Blocker Reliability","title":"G-5070: Avoid using Oracle predefined exceptions."},{"location":"4-language-usage/5-exception-handling/g-5070/#reason","text":"You have raised an exception whose name was defined by Oracle. While it is possible that you have a good reason for \"using\" one of Oracle's predefined exceptions, you should make sure that you would not be better off declaring your own exception and raising that instead. If you decide to change the exception you are using, you should apply the same consideration to your own exceptions. Specifically, do not \"re-use\" exceptions. You should define a separate exception for each error condition, rather than use the same exception for different circumstances. Being as specific as possible with the errors raised will allow developers to check for, and handle, the different kinds of errors the code might produce.","title":"Reason"},{"location":"4-language-usage/5-exception-handling/g-5070/#example-bad","text":"1 2 3 4 begin raise no_data_found ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/5-exception-handling/g-5070/#example-good","text":"1 2 3 4 5 6 declare e_my_exception exception ; begin raise e_my_exception ; end ; /","title":"Example (good)"},{"location":"4-language-usage/5-exception-handling/g-5080/","text":"G-5080: Always use FORMAT_ERROR_BACKTRACE when using FORMAT_ERROR_STACK or SQLERRM. Critical Maintainability, Testability Reason In exception handler sqlerrm and format_error_stack won't tell you the exact line where the error occurred. format_error_backtrace displays the call stack at the point where an exception was raised, even if the subprogram is called from an exception handler in an outer scope. If you use sqlerrm or format_error_stack to log/display error, you should also include format_error_backtrace to identify the exact location where the exception was raised. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create or replace package body order_api as procedure discount_and_recalculate ( in_customer_id in integer , in_discount in number ) is co_customer_id constant customer . id % type : = in_customer_id ; co_discount constant customer . discount_percentage % type : = in_discount ; co_error_label constant type_up . text : = 'Error: ' ; begin customer_api . apply_discount ( in_customer_id => co_customer_id , in_discount => co_discount ); customer_api . calc ( co_customer_id ); exception when zero_divide then null ; -- ignore when others then logging_package . log_error ( co_error_label || sqlerrm ); raise ; end discount_and_recalculate ; end order_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 create or replace package body order_api as procedure discount_and_recalculate ( in_customer_id in integer , in_discount in number ) is co_customer_id constant customer . id % type : = in_customer_id ; co_discount constant customer . discount_percentage % type : = in_discount ; co_error_label constant type_up . text : = 'Error: ' ; co_backtrace_label constant type_up . text : = ' - Backtrace: ' ; begin customer_api . apply_discount ( in_customer_id => co_customer_id , in_discount => co_discount ); customer_api . calc ( co_customer_id ); exception when zero_divide then null ; -- ignore when others then logging_package . log_error ( co_error_label || sqlerrm || co_backtrace_label || sys . dbms_utility . format_error_backtrace ); raise ; end discount_and_recalculate ; end order_api ; /","title":"G-5080: Always use FORMAT_ERROR_BACKTRACE when using FORMAT_ERROR_STACK or SQLERRM."},{"location":"4-language-usage/5-exception-handling/g-5080/#g-5080-always-use-format_error_backtrace-when-using-format_error_stack-or-sqlerrm","text":"Critical Maintainability, Testability","title":"G-5080: Always use FORMAT_ERROR_BACKTRACE when using FORMAT_ERROR_STACK or SQLERRM."},{"location":"4-language-usage/5-exception-handling/g-5080/#reason","text":"In exception handler sqlerrm and format_error_stack won't tell you the exact line where the error occurred. format_error_backtrace displays the call stack at the point where an exception was raised, even if the subprogram is called from an exception handler in an outer scope. If you use sqlerrm or format_error_stack to log/display error, you should also include format_error_backtrace to identify the exact location where the exception was raised.","title":"Reason"},{"location":"4-language-usage/5-exception-handling/g-5080/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create or replace package body order_api as procedure discount_and_recalculate ( in_customer_id in integer , in_discount in number ) is co_customer_id constant customer . id % type : = in_customer_id ; co_discount constant customer . discount_percentage % type : = in_discount ; co_error_label constant type_up . text : = 'Error: ' ; begin customer_api . apply_discount ( in_customer_id => co_customer_id , in_discount => co_discount ); customer_api . calc ( co_customer_id ); exception when zero_divide then null ; -- ignore when others then logging_package . log_error ( co_error_label || sqlerrm ); raise ; end discount_and_recalculate ; end order_api ; /","title":"Example (bad)"},{"location":"4-language-usage/5-exception-handling/g-5080/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 create or replace package body order_api as procedure discount_and_recalculate ( in_customer_id in integer , in_discount in number ) is co_customer_id constant customer . id % type : = in_customer_id ; co_discount constant customer . discount_percentage % type : = in_discount ; co_error_label constant type_up . text : = 'Error: ' ; co_backtrace_label constant type_up . text : = ' - Backtrace: ' ; begin customer_api . apply_discount ( in_customer_id => co_customer_id , in_discount => co_discount ); customer_api . calc ( co_customer_id ); exception when zero_divide then null ; -- ignore when others then logging_package . log_error ( co_error_label || sqlerrm || co_backtrace_label || sys . dbms_utility . format_error_backtrace ); raise ; end discount_and_recalculate ; end order_api ; /","title":"Example (good)"},{"location":"4-language-usage/6-dynamic-sql/g-6010/","text":"G-6010: Always use a character variable to execute dynamic SQL. Major Maintainability, Testability Reason Having the executed statement in a variable makes it easier to debug your code (e.g. by logging the statement that failed). Example (bad) 1 2 3 4 5 6 7 declare l_next_val employees . employee_id % type ; begin execute immediate 'select employees_seq.nextval from dual' into l_next_val ; end ; / Example (good) 1 2 3 4 5 6 7 8 declare l_next_val employees . employee_id % type ; co_sql constant types_up . big_string_type : = 'select employees_seq.nextval from dual' ; begin execute immediate co_sql into l_next_val ; end ; /","title":"G-6010: Always use a character variable to execute dynamic SQL."},{"location":"4-language-usage/6-dynamic-sql/g-6010/#g-6010-always-use-a-character-variable-to-execute-dynamic-sql","text":"Major Maintainability, Testability","title":"G-6010: Always use a character variable to execute dynamic SQL."},{"location":"4-language-usage/6-dynamic-sql/g-6010/#reason","text":"Having the executed statement in a variable makes it easier to debug your code (e.g. by logging the statement that failed).","title":"Reason"},{"location":"4-language-usage/6-dynamic-sql/g-6010/#example-bad","text":"1 2 3 4 5 6 7 declare l_next_val employees . employee_id % type ; begin execute immediate 'select employees_seq.nextval from dual' into l_next_val ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/6-dynamic-sql/g-6010/#example-good","text":"1 2 3 4 5 6 7 8 declare l_next_val employees . employee_id % type ; co_sql constant types_up . big_string_type : = 'select employees_seq.nextval from dual' ; begin execute immediate co_sql into l_next_val ; end ; /","title":"Example (good)"},{"location":"4-language-usage/6-dynamic-sql/g-6020/","text":"G-6020: Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause. Minor Maintainability Reason When a dynamic insert , update , or delete statement has a returning clause, output bind arguments can go in the returning into clause or in the using clause. You should use the returning into clause for values returned from a DML operation. Reserve out and in out bind variables for dynamic PL/SQL blocks that return values in PL/SQL variables. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create or replace package body employee_api is procedure upd_salary ( in_employee_id in employees . employee_id % type , in_increase_pct in types_up . percentage , out_new_salary out employees . salary % type ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_increase_pct constant types_up . percentage : = in_increase_pct ; co_sql_stmt constant types_up . big_string_type : = ' update employees set salary = salary + (salary / 100 * :1) where employee_id = :2 returning salary into :3' ; begin execute immediate co_sql_stmt using co_increase_pct , co_employee_id , out out_new_salary ; end upd_salary ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body employee_api is procedure upd_salary ( in_employee_id in employees . employee_id % type , in_increase_pct in types_up . percentage , out_new_salary out employees . salary % type ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_increase_pct constant types_up . percentage : = in_increase_pct ; co_sql_stmt constant types_up . big_string_type : = ' update employees set salary = salary + (salary / 100 * :1) where employee_id = :2 returning salary into :3' ; begin execute immediate co_sql_stmt using co_increase_pct , co_employee_id returning into out_new_salary ; end upd_salary ; end employee_api ; /","title":"G-6020: Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause."},{"location":"4-language-usage/6-dynamic-sql/g-6020/#g-6020-try-to-use-output-bind-arguments-in-the-returning-into-clause-of-dynamic-dml-statements-rather-than-the-using-clause","text":"Minor Maintainability","title":"G-6020: Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause."},{"location":"4-language-usage/6-dynamic-sql/g-6020/#reason","text":"When a dynamic insert , update , or delete statement has a returning clause, output bind arguments can go in the returning into clause or in the using clause. You should use the returning into clause for values returned from a DML operation. Reserve out and in out bind variables for dynamic PL/SQL blocks that return values in PL/SQL variables.","title":"Reason"},{"location":"4-language-usage/6-dynamic-sql/g-6020/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create or replace package body employee_api is procedure upd_salary ( in_employee_id in employees . employee_id % type , in_increase_pct in types_up . percentage , out_new_salary out employees . salary % type ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_increase_pct constant types_up . percentage : = in_increase_pct ; co_sql_stmt constant types_up . big_string_type : = ' update employees set salary = salary + (salary / 100 * :1) where employee_id = :2 returning salary into :3' ; begin execute immediate co_sql_stmt using co_increase_pct , co_employee_id , out out_new_salary ; end upd_salary ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/6-dynamic-sql/g-6020/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body employee_api is procedure upd_salary ( in_employee_id in employees . employee_id % type , in_increase_pct in types_up . percentage , out_new_salary out employees . salary % type ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_increase_pct constant types_up . percentage : = in_increase_pct ; co_sql_stmt constant types_up . big_string_type : = ' update employees set salary = salary + (salary / 100 * :1) where employee_id = :2 returning salary into :3' ; begin execute immediate co_sql_stmt using co_increase_pct , co_employee_id returning into out_new_salary ; end upd_salary ; end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7110/","text":"G-7110: Try to use named notation when calling program units. Major Changeability, Maintainability Reason Named notation makes sure that changes to the signature of the called program unit do not affect your call. This is not needed for standard functions like ( to_char , to_date , nvl , round , etc.) but should be followed for any other stored object having more than one parameter. Example (bad) 1 2 3 4 5 6 7 declare r_employee employees % rowtype ; co_id constant employees . employee_id % type : = 107 ; begin employee_api . employee_by_id ( r_employee , co_id ); end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 declare r_employee employees % rowtype ; co_id constant employees . employee_id % type : = 107 ; begin employee_api . employee_by_id ( out_row => r_employee , in_employee_id => co_id ); end ; /","title":"G-7110: Try to use named notation when calling program units."},{"location":"4-language-usage/7-stored-objects/1-general/g-7110/#g-7110-try-to-use-named-notation-when-calling-program-units","text":"Major Changeability, Maintainability","title":"G-7110: Try to use named notation when calling program units."},{"location":"4-language-usage/7-stored-objects/1-general/g-7110/#reason","text":"Named notation makes sure that changes to the signature of the called program unit do not affect your call. This is not needed for standard functions like ( to_char , to_date , nvl , round , etc.) but should be followed for any other stored object having more than one parameter.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/1-general/g-7110/#example-bad","text":"1 2 3 4 5 6 7 declare r_employee employees % rowtype ; co_id constant employees . employee_id % type : = 107 ; begin employee_api . employee_by_id ( r_employee , co_id ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7110/#example-good","text":"1 2 3 4 5 6 7 8 9 10 declare r_employee employees % rowtype ; co_id constant employees . employee_id % type : = 107 ; begin employee_api . employee_by_id ( out_row => r_employee , in_employee_id => co_id ); end ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7120/","text":"G-7120: Always add the name of the program unit to its end keyword. Minor Maintainability Reason It's a good alternative for comments to indicate the end of program units, especially if they are lengthy or nested. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body employee_api is function employee_by_id ( in_employee_id in integer ) -- NOSONAR: non-deterministic return employees % rowtype is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_employee employees % rowtype ; begin select * into r_employee from employees where employee_id = co_employee_id ; return r_employee ; exception when no_data_found then null ; when too_many_rows then raise ; end ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body employee_api is function employee_by_id ( in_employee_id in integer ) -- NOSONAR: non-deterministic return employees % rowtype is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_employee employees % rowtype ; begin select * into r_employee from employees where employee_id = co_employee_id ; return r_employee ; exception when no_data_found then null ; when too_many_rows then raise ; end employee_by_id ; end employee_api ; /","title":"G-7120: Always add the name of the program unit to its end keyword."},{"location":"4-language-usage/7-stored-objects/1-general/g-7120/#g-7120-always-add-the-name-of-the-program-unit-to-its-end-keyword","text":"Minor Maintainability","title":"G-7120: Always add the name of the program unit to its end keyword."},{"location":"4-language-usage/7-stored-objects/1-general/g-7120/#reason","text":"It's a good alternative for comments to indicate the end of program units, especially if they are lengthy or nested.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/1-general/g-7120/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body employee_api is function employee_by_id ( in_employee_id in integer ) -- NOSONAR: non-deterministic return employees % rowtype is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_employee employees % rowtype ; begin select * into r_employee from employees where employee_id = co_employee_id ; return r_employee ; exception when no_data_found then null ; when too_many_rows then raise ; end ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7120/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body employee_api is function employee_by_id ( in_employee_id in integer ) -- NOSONAR: non-deterministic return employees % rowtype is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_employee employees % rowtype ; begin select * into r_employee from employees where employee_id = co_employee_id ; return r_employee ; exception when no_data_found then null ; when too_many_rows then raise ; end employee_by_id ; end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7125/","text":"G-7125: Always use CREATE OR REPLACE instead of CREATE alone. Major Maintainability Reason Using create alone makes your scripts give an error if the program unit already exists, which makes the script not repeatable. It is good practice to use create or replace to avoid such errors. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create package body employee_api is function employee_by_id ( in_employee_id in integer ) -- NOSONAR: non-deterministic return employees % rowtype is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_employee employees % rowtype ; begin select * into r_employee from employees where employee_id = co_employee_id ; return r_employee ; exception when no_data_found then null ; when too_many_rows then raise ; end employee_by_id ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body employee_api is function employee_by_id ( in_employee_id in integer ) -- NOSONAR: non-deterministic return employees % rowtype is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_employee employees % rowtype ; begin select * into r_employee from employees where employee_id = co_employee_id ; return r_employee ; exception when no_data_found then null ; when too_many_rows then raise ; end employee_by_id ; end employee_api ; /","title":"G-7125: Always use CREATE OR REPLACE instead of CREATE alone."},{"location":"4-language-usage/7-stored-objects/1-general/g-7125/#g-7125-always-use-create-or-replace-instead-of-create-alone","text":"Major Maintainability","title":"G-7125: Always use CREATE OR REPLACE instead of CREATE alone."},{"location":"4-language-usage/7-stored-objects/1-general/g-7125/#reason","text":"Using create alone makes your scripts give an error if the program unit already exists, which makes the script not repeatable. It is good practice to use create or replace to avoid such errors.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/1-general/g-7125/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create package body employee_api is function employee_by_id ( in_employee_id in integer ) -- NOSONAR: non-deterministic return employees % rowtype is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_employee employees % rowtype ; begin select * into r_employee from employees where employee_id = co_employee_id ; return r_employee ; exception when no_data_found then null ; when too_many_rows then raise ; end employee_by_id ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7125/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 create or replace package body employee_api is function employee_by_id ( in_employee_id in integer ) -- NOSONAR: non-deterministic return employees % rowtype is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_employee employees % rowtype ; begin select * into r_employee from employees where employee_id = co_employee_id ; return r_employee ; exception when no_data_found then null ; when too_many_rows then raise ; end employee_by_id ; end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7130/","text":"G-7130: Always use parameters or pull in definitions rather than referencing external variables in a local program unit. Major Maintainability, Reliability, Testability Reason Local procedures and functions offer an excellent way to avoid code redundancy and make your code more readable (and thus more maintainable). Your local program refers, however, an external data structure, i.e., a variable that is declared outside of the local program. Thus, it is acting as a global variable inside the program. This external dependency is hidden, and may cause problems in the future. You should instead add a parameter to the parameter list of this program and pass the value through the list. This technique makes your program more reusable and avoids scoping problems, i.e. the program unit is less tied to particular variables in the program. In addition, unit encapsulation makes maintenance a lot easier and cheaper. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 create or replace package body employee_api is procedure calc_salary ( in_employee_id in integer ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_emp employees % rowtype ; function commission return number is -- NOSONAR: non-deterministic l_commission employees . salary % type : = 0 ; begin if r_emp . commission_pct is not null then l_commission : = r_emp . salary * r_emp . commission_pct ; end if ; return l_commission ; end commission ; begin select * into r_emp from employees where employee_id = co_employee_id ; sys . dbms_output . put_line ( r_emp . salary + commission ()); exception when no_data_found then null ; when too_many_rows then null ; end calc_salary ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 create or replace package body employee_api is procedure calc_salary ( in_employee_id in integer ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_emp employees % rowtype ; function commission ( in_salary in number , in_comm_pct in number ) return number deterministic is co_salary constant employees . salary % type : = in_salary ; co_comm_pct constant employees . commission_pct % type : = in_comm_pct ; l_commission employees . salary % type : = 0 ; begin if in_comm_pct is not null then l_commission : = co_salary * co_comm_pct ; end if ; return l_commission ; end commission ; begin select * into r_emp from employees where employee_id = co_employee_id ; sys . dbms_output . put_line ( r_emp . salary + commission ( in_salary => r_emp . salary , in_comm_pct => r_emp . commission_pct ) ); exception when no_data_found then null ; when too_many_rows then null ; end calc_salary ; end employee_api ; /","title":"G-7130: Always use parameters or pull in definitions rather than referencing external variables in a local program unit."},{"location":"4-language-usage/7-stored-objects/1-general/g-7130/#g-7130-always-use-parameters-or-pull-in-definitions-rather-than-referencing-external-variables-in-a-local-program-unit","text":"Major Maintainability, Reliability, Testability","title":"G-7130: Always use parameters or pull in definitions rather than referencing external variables in a local program unit."},{"location":"4-language-usage/7-stored-objects/1-general/g-7130/#reason","text":"Local procedures and functions offer an excellent way to avoid code redundancy and make your code more readable (and thus more maintainable). Your local program refers, however, an external data structure, i.e., a variable that is declared outside of the local program. Thus, it is acting as a global variable inside the program. This external dependency is hidden, and may cause problems in the future. You should instead add a parameter to the parameter list of this program and pass the value through the list. This technique makes your program more reusable and avoids scoping problems, i.e. the program unit is less tied to particular variables in the program. In addition, unit encapsulation makes maintenance a lot easier and cheaper.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/1-general/g-7130/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 create or replace package body employee_api is procedure calc_salary ( in_employee_id in integer ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_emp employees % rowtype ; function commission return number is -- NOSONAR: non-deterministic l_commission employees . salary % type : = 0 ; begin if r_emp . commission_pct is not null then l_commission : = r_emp . salary * r_emp . commission_pct ; end if ; return l_commission ; end commission ; begin select * into r_emp from employees where employee_id = co_employee_id ; sys . dbms_output . put_line ( r_emp . salary + commission ()); exception when no_data_found then null ; when too_many_rows then null ; end calc_salary ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7130/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 create or replace package body employee_api is procedure calc_salary ( in_employee_id in integer ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; r_emp employees % rowtype ; function commission ( in_salary in number , in_comm_pct in number ) return number deterministic is co_salary constant employees . salary % type : = in_salary ; co_comm_pct constant employees . commission_pct % type : = in_comm_pct ; l_commission employees . salary % type : = 0 ; begin if in_comm_pct is not null then l_commission : = co_salary * co_comm_pct ; end if ; return l_commission ; end commission ; begin select * into r_emp from employees where employee_id = co_employee_id ; sys . dbms_output . put_line ( r_emp . salary + commission ( in_salary => r_emp . salary , in_comm_pct => r_emp . commission_pct ) ); exception when no_data_found then null ; when too_many_rows then null ; end calc_salary ; end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7140/","text":"G-7140: Always ensure that locally defined procedures or functions are referenced. Major Maintainability, Reliability Reason This can occur as the result of changes to code over time, but you should make sure that this situation does not reflect a problem. And you should remove the declaration to avoid maintenance errors in the future. You should go through your programs and remove any part of your code that is no longer used. This is a relatively straightforward process for variables and named constants. Simply execute searches for a variable's name in that variable's scope. If you find that the only place it appears is in its declaration, delete the declaration. There is never a better time to review all the steps you took, and to understand the reasons you took them, then immediately upon completion of your program. If you wait, you will find it particularly difficult to remember those parts of the program that were needed at one point, but were rendered unnecessary in the end. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body my_package is procedure my_procedure is function my_func return number deterministic is co_true constant integer : = 1 ; begin return co_true ; end my_func ; begin null ; end my_procedure ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body my_package is procedure my_procedure is function my_func return number deterministic is co_true constant integer : = 1 ; begin return co_true ; end my_func ; begin sys . dbms_output . put_line ( my_func ()); end my_procedure ; end my_package ; /","title":"G-7140: Always ensure that locally defined procedures or functions are referenced."},{"location":"4-language-usage/7-stored-objects/1-general/g-7140/#g-7140-always-ensure-that-locally-defined-procedures-or-functions-are-referenced","text":"Major Maintainability, Reliability","title":"G-7140: Always ensure that locally defined procedures or functions are referenced."},{"location":"4-language-usage/7-stored-objects/1-general/g-7140/#reason","text":"This can occur as the result of changes to code over time, but you should make sure that this situation does not reflect a problem. And you should remove the declaration to avoid maintenance errors in the future. You should go through your programs and remove any part of your code that is no longer used. This is a relatively straightforward process for variables and named constants. Simply execute searches for a variable's name in that variable's scope. If you find that the only place it appears is in its declaration, delete the declaration. There is never a better time to review all the steps you took, and to understand the reasons you took them, then immediately upon completion of your program. If you wait, you will find it particularly difficult to remember those parts of the program that were needed at one point, but were rendered unnecessary in the end.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/1-general/g-7140/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body my_package is procedure my_procedure is function my_func return number deterministic is co_true constant integer : = 1 ; begin return co_true ; end my_func ; begin null ; end my_procedure ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7140/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body my_package is procedure my_procedure is function my_func return number deterministic is co_true constant integer : = 1 ; begin return co_true ; end my_func ; begin sys . dbms_output . put_line ( my_func ()); end my_procedure ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7150/","text":"G-7150: Try to remove unused parameters. Major Efficiency, Maintainability Reason You should go through your programs and remove any parameter that is no longer used. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 create or replace package body department_api is function name_by_id ( -- NOSONAR: non-deterministic in_department_id in integer , in_manager in employees % rowtype ) return departments . department_name % type is co_department_id constant departments . department_id % type : = in_department_id ; l_department_name departments . department_name % type ; begin << find_department >> begin select department_name into l_department_name from departments where department_id = co_department_id ; exception when no_data_found or too_many_rows then l_department_name : = null ; end find_department ; return l_department_name ; end name_by_id ; end department_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create or replace package body department_api is function name_by_id ( -- NOSONAR: non-deterministic in_department_id in integer ) return departments . department_name % type is co_department_id constant departments . department_id % type : = in_department_id ; l_department_name departments . department_name % type ; begin << find_department >> begin select department_name into l_department_name from departments where department_id = co_department_id ; exception when no_data_found or too_many_rows then l_department_name : = null ; end find_department ; return l_department_name ; end name_by_id ; end department_api ; /","title":"G-7150: Try to remove unused parameters."},{"location":"4-language-usage/7-stored-objects/1-general/g-7150/#g-7150-try-to-remove-unused-parameters","text":"Major Efficiency, Maintainability","title":"G-7150: Try to remove unused parameters."},{"location":"4-language-usage/7-stored-objects/1-general/g-7150/#reason","text":"You should go through your programs and remove any parameter that is no longer used.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/1-general/g-7150/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 create or replace package body department_api is function name_by_id ( -- NOSONAR: non-deterministic in_department_id in integer , in_manager in employees % rowtype ) return departments . department_name % type is co_department_id constant departments . department_id % type : = in_department_id ; l_department_name departments . department_name % type ; begin << find_department >> begin select department_name into l_department_name from departments where department_id = co_department_id ; exception when no_data_found or too_many_rows then l_department_name : = null ; end find_department ; return l_department_name ; end name_by_id ; end department_api ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7150/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create or replace package body department_api is function name_by_id ( -- NOSONAR: non-deterministic in_department_id in integer ) return departments . department_name % type is co_department_id constant departments . department_id % type : = in_department_id ; l_department_name departments . department_name % type ; begin << find_department >> begin select department_name into l_department_name from departments where department_id = co_department_id ; exception when no_data_found or too_many_rows then l_department_name : = null ; end find_department ; return l_department_name ; end name_by_id ; end department_api ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7160/","text":"G-7160: Always explicitly state parameter mode. Major Maintainability Reason By showing the mode of parameters, you help the reader. If you do not specify a parameter mode, the default mode is in . Explicitly showing the mode indication of all parameters is a more assertive action than simply taking the default mode. Anyone reviewing the code later will be more confident that you intended the parameter mode to be in , out or in out . Example (bad) 1 2 3 4 5 6 7 8 9 create or replace package employee_api is procedure store ( io_id in out employees . id % type , in_first_name employees . first_name % type , in_last_name employees . last_name % type , in_email employees . email % type , in_department_id employees . department_id % type , out_success out pls_integer ); end employee_up ; / Example (good) 1 2 3 4 5 6 7 8 9 create or replace package employee_api is procedure store ( io_id in out employees . id % type , in_first_name in employees . first_name % type , in_last_name in employees . last_name % type , in_email in employees . email % type , in_department_id in employees . department_id % type , out_success out pls_integer ); end employee_up ; /","title":"G-7160: Always explicitly state parameter mode."},{"location":"4-language-usage/7-stored-objects/1-general/g-7160/#g-7160-always-explicitly-state-parameter-mode","text":"Major Maintainability","title":"G-7160: Always explicitly state parameter mode."},{"location":"4-language-usage/7-stored-objects/1-general/g-7160/#reason","text":"By showing the mode of parameters, you help the reader. If you do not specify a parameter mode, the default mode is in . Explicitly showing the mode indication of all parameters is a more assertive action than simply taking the default mode. Anyone reviewing the code later will be more confident that you intended the parameter mode to be in , out or in out .","title":"Reason"},{"location":"4-language-usage/7-stored-objects/1-general/g-7160/#example-bad","text":"1 2 3 4 5 6 7 8 9 create or replace package employee_api is procedure store ( io_id in out employees . id % type , in_first_name employees . first_name % type , in_last_name employees . last_name % type , in_email employees . email % type , in_department_id employees . department_id % type , out_success out pls_integer ); end employee_up ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7160/#example-good","text":"1 2 3 4 5 6 7 8 9 create or replace package employee_api is procedure store ( io_id in out employees . id % type , in_first_name in employees . first_name % type , in_last_name in employees . last_name % type , in_email in employees . email % type , in_department_id in employees . department_id % type , out_success out pls_integer ); end employee_up ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7170/","text":"G-7170: Avoid using an IN OUT parameter as IN or OUT only. Major Efficiency, Maintainability Unsupported in db* CODECOP Validators We cannot determine the usage of an in out parameter in a reliable way, especially when other units are involved which are maintained in another file. Reason Avoid using parameter mode in out unless you actually use the parameter both as input and output. If the code body only reads from the parameter, use in ; if the code body only assigns to the parameter, use out . If at the beginning of a project you expect a parameter to be both input and output and therefore choose in out just in case, but later development shows the parameter actually is only in or out , you should change the parameter mode accordingly. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 create or replace package body employee_up is procedure rcv_emp ( io_first_name in out employees . first_name % type , io_last_name in out employees . last_name % type , io_email in out employees . email % type , io_phone_number in out employees . phone_number % type , io_hire_date in out employees . hire_date % type , io_job_id in out employees . job_id % type , io_salary in out employees . salary % type , io_commission_pct in out employees . commission_pct % type , io_manager_id in out employees . manager_id % type , io_department_id in out employees . department_id % type , in_wait in integer ) is l_status pls_integer ; co_dflt_pipe_name constant string ( 30 char ) : = 'MyPipe' ; co_ok constant pls_integer : = 1 ; co_wait constant pls_integer : = in_wait ; begin -- Receive next message and unpack for each column. l_status : = sys . dbms_pipe . receive_message ( pipename => co_dflt_pipe_name , timeout => co_wait ); if l_status = co_ok then sys . dbms_pipe . unpack_message ( io_first_name ); sys . dbms_pipe . unpack_message ( io_last_name ); sys . dbms_pipe . unpack_message ( io_email ); sys . dbms_pipe . unpack_message ( io_phone_number ); sys . dbms_pipe . unpack_message ( io_hire_date ); sys . dbms_pipe . unpack_message ( io_job_id ); sys . dbms_pipe . unpack_message ( io_salary ); sys . dbms_pipe . unpack_message ( io_commission_pct ); sys . dbms_pipe . unpack_message ( io_manager_id ); sys . dbms_pipe . unpack_message ( io_department_id ); end if ; end rcv_emp ; end employee_up ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 create or replace package body employee_up is procedure rcv_emp ( out_first_name out employees . first_name % type , out_last_name out employees . last_name % type , out_email out employees . email % type , out_phone_number out employees . phone_number % type , out_hire_date out employees . hire_date % type , out_job_id out employees . job_id % type , out_salary out employees . salary % type , out_commission_pct out employees . commission_pct % type , out_manager_id out employees . manager_id % type , out_department_id out employees . department_id % type , in_wait in integer ) is l_status pls_integer ; co_dflt_pipe_name constant string ( 30 char ) : = 'MyPipe' ; co_ok constant pls_integer : = 1 ; co_wait constant pls_integer : = in_wait ; begin -- Receive next message and unpack for each column. l_status : = sys . dbms_pipe . receive_message ( pipename => co_dflt_pipe_name , timeout => co_wait ); if l_status = co_ok then sys . dbms_pipe . unpack_message ( out_first_name ); sys . dbms_pipe . unpack_message ( out_last_name ); sys . dbms_pipe . unpack_message ( out_email ); sys . dbms_pipe . unpack_message ( out_phone_number ); sys . dbms_pipe . unpack_message ( out_hire_date ); sys . dbms_pipe . unpack_message ( out_job_id ); sys . dbms_pipe . unpack_message ( out_salary ); sys . dbms_pipe . unpack_message ( out_commission_pct ); sys . dbms_pipe . unpack_message ( out_manager_id ); sys . dbms_pipe . unpack_message ( out_department_id ); end if ; end rcv_emp ; end employee_up ; /","title":"G-7170: Avoid using an IN OUT parameter as IN or OUT only."},{"location":"4-language-usage/7-stored-objects/1-general/g-7170/#g-7170-avoid-using-an-in-out-parameter-as-in-or-out-only","text":"Major Efficiency, Maintainability Unsupported in db* CODECOP Validators We cannot determine the usage of an in out parameter in a reliable way, especially when other units are involved which are maintained in another file.","title":"G-7170: Avoid using an IN OUT parameter as IN or OUT only."},{"location":"4-language-usage/7-stored-objects/1-general/g-7170/#reason","text":"Avoid using parameter mode in out unless you actually use the parameter both as input and output. If the code body only reads from the parameter, use in ; if the code body only assigns to the parameter, use out . If at the beginning of a project you expect a parameter to be both input and output and therefore choose in out just in case, but later development shows the parameter actually is only in or out , you should change the parameter mode accordingly.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/1-general/g-7170/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 create or replace package body employee_up is procedure rcv_emp ( io_first_name in out employees . first_name % type , io_last_name in out employees . last_name % type , io_email in out employees . email % type , io_phone_number in out employees . phone_number % type , io_hire_date in out employees . hire_date % type , io_job_id in out employees . job_id % type , io_salary in out employees . salary % type , io_commission_pct in out employees . commission_pct % type , io_manager_id in out employees . manager_id % type , io_department_id in out employees . department_id % type , in_wait in integer ) is l_status pls_integer ; co_dflt_pipe_name constant string ( 30 char ) : = 'MyPipe' ; co_ok constant pls_integer : = 1 ; co_wait constant pls_integer : = in_wait ; begin -- Receive next message and unpack for each column. l_status : = sys . dbms_pipe . receive_message ( pipename => co_dflt_pipe_name , timeout => co_wait ); if l_status = co_ok then sys . dbms_pipe . unpack_message ( io_first_name ); sys . dbms_pipe . unpack_message ( io_last_name ); sys . dbms_pipe . unpack_message ( io_email ); sys . dbms_pipe . unpack_message ( io_phone_number ); sys . dbms_pipe . unpack_message ( io_hire_date ); sys . dbms_pipe . unpack_message ( io_job_id ); sys . dbms_pipe . unpack_message ( io_salary ); sys . dbms_pipe . unpack_message ( io_commission_pct ); sys . dbms_pipe . unpack_message ( io_manager_id ); sys . dbms_pipe . unpack_message ( io_department_id ); end if ; end rcv_emp ; end employee_up ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/1-general/g-7170/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 create or replace package body employee_up is procedure rcv_emp ( out_first_name out employees . first_name % type , out_last_name out employees . last_name % type , out_email out employees . email % type , out_phone_number out employees . phone_number % type , out_hire_date out employees . hire_date % type , out_job_id out employees . job_id % type , out_salary out employees . salary % type , out_commission_pct out employees . commission_pct % type , out_manager_id out employees . manager_id % type , out_department_id out employees . department_id % type , in_wait in integer ) is l_status pls_integer ; co_dflt_pipe_name constant string ( 30 char ) : = 'MyPipe' ; co_ok constant pls_integer : = 1 ; co_wait constant pls_integer : = in_wait ; begin -- Receive next message and unpack for each column. l_status : = sys . dbms_pipe . receive_message ( pipename => co_dflt_pipe_name , timeout => co_wait ); if l_status = co_ok then sys . dbms_pipe . unpack_message ( out_first_name ); sys . dbms_pipe . unpack_message ( out_last_name ); sys . dbms_pipe . unpack_message ( out_email ); sys . dbms_pipe . unpack_message ( out_phone_number ); sys . dbms_pipe . unpack_message ( out_hire_date ); sys . dbms_pipe . unpack_message ( out_job_id ); sys . dbms_pipe . unpack_message ( out_salary ); sys . dbms_pipe . unpack_message ( out_commission_pct ); sys . dbms_pipe . unpack_message ( out_manager_id ); sys . dbms_pipe . unpack_message ( out_department_id ); end if ; end rcv_emp ; end employee_up ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/2-packages/g-7210/","text":"G-7210: Try to keep your packages small. Include only few procedures and functions that are used in the same context. Major Efficiency, Maintainability Reason The entire package is loaded into memory when the package is called the first time. To optimize memory consumption and keep load time small packages should be kept small but include components that are used together.","title":"G-7210: Try to keep your packages small. Include only few procedures and functions that are used in the same context."},{"location":"4-language-usage/7-stored-objects/2-packages/g-7210/#g-7210-try-to-keep-your-packages-small-include-only-few-procedures-and-functions-that-are-used-in-the-same-context","text":"Major Efficiency, Maintainability","title":"G-7210: Try to keep your packages small. Include only few procedures and functions that are used in the same context."},{"location":"4-language-usage/7-stored-objects/2-packages/g-7210/#reason","text":"The entire package is loaded into memory when the package is called the first time. To optimize memory consumption and keep load time small packages should be kept small but include components that are used together.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/2-packages/g-7220/","text":"G-7220: Always use forward declaration for private functions and procedures. Minor Changeability Reason Having forward declarations allows you to order the functions and procedures of the package in a reasonable way. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 create or replace package department_api is procedure del ( in_department_id in departments . department_id % type ); end department_api ; / create or replace package body department_api is function does_exist ( in_department_id in departments . department_id % type ) -- violates also G-7460 return boolean is co_department_id constant departments . department_id % type : = in_department_id ; l_return pls_integer ; begin << check_row_exists >> begin select 1 into l_return from departments where department_id = co_department_id ; exception when no_data_found or too_many_rows then l_return : = 0 ; end check_row_exists ; return l_return = 1 ; end does_exist ; procedure del ( in_department_id in departments . department_id % type ) is co_department_id constant departments . department_id % type : = in_department_id ; begin if does_exist ( co_department_id ) then null ; end if ; end del ; end department_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 create or replace package department_api is procedure del ( in_department_id in departments . department_id % type ); end department_api ; / create or replace package body department_api is function does_exist ( in_department_id in departments . department_id % type ) -- NOSONAR: non-deterministic return boolean ; procedure del ( in_department_id in departments . department_id % type ) is co_department_id constant departments . department_id % type : = in_department_id ; begin if does_exist ( co_department_id ) then null ; end if ; end del ; function does_exist ( in_department_id in departments . department_id % type ) -- NOSONAR: non-deterministic return boolean is co_department_id constant departments . department_id % type : = in_department_id ; l_return pls_integer ; begin << check_row_exists >> begin select 1 into l_return from departments where department_id = co_department_id ; exception when no_data_found or too_many_rows then l_return : = 0 ; end check_row_exists ; return l_return = 1 ; end does_exist ; end department_api ; /","title":"G-7220: Always use forward declaration for private functions and procedures."},{"location":"4-language-usage/7-stored-objects/2-packages/g-7220/#g-7220-always-use-forward-declaration-for-private-functions-and-procedures","text":"Minor Changeability","title":"G-7220: Always use forward declaration for private functions and procedures."},{"location":"4-language-usage/7-stored-objects/2-packages/g-7220/#reason","text":"Having forward declarations allows you to order the functions and procedures of the package in a reasonable way.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/2-packages/g-7220/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 create or replace package department_api is procedure del ( in_department_id in departments . department_id % type ); end department_api ; / create or replace package body department_api is function does_exist ( in_department_id in departments . department_id % type ) -- violates also G-7460 return boolean is co_department_id constant departments . department_id % type : = in_department_id ; l_return pls_integer ; begin << check_row_exists >> begin select 1 into l_return from departments where department_id = co_department_id ; exception when no_data_found or too_many_rows then l_return : = 0 ; end check_row_exists ; return l_return = 1 ; end does_exist ; procedure del ( in_department_id in departments . department_id % type ) is co_department_id constant departments . department_id % type : = in_department_id ; begin if does_exist ( co_department_id ) then null ; end if ; end del ; end department_api ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/2-packages/g-7220/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 create or replace package department_api is procedure del ( in_department_id in departments . department_id % type ); end department_api ; / create or replace package body department_api is function does_exist ( in_department_id in departments . department_id % type ) -- NOSONAR: non-deterministic return boolean ; procedure del ( in_department_id in departments . department_id % type ) is co_department_id constant departments . department_id % type : = in_department_id ; begin if does_exist ( co_department_id ) then null ; end if ; end del ; function does_exist ( in_department_id in departments . department_id % type ) -- NOSONAR: non-deterministic return boolean is co_department_id constant departments . department_id % type : = in_department_id ; l_return pls_integer ; begin << check_row_exists >> begin select 1 into l_return from departments where department_id = co_department_id ; exception when no_data_found or too_many_rows then l_return : = 0 ; end check_row_exists ; return l_return = 1 ; end does_exist ; end department_api ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/2-packages/g-7230/","text":"G-7230: Avoid declaring global variables public. Major Reliability Reason You should always declare package-level data (non-constants) inside the package body. You can then define \"get and set\" methods (functions and procedures, respectively) in the package specification to provide controlled access to that data. By doing so you can guarantee data integrity, you can change your data structure implementation, and also track access to those data structures. Data structures (scalar variables, collections, cursors) declared in the package specification (not within any specific program) can be referenced directly by any program running in a session with execute rights to the package. Instead, declare all package-level data in the package body and provide \"get and set\" methods - a function to get the value and a procedure to set the value - in the package specification. Developers then can access the data using these methods - and will automatically follow all rules you set upon data modification. For package-level constants, consider whether the constant should be public and usable from other code, or if only relevant for code within the package. If the latter, declare the constant in the package body. If the former, it is typically good practice to place the constants in a package specification that only holds constants. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 create or replace package employee_api as co_min_increase constant types_up . sal_increase_type : = 0 . 01 ; co_max_increase constant types_up . sal_increase_type : = 0 . 5 ; g_salary_increase types_up . sal_increase_type : = co_min_increase ; procedure set_salary_increase ( in_increase in types_up . sal_increase_type ); function salary_increase return types_up . sal_increase_type ; -- NOSONAR: non-deterministic end employee_api ; / create or replace package body employee_api as procedure set_salary_increase ( in_increase in types_up . sal_increase_type ) is co_increase constant types_up . sal_increase_type : = in_increase ; begin g_salary_increase : = greatest ( least ( co_increase , co_max_increase ) , co_min_increase ); end set_salary_increase ; function salary_increase return types_up . sal_increase_type is -- NOSONAR: non-deterministic begin return g_salary_increase ; end salary_increase ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 create or replace package constants_up as co_min_increase constant types_up . sal_increase_type : = 0 . 01 ; co_max_increase constant types_up . sal_increase_type : = 0 . 5 ; end constants_up ; / create or replace package employee_api as procedure set_salary_increase ( in_increase in types_up . sal_increase_type ); function salary_increase return types_up . sal_increase_type ; -- NOSONAR: non-deterministic end employee_api ; / create or replace package body employee_api as g_salary_increase types_up . sal_increase_type ; procedure init ; procedure set_salary_increase ( in_increase in types_up . sal_increase_type ) is co_increase constant types_up . sal_increase_type : = in_increase ; begin g_salary_increase : = greatest ( least ( co_increase , constants_up . co_max_increase ) , constants_up . co_min_increase ); end set_salary_increase ; function salary_increase return types_up . sal_increase_type is -- NOSONAR: non-deterministic begin return g_salary_increase ; end salary_increase ; procedure init is begin g_salary_increase : = constants_up . co_min_increase ; end init ; begin init (); end employee_api ; /","title":"G-7230: Avoid declaring global variables public."},{"location":"4-language-usage/7-stored-objects/2-packages/g-7230/#g-7230-avoid-declaring-global-variables-public","text":"Major Reliability","title":"G-7230: Avoid declaring global variables public."},{"location":"4-language-usage/7-stored-objects/2-packages/g-7230/#reason","text":"You should always declare package-level data (non-constants) inside the package body. You can then define \"get and set\" methods (functions and procedures, respectively) in the package specification to provide controlled access to that data. By doing so you can guarantee data integrity, you can change your data structure implementation, and also track access to those data structures. Data structures (scalar variables, collections, cursors) declared in the package specification (not within any specific program) can be referenced directly by any program running in a session with execute rights to the package. Instead, declare all package-level data in the package body and provide \"get and set\" methods - a function to get the value and a procedure to set the value - in the package specification. Developers then can access the data using these methods - and will automatically follow all rules you set upon data modification. For package-level constants, consider whether the constant should be public and usable from other code, or if only relevant for code within the package. If the latter, declare the constant in the package body. If the former, it is typically good practice to place the constants in a package specification that only holds constants.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/2-packages/g-7230/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 create or replace package employee_api as co_min_increase constant types_up . sal_increase_type : = 0 . 01 ; co_max_increase constant types_up . sal_increase_type : = 0 . 5 ; g_salary_increase types_up . sal_increase_type : = co_min_increase ; procedure set_salary_increase ( in_increase in types_up . sal_increase_type ); function salary_increase return types_up . sal_increase_type ; -- NOSONAR: non-deterministic end employee_api ; / create or replace package body employee_api as procedure set_salary_increase ( in_increase in types_up . sal_increase_type ) is co_increase constant types_up . sal_increase_type : = in_increase ; begin g_salary_increase : = greatest ( least ( co_increase , co_max_increase ) , co_min_increase ); end set_salary_increase ; function salary_increase return types_up . sal_increase_type is -- NOSONAR: non-deterministic begin return g_salary_increase ; end salary_increase ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/2-packages/g-7230/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 create or replace package constants_up as co_min_increase constant types_up . sal_increase_type : = 0 . 01 ; co_max_increase constant types_up . sal_increase_type : = 0 . 5 ; end constants_up ; / create or replace package employee_api as procedure set_salary_increase ( in_increase in types_up . sal_increase_type ); function salary_increase return types_up . sal_increase_type ; -- NOSONAR: non-deterministic end employee_api ; / create or replace package body employee_api as g_salary_increase types_up . sal_increase_type ; procedure init ; procedure set_salary_increase ( in_increase in types_up . sal_increase_type ) is co_increase constant types_up . sal_increase_type : = in_increase ; begin g_salary_increase : = greatest ( least ( co_increase , constants_up . co_max_increase ) , constants_up . co_min_increase ); end set_salary_increase ; function salary_increase return types_up . sal_increase_type is -- NOSONAR: non-deterministic begin return g_salary_increase ; end salary_increase ; procedure init is begin g_salary_increase : = constants_up . co_min_increase ; end init ; begin init (); end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/2-packages/g-7250/","text":"G-7250: Never use RETURN in package initialization block. Major Maintainability Reason The purpose of the initialization block of a package body is to set initial values of the global variables of the package (initialize the package state). Although return is syntactically allowed in this block, it makes no sense. If it is the last keyword of the block, it is superfluous. If it is not the last keyword, then all code after the return is unreachable and thus dead code. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create or replace package body employee_api as g_salary_increase types_up . sal_increase_type ; procedure set_salary_increase ( in_increase in types_up . sal_increase_type ) is co_increase constant types_up . sal_increase_type : = in_increase ; begin g_salary_increase : = greatest ( least ( co_increase , constants_up . max_salary_increase ()) , constants_up . min_salary_increase ()); end set_salary_increase ; function salary_increase return types_up . sal_increase_type is -- NOSONAR: non-deterministic begin return g_salary_increase ; end salary_increase ; begin g_salary_increase : = constants_up . min_salary_increase (); return ; -- violates also G-1040 set_salary_increase ( constants_up . min_salary_increase ()); -- dead code end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create or replace package body employee_api as g_salary_increase types_up . sal_increase_type ; procedure set_salary_increase ( in_increase in types_up . sal_increase_type ) is co_increase constant types_up . sal_increase_type : = in_increase ; begin g_salary_increase : = greatest ( least ( co_increase , constants_up . max_salary_increase ()) , constants_up . min_salary_increase ()); end set_salary_increase ; function salary_increase return types_up . sal_increase_type is -- NOSONAR: non-deterministic begin return g_salary_increase ; end salary_increase ; begin g_salary_increase : = constants_up . min_salary_increase (); end employee_api ; /","title":"G-7250: Never use RETURN in package initialization block."},{"location":"4-language-usage/7-stored-objects/2-packages/g-7250/#g-7250-never-use-return-in-package-initialization-block","text":"Major Maintainability","title":"G-7250: Never use RETURN in package initialization block."},{"location":"4-language-usage/7-stored-objects/2-packages/g-7250/#reason","text":"The purpose of the initialization block of a package body is to set initial values of the global variables of the package (initialize the package state). Although return is syntactically allowed in this block, it makes no sense. If it is the last keyword of the block, it is superfluous. If it is not the last keyword, then all code after the return is unreachable and thus dead code.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/2-packages/g-7250/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create or replace package body employee_api as g_salary_increase types_up . sal_increase_type ; procedure set_salary_increase ( in_increase in types_up . sal_increase_type ) is co_increase constant types_up . sal_increase_type : = in_increase ; begin g_salary_increase : = greatest ( least ( co_increase , constants_up . max_salary_increase ()) , constants_up . min_salary_increase ()); end set_salary_increase ; function salary_increase return types_up . sal_increase_type is -- NOSONAR: non-deterministic begin return g_salary_increase ; end salary_increase ; begin g_salary_increase : = constants_up . min_salary_increase (); return ; -- violates also G-1040 set_salary_increase ( constants_up . min_salary_increase ()); -- dead code end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/2-packages/g-7250/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create or replace package body employee_api as g_salary_increase types_up . sal_increase_type ; procedure set_salary_increase ( in_increase in types_up . sal_increase_type ) is co_increase constant types_up . sal_increase_type : = in_increase ; begin g_salary_increase : = greatest ( least ( co_increase , constants_up . max_salary_increase ()) , constants_up . min_salary_increase ()); end set_salary_increase ; function salary_increase return types_up . sal_increase_type is -- NOSONAR: non-deterministic begin return g_salary_increase ; end salary_increase ; begin g_salary_increase : = constants_up . min_salary_increase (); end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7310/","text":"G-7310: Avoid standalone procedures \u2013 put your procedures in packages. Minor Maintainability Reason Use packages to structure your code, combine procedures and functions which belong together. Package bodies may be changed and compiled without invalidating other packages. This is a major advantage compared to standalone procedures and functions. Example (bad) 1 2 3 4 5 create or replace procedure my_procedure is begin null ; end my_procedure ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 create or replace package my_package is procedure my_procedure ; end my_package ; / create or replace package body my_package is procedure my_procedure is begin null ; end my_procedure ; end my_package ; /","title":"G-7310: Avoid standalone procedures \u2013 put your procedures in packages."},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7310/#g-7310-avoid-standalone-procedures-put-your-procedures-in-packages","text":"Minor Maintainability","title":"G-7310: Avoid standalone procedures \u2013 put your procedures in packages."},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7310/#reason","text":"Use packages to structure your code, combine procedures and functions which belong together. Package bodies may be changed and compiled without invalidating other packages. This is a major advantage compared to standalone procedures and functions.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7310/#example-bad","text":"1 2 3 4 5 create or replace procedure my_procedure is begin null ; end my_procedure ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7310/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 create or replace package my_package is procedure my_procedure ; end my_package ; / create or replace package body my_package is procedure my_procedure is begin null ; end my_procedure ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7320/","text":"G-7320: Avoid using RETURN statements in a PROCEDURE. Major Maintainability, Testability Reason Use of the return statement is legal within a procedure in PL/SQL, but it is very similar to a goto , which means you end up with poorly structured code that is hard to debug and maintain. A good general rule to follow as you write your PL/SQL programs is \"one way in and one way out\". In other words, there should be just one way to enter or call a program, and there should be one way out, one exit path from a program (or loop) on successful termination. By following this rule, you end up with code that is much easier to trace, debug, and maintain. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create or replace package body my_package is procedure my_procedure is l_idx simple_integer : = 1 ; co_modulo constant simple_integer : = 7 ; begin << mod7_loop >> loop if mod ( l_idx , co_modulo ) = 0 then return ; end if ; l_idx : = l_idx + 1 ; end loop mod7_loop ; end my_procedure ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body my_package is procedure my_procedure is l_idx simple_integer : = 1 ; co_modulo constant simple_integer : = 7 ; begin << mod7_loop >> loop exit mod7_loop when mod ( l_idx , co_modulo ) = 0 ; l_idx : = l_idx + 1 ; end loop mod7_loop ; end my_procedure ; end my_package ; /","title":"G-7320: Avoid using RETURN statements in a PROCEDURE."},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7320/#g-7320-avoid-using-return-statements-in-a-procedure","text":"Major Maintainability, Testability","title":"G-7320: Avoid using RETURN statements in a PROCEDURE."},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7320/#reason","text":"Use of the return statement is legal within a procedure in PL/SQL, but it is very similar to a goto , which means you end up with poorly structured code that is hard to debug and maintain. A good general rule to follow as you write your PL/SQL programs is \"one way in and one way out\". In other words, there should be just one way to enter or call a program, and there should be one way out, one exit path from a program (or loop) on successful termination. By following this rule, you end up with code that is much easier to trace, debug, and maintain.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7320/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create or replace package body my_package is procedure my_procedure is l_idx simple_integer : = 1 ; co_modulo constant simple_integer : = 7 ; begin << mod7_loop >> loop if mod ( l_idx , co_modulo ) = 0 then return ; end if ; l_idx : = l_idx + 1 ; end loop mod7_loop ; end my_procedure ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7320/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body my_package is procedure my_procedure is l_idx simple_integer : = 1 ; co_modulo constant simple_integer : = 7 ; begin << mod7_loop >> loop exit mod7_loop when mod ( l_idx , co_modulo ) = 0 ; l_idx : = l_idx + 1 ; end loop mod7_loop ; end my_procedure ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7330/","text":"G-7330: Always assign values to OUT parameters. Blocker Maintainability, Testability Reason Marking a parameter for output means that callers will expect its value to be updated with a result from the execution of the procedure. Failing to update the parameter before the procedure returns is surely an error. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 create or replace package body my_package is procedure greet ( in_name in varchar2 , out_greeting out varchar2 -- violates also G-7150 ) is l_message types_up . text ; co_name constant employees . first_name : = in_name ; co_hello constant types_up . text : = 'Hello, ' ; begin l_message : = co_hello || co_name ; -- NOSONAR: G-2135 end greet ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 create or replace package body my_package is procedure greet ( in_name in varchar2 , out_greeting out varchar2 ) is co_name constant employees . first_name : = in_name ; co_hello constant types_up . text : = 'Hello, ' ; begin out_greeting : = co_hello || co_name ; end greet ; end my_package ; /","title":"G-7330: Always assign values to OUT parameters."},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7330/#g-7330-always-assign-values-to-out-parameters","text":"Blocker Maintainability, Testability","title":"G-7330: Always assign values to OUT parameters."},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7330/#reason","text":"Marking a parameter for output means that callers will expect its value to be updated with a result from the execution of the procedure. Failing to update the parameter before the procedure returns is surely an error.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7330/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 create or replace package body my_package is procedure greet ( in_name in varchar2 , out_greeting out varchar2 -- violates also G-7150 ) is l_message types_up . text ; co_name constant employees . first_name : = in_name ; co_hello constant types_up . text : = 'Hello, ' ; begin l_message : = co_hello || co_name ; -- NOSONAR: G-2135 end greet ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/3-procedures/g-7330/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 create or replace package body my_package is procedure greet ( in_name in varchar2 , out_greeting out varchar2 ) is co_name constant employees . first_name : = in_name ; co_hello constant types_up . text : = 'Hello, ' ; begin out_greeting : = co_hello || co_name ; end greet ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7410/","text":"G-7410: Avoid standalone functions \u2013 put your functions in packages. Minor Maintainability Reason Use packages to structure your code, combine procedures and functions which belong together. Package bodies may be changed and compiled without invalidating other packages. This is a major advantage compared to standalone procedures and functions. Example (bad) 1 2 3 4 5 6 7 create or replace function my_function return varchar2 deterministic is begin return null ; end my_function ; / Example (good) 1 2 3 4 5 6 7 8 9 create or replace package body my_package is function my_function return varchar2 deterministic is begin return null ; end my_function ; end my_package ; /","title":"G-7410: Avoid standalone functions \u2013 put your functions in packages."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7410/#g-7410-avoid-standalone-functions-put-your-functions-in-packages","text":"Minor Maintainability","title":"G-7410: Avoid standalone functions \u2013 put your functions in packages."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7410/#reason","text":"Use packages to structure your code, combine procedures and functions which belong together. Package bodies may be changed and compiled without invalidating other packages. This is a major advantage compared to standalone procedures and functions.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7410/#example-bad","text":"1 2 3 4 5 6 7 create or replace function my_function return varchar2 deterministic is begin return null ; end my_function ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7410/#example-good","text":"1 2 3 4 5 6 7 8 9 create or replace package body my_package is function my_function return varchar2 deterministic is begin return null ; end my_function ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7420/","text":"G-7420: Always make the RETURN statement the last statement of your function. Major Maintainability Reason The reader expects the return statement to be the last statement of a function. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 create or replace package body my_package is function my_function ( in_from in pls_integer , in_to in pls_integer ) return pls_integer deterministic is l_ret pls_integer ; begin l_ret : = in_from ; << for_loop >> for i in in_from .. in_to loop l_ret : = l_ret + i ; if i = in_to then return l_ret ; end if ; end loop for_loop ; end my_function ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create or replace package body my_package is function my_function ( in_from in pls_integer , in_to in pls_integer ) return pls_integer deterministic is l_ret pls_integer ; begin l_ret : = in_from ; << for_loop >> for i in in_from .. in_to loop l_ret : = l_ret + i ; end loop for_loop ; return l_ret ; end my_function ; end my_package ; /","title":"G-7420: Always make the RETURN statement the last statement of your function."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7420/#g-7420-always-make-the-return-statement-the-last-statement-of-your-function","text":"Major Maintainability","title":"G-7420: Always make the RETURN statement the last statement of your function."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7420/#reason","text":"The reader expects the return statement to be the last statement of a function.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7420/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 create or replace package body my_package is function my_function ( in_from in pls_integer , in_to in pls_integer ) return pls_integer deterministic is l_ret pls_integer ; begin l_ret : = in_from ; << for_loop >> for i in in_from .. in_to loop l_ret : = l_ret + i ; if i = in_to then return l_ret ; end if ; end loop for_loop ; end my_function ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7420/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create or replace package body my_package is function my_function ( in_from in pls_integer , in_to in pls_integer ) return pls_integer deterministic is l_ret pls_integer ; begin l_ret : = in_from ; << for_loop >> for i in in_from .. in_to loop l_ret : = l_ret + i ; end loop for_loop ; return l_ret ; end my_function ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7430/","text":"G-7430: Try to use no more than one RETURN statement within a function. Major Maintainability, Testability Reason A function should have a single point of entry as well as a single exit-point. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body my_package is function my_function ( in_value in pls_integer ) return boolean deterministic is co_yes constant pls_integer : = 1 ; begin if in_value = co_yes then return true ; else return false ; end if ; end my_function ; end my_package ; / Example (better) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body my_package is function my_function ( in_value in pls_integer ) return boolean deterministic is co_yes constant pls_integer : = 1 ; l_ret boolean ; begin if in_value = co_yes then l_ret : = true ; else l_ret : = false ; end if ; return l_ret ; end my_function ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 create or replace package body my_package is function my_function ( in_value in pls_integer ) return boolean deterministic is co_yes constant pls_integer : = 1 ; begin return in_value = co_yes ; end my_function ; end my_package ; /","title":"G-7430: Try to use no more than one RETURN statement within a function."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7430/#g-7430-try-to-use-no-more-than-one-return-statement-within-a-function","text":"Major Maintainability, Testability","title":"G-7430: Try to use no more than one RETURN statement within a function."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7430/#reason","text":"A function should have a single point of entry as well as a single exit-point.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7430/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body my_package is function my_function ( in_value in pls_integer ) return boolean deterministic is co_yes constant pls_integer : = 1 ; begin if in_value = co_yes then return true ; else return false ; end if ; end my_function ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7430/#example-better","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body my_package is function my_function ( in_value in pls_integer ) return boolean deterministic is co_yes constant pls_integer : = 1 ; l_ret boolean ; begin if in_value = co_yes then l_ret : = true ; else l_ret : = false ; end if ; return l_ret ; end my_function ; end my_package ; /","title":"Example (better)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7430/#example-good","text":"1 2 3 4 5 6 7 8 9 10 create or replace package body my_package is function my_function ( in_value in pls_integer ) return boolean deterministic is co_yes constant pls_integer : = 1 ; begin return in_value = co_yes ; end my_function ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7440/","text":"G-7440: Never use OUT parameters to return values from a function. Major Reusability Reason A function should return all its data through the return clause. Having an out parameter prohibits usage of a function within SQL statements. Example (bad) 1 2 3 4 5 6 7 8 9 10 create or replace package body my_package is function my_function ( out_date out date ) return boolean deterministic is begin out_date : = sysdate ; return true ; end my_function ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 create or replace package body my_package is function my_function return date deterministic is begin return sysdate ; end my_function ; end my_package ; /","title":"G-7440: Never use OUT parameters to return values from a function."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7440/#g-7440-never-use-out-parameters-to-return-values-from-a-function","text":"Major Reusability","title":"G-7440: Never use OUT parameters to return values from a function."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7440/#reason","text":"A function should return all its data through the return clause. Having an out parameter prohibits usage of a function within SQL statements.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7440/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 create or replace package body my_package is function my_function ( out_date out date ) return boolean deterministic is begin out_date : = sysdate ; return true ; end my_function ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7440/#example-good","text":"1 2 3 4 5 6 7 8 9 create or replace package body my_package is function my_function return date deterministic is begin return sysdate ; end my_function ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7450/","text":"G-7450: Never return a NULL value from a BOOLEAN function. Blocker Reliability, Testability Reason If a boolean function returns null , the caller has do deal with it. This makes the usage cumbersome and more error-prone. Example (bad) 1 2 3 4 5 6 7 8 9 create or replace package body my_package is function my_function return boolean deterministic is begin return null ; end my_function ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 create or replace package body my_package is function my_function return boolean deterministic is begin return true ; end my_function ; end my_package ; /","title":"G-7450: Never return a NULL value from a BOOLEAN function."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7450/#g-7450-never-return-a-null-value-from-a-boolean-function","text":"Blocker Reliability, Testability","title":"G-7450: Never return a NULL value from a BOOLEAN function."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7450/#reason","text":"If a boolean function returns null , the caller has do deal with it. This makes the usage cumbersome and more error-prone.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7450/#example-bad","text":"1 2 3 4 5 6 7 8 9 create or replace package body my_package is function my_function return boolean deterministic is begin return null ; end my_function ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7450/#example-good","text":"1 2 3 4 5 6 7 8 9 create or replace package body my_package is function my_function return boolean deterministic is begin return true ; end my_function ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7460/","text":"G-7460: Try to define your packaged/standalone function deterministic if appropriate. Major Efficiency Reason A deterministic function (always return same result for identical parameters) which is defined to be deterministic will be executed once per different parameter within a SQL statement whereas if the function is not defined to be deterministic it is executed once per result row. Example (bad) 1 2 3 4 5 create or replace package department_api is function name_by_id ( in_department_id in departments . department_id % type ) return departments . department_name % type ; end department_api ; / Example (good) 1 2 3 4 5 6 create or replace package department_api is function name_by_id ( in_department_id in departments . department_id % type ) return departments . department_name % type deterministic ; end department_api ; /","title":"G-7460: Try to define your packaged/standalone function deterministic if appropriate."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7460/#g-7460-try-to-define-your-packagedstandalone-function-deterministic-if-appropriate","text":"Major Efficiency","title":"G-7460: Try to define your packaged/standalone function deterministic if appropriate."},{"location":"4-language-usage/7-stored-objects/4-functions/g-7460/#reason","text":"A deterministic function (always return same result for identical parameters) which is defined to be deterministic will be executed once per different parameter within a SQL statement whereas if the function is not defined to be deterministic it is executed once per result row.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7460/#example-bad","text":"1 2 3 4 5 create or replace package department_api is function name_by_id ( in_department_id in departments . department_id % type ) return departments . department_name % type ; end department_api ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/4-functions/g-7460/#example-good","text":"1 2 3 4 5 6 create or replace package department_api is function name_by_id ( in_department_id in departments . department_id % type ) return departments . department_name % type deterministic ; end department_api ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/","text":"G-7510: Always prefix Oracle supplied packages with owner schema name. Major Security Reason The signature of Oracle supplied packages is well known and therefore it is quite easy to provide packages with the same name as those from Oracle doing something completely different without you noticing it. Example (bad) 1 2 3 4 5 6 declare co_hello_world constant string ( 30 char ) : = 'Hello World' ; begin dbms_output . put_line ( co_hello_world ); end ; / Example (good) 1 2 3 4 5 6 declare co_hello_world constant string ( 30 char ) : = 'Hello World' ; begin sys . dbms_output . put_line ( co_hello_world ); end ; /","title":"G-7510: Always prefix Oracle supplied packages with owner schema name."},{"location":"4-language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#g-7510-always-prefix-oracle-supplied-packages-with-owner-schema-name","text":"Major Security","title":"G-7510: Always prefix Oracle supplied packages with owner schema name."},{"location":"4-language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#reason","text":"The signature of Oracle supplied packages is well known and therefore it is quite easy to provide packages with the same name as those from Oracle doing something completely different without you noticing it.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#example-bad","text":"1 2 3 4 5 6 declare co_hello_world constant string ( 30 char ) : = 'Hello World' ; begin dbms_output . put_line ( co_hello_world ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#example-good","text":"1 2 3 4 5 6 declare co_hello_world constant string ( 30 char ) : = 'Hello World' ; begin sys . dbms_output . put_line ( co_hello_world ); end ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/6-object-types/object-types/","text":"Object Types There are no object type-specific recommendations to be defined at the time of writing.","title":"Object Types"},{"location":"4-language-usage/7-stored-objects/6-object-types/object-types/#object-types","text":"There are no object type-specific recommendations to be defined at the time of writing.","title":"Object Types"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7710/","text":"G-7710: Avoid cascading triggers. Major Maintainability, Testability Reason Having triggers that act on other tables in a way that causes triggers on that table to fire lead to obscure behavior. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 create or replace trigger dept_br_u before update on departments for each row begin insert into departments_hist ( department_id , department_name , manager_id , location_id , modification_date ) values ( : old . department_id ,: old . department_name ,: old . manager_id ,: old . location_id , sysdate ); end ; / create or replace trigger dept_hist_br_i before insert on departments_hist for each row begin insert into departments_log ( department_id , department_name , modification_date ) values ( : new . department_id ,: new . department_name , sysdate ); end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 create or replace trigger dept_br_u before update on departments for each row begin insert into departments_hist ( department_id , department_name , manager_id , location_id , modification_date ) values ( : old . department_id ,: old . department_name ,: old . manager_id ,: old . location_id , sysdate ); insert into departments_log ( department_id , department_name , modification_date ) values ( : old . department_id ,: old . department_name , sysdate ); end ; /","title":"G-7710: Avoid cascading triggers."},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7710/#g-7710-avoid-cascading-triggers","text":"Major Maintainability, Testability","title":"G-7710: Avoid cascading triggers."},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7710/#reason","text":"Having triggers that act on other tables in a way that causes triggers on that table to fire lead to obscure behavior.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7710/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 create or replace trigger dept_br_u before update on departments for each row begin insert into departments_hist ( department_id , department_name , manager_id , location_id , modification_date ) values ( : old . department_id ,: old . department_name ,: old . manager_id ,: old . location_id , sysdate ); end ; / create or replace trigger dept_hist_br_i before insert on departments_hist for each row begin insert into departments_log ( department_id , department_name , modification_date ) values ( : new . department_id ,: new . department_name , sysdate ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7710/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 create or replace trigger dept_br_u before update on departments for each row begin insert into departments_hist ( department_id , department_name , manager_id , location_id , modification_date ) values ( : old . department_id ,: old . department_name ,: old . manager_id ,: old . location_id , sysdate ); insert into departments_log ( department_id , department_name , modification_date ) values ( : old . department_id ,: old . department_name , sysdate ); end ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7720/","text":"G-7720: Never use multiple UPDATE OF in trigger event clause. Blocker Maintainability, Reliability, Testability Reason A DML trigger can have multiple triggering events separated by or like before insert or delete or update of some_column . If you have multiple update of separated by or , only one of them (the last one) is actually used and you get no error message, so you have a bug waiting to happen. Instead you always should use a single update of with all columns comma-separated, or an update without of if you wish all columns. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 create or replace trigger dept_br_u before update of department_id or update of department_name -- violates also G-7730 on departments for each row begin -- will only fire on updates of department_name insert into departments_log ( department_id , department_name , modification_date ) values ( : old . department_id ,: old . department_name , sysdate ); end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace trigger dept_br_u before update of department_id , department_name on departments for each row begin insert into departments_log ( department_id , department_name , modification_date ) values ( : old . department_id ,: old . department_name , sysdate ); end ; /","title":"G-7720: Never use multiple UPDATE OF in trigger event clause."},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7720/#g-7720-never-use-multiple-update-of-in-trigger-event-clause","text":"Blocker Maintainability, Reliability, Testability","title":"G-7720: Never use multiple UPDATE OF in trigger event clause."},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7720/#reason","text":"A DML trigger can have multiple triggering events separated by or like before insert or delete or update of some_column . If you have multiple update of separated by or , only one of them (the last one) is actually used and you get no error message, so you have a bug waiting to happen. Instead you always should use a single update of with all columns comma-separated, or an update without of if you wish all columns.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7720/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 create or replace trigger dept_br_u before update of department_id or update of department_name -- violates also G-7730 on departments for each row begin -- will only fire on updates of department_name insert into departments_log ( department_id , department_name , modification_date ) values ( : old . department_id ,: old . department_name , sysdate ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7720/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace trigger dept_br_u before update of department_id , department_name on departments for each row begin insert into departments_log ( department_id , department_name , modification_date ) values ( : old . department_id ,: old . department_name , sysdate ); end ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7730/","text":"G-7730: Avoid multiple DML events per trigger. Minor Maintainability, Testability Reason Rather than a single trigger handling multiple DML events with separated blocks of if inserting , if updating and if deleting , modularity by individual triggers per DML event helps maintaining and testing the code. If most of the code is common for either DML event (only small pieces of code are individual) consider an exception to the rule and allow if inserting , if updating and if deleting blocks, or alternatively gather the common code in a procedure and let individual triggers handle the individual pieces of code plus call the procedure with the common code. If the trigger makes assignment to a primary key and there are child tables with a foreign key referring to this primary key, the database can make undesirable table locks. If such is the case, you should always use individual triggers. See G-7740 for details. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 create or replace trigger dept_br_iu before insert or update on departments for each row begin if inserting then : new . created_date : = sysdate ; end if ; if updating then : new . changed_date : = sysdate ; end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 create or replace trigger dept_br_i before insert on departments for each row begin : new . created_date : = sysdate ; end ; / create or replace trigger dept_br_u before update on departments for each row begin : new . changed_date : = sysdate ; end ; /","title":"G-7730: Avoid multiple DML events per trigger."},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7730/#g-7730-avoid-multiple-dml-events-per-trigger","text":"Minor Maintainability, Testability","title":"G-7730: Avoid multiple DML events per trigger."},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7730/#reason","text":"Rather than a single trigger handling multiple DML events with separated blocks of if inserting , if updating and if deleting , modularity by individual triggers per DML event helps maintaining and testing the code. If most of the code is common for either DML event (only small pieces of code are individual) consider an exception to the rule and allow if inserting , if updating and if deleting blocks, or alternatively gather the common code in a procedure and let individual triggers handle the individual pieces of code plus call the procedure with the common code. If the trigger makes assignment to a primary key and there are child tables with a foreign key referring to this primary key, the database can make undesirable table locks. If such is the case, you should always use individual triggers. See G-7740 for details.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7730/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 create or replace trigger dept_br_iu before insert or update on departments for each row begin if inserting then : new . created_date : = sysdate ; end if ; if updating then : new . changed_date : = sysdate ; end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7730/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 create or replace trigger dept_br_i before insert on departments for each row begin : new . created_date : = sysdate ; end ; / create or replace trigger dept_br_u before update on departments for each row begin : new . changed_date : = sysdate ; end ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7740/","text":"G-7740: Never handle multiple DML events per trigger if primary key is assigned in trigger. Critical Efficiency, Reliability Unsupported in db* CODECOP Validators We cannot identify what the primary key column(s) are to check if assignment to a primary key is taking place in the trigger. Reason If a trigger makes assignment to the primary key anywhere in the trigger code, that causes the session firing the trigger to take a lock on any child tables with a foreign key to this primary key. Even if the assignment is in for example an if inserting block and the trigger is fired by an update statement, such locks still happen unnecessarily. The issue is avoided by having one trigger for the insert containing the primary key assignment, and another trigger for the update. Or even better by handling the insert assignment as \u00b4default on null\u00b4 clauses, so that only an on update trigger is needed. This locking of child tables behaviour goes for simple DML triggers as well as compound DML triggers where assignments to primary keys take place. It is not relevant for instead-of triggers on views, as it is not possible to assign :new values and therefore no locks on child tables are needed. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 create or replace trigger dept_br_iu before insert or update -- NOSONAR: G-7730 on departments for each row begin if inserting then : new . department_id : = department_seq . nextval ; -- NOSONAR: G-3150 : new . created_date : = sysdate ; end if ; if updating then : new . changed_date : = sysdate ; end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create or replace trigger dept_br_i before insert on departments for each row begin : new . department_id : = department_seq . nextval ; -- NOSONAR: G-3150 : new . created_date : = sysdate ; end ; / create or replace trigger dept_br_u before update on departments for each row begin : new . changed_date : = sysdate ; end ; / Example (best) 1 2 3 4 5 6 7 8 9 10 alter table department modify department_id default on null department_seq . nextval ; alter table department modify created_date default on null sysdate ; create or replace trigger dept_br_u before update on departments for each row begin : new . changed_date : = sysdate ; end ; /","title":"G-7740: Never handle multiple DML events per trigger if primary key is assigned in trigger."},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7740/#g-7740-never-handle-multiple-dml-events-per-trigger-if-primary-key-is-assigned-in-trigger","text":"Critical Efficiency, Reliability Unsupported in db* CODECOP Validators We cannot identify what the primary key column(s) are to check if assignment to a primary key is taking place in the trigger.","title":"G-7740: Never handle multiple DML events per trigger if primary key is assigned in trigger."},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7740/#reason","text":"If a trigger makes assignment to the primary key anywhere in the trigger code, that causes the session firing the trigger to take a lock on any child tables with a foreign key to this primary key. Even if the assignment is in for example an if inserting block and the trigger is fired by an update statement, such locks still happen unnecessarily. The issue is avoided by having one trigger for the insert containing the primary key assignment, and another trigger for the update. Or even better by handling the insert assignment as \u00b4default on null\u00b4 clauses, so that only an on update trigger is needed. This locking of child tables behaviour goes for simple DML triggers as well as compound DML triggers where assignments to primary keys take place. It is not relevant for instead-of triggers on views, as it is not possible to assign :new values and therefore no locks on child tables are needed.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7740/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 create or replace trigger dept_br_iu before insert or update -- NOSONAR: G-7730 on departments for each row begin if inserting then : new . department_id : = department_seq . nextval ; -- NOSONAR: G-3150 : new . created_date : = sysdate ; end if ; if updating then : new . changed_date : = sysdate ; end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7740/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create or replace trigger dept_br_i before insert on departments for each row begin : new . department_id : = department_seq . nextval ; -- NOSONAR: G-3150 : new . created_date : = sysdate ; end ; / create or replace trigger dept_br_u before update on departments for each row begin : new . changed_date : = sysdate ; end ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/7-triggers/g-7740/#example-best","text":"1 2 3 4 5 6 7 8 9 10 alter table department modify department_id default on null department_seq . nextval ; alter table department modify created_date default on null sysdate ; create or replace trigger dept_br_u before update on departments for each row begin : new . changed_date : = sysdate ; end ; /","title":"Example (best)"},{"location":"4-language-usage/7-stored-objects/8-sequences/g-7810/","text":"G-7810: Never use SQL inside PL/SQL to read sequence numbers (or SYSDATE). Critical Efficiency, Maintainability Reason Since Oracle Database 11g it is no longer needed to use a select statement to read a sequence (which would imply a context switch). Example (bad) 1 2 3 4 5 6 7 8 9 declare l_sequence_number employees . employee_id % type ; begin select employees_seq . nextval into l_sequence_number from dual ; my_package . do_something ( l_sequence_number ); end ; / Example (good) 1 2 3 4 5 6 7 declare l_sequence_number employees . employee_id % type ; begin l_sequence_number : = employees_seq . nextval ; my_package . do_something ( l_sequence_number ); end ; /","title":"G-7810: Never use SQL inside PL/SQL to read sequence numbers (or SYSDATE)."},{"location":"4-language-usage/7-stored-objects/8-sequences/g-7810/#g-7810-never-use-sql-inside-plsql-to-read-sequence-numbers-or-sysdate","text":"Critical Efficiency, Maintainability","title":"G-7810: Never use SQL inside PL/SQL to read sequence numbers (or SYSDATE)."},{"location":"4-language-usage/7-stored-objects/8-sequences/g-7810/#reason","text":"Since Oracle Database 11g it is no longer needed to use a select statement to read a sequence (which would imply a context switch).","title":"Reason"},{"location":"4-language-usage/7-stored-objects/8-sequences/g-7810/#example-bad","text":"1 2 3 4 5 6 7 8 9 declare l_sequence_number employees . employee_id % type ; begin select employees_seq . nextval into l_sequence_number from dual ; my_package . do_something ( l_sequence_number ); end ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/8-sequences/g-7810/#example-good","text":"1 2 3 4 5 6 7 declare l_sequence_number employees . employee_id % type ; begin l_sequence_number : = employees_seq . nextval ; my_package . do_something ( l_sequence_number ); end ; /","title":"Example (good)"},{"location":"4-language-usage/7-stored-objects/9-sql-macros/g-7910/","text":"G-7910: Never use DML within a SQL macro. Blocker Reliability, Testability Restriction Oracle Database 21c (19c from version 19.7 for table macros alone) Reason Doing DML (except for select ) within a SQL macro can lead to disastrous side effects from calling the macro in a SQL query. Logging macro calls via a call to a procedure that does DML in an autonomous transaction can be an exception to the rule. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body my_package is function row_generator ( in_num_rows in number ) -- NOSONAR: non-deterministic return varchar2 sql_macro as begin insert into function_calls ( name , called_at , parameter_value ) values ( $$ plsql_unit , current_timestamp , in_num_rows ); commit ; return 'select level as row_sequence -- NOSONAR: G-1050 from dual connect by level <= in_num_rows' ; end row_generator ; end my_package ; / Example (good) 1 2 3 4 5 6 7 8 9 10 create or replace package body my_package is function row_generator ( in_num_rows in number ) -- NOSONAR: non-deterministic return varchar2 sql_macro as begin return 'select level as row_sequence -- NOSONAR: G-1050 from dual connect by level <= in_num_rows' ; end row_generator ; end my_package ; /","title":"G-7910: Never use DML within a SQL macro."},{"location":"4-language-usage/7-stored-objects/9-sql-macros/g-7910/#g-7910-never-use-dml-within-a-sql-macro","text":"Blocker Reliability, Testability","title":"G-7910: Never use DML within a SQL macro."},{"location":"4-language-usage/7-stored-objects/9-sql-macros/g-7910/#restriction","text":"Oracle Database 21c (19c from version 19.7 for table macros alone)","title":"Restriction"},{"location":"4-language-usage/7-stored-objects/9-sql-macros/g-7910/#reason","text":"Doing DML (except for select ) within a SQL macro can lead to disastrous side effects from calling the macro in a SQL query. Logging macro calls via a call to a procedure that does DML in an autonomous transaction can be an exception to the rule.","title":"Reason"},{"location":"4-language-usage/7-stored-objects/9-sql-macros/g-7910/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body my_package is function row_generator ( in_num_rows in number ) -- NOSONAR: non-deterministic return varchar2 sql_macro as begin insert into function_calls ( name , called_at , parameter_value ) values ( $$ plsql_unit , current_timestamp , in_num_rows ); commit ; return 'select level as row_sequence -- NOSONAR: G-1050 from dual connect by level <= in_num_rows' ; end row_generator ; end my_package ; /","title":"Example (bad)"},{"location":"4-language-usage/7-stored-objects/9-sql-macros/g-7910/#example-good","text":"1 2 3 4 5 6 7 8 9 10 create or replace package body my_package is function row_generator ( in_num_rows in number ) -- NOSONAR: non-deterministic return varchar2 sql_macro as begin return 'select level as row_sequence -- NOSONAR: G-1050 from dual connect by level <= in_num_rows' ; end row_generator ; end my_package ; /","title":"Example (good)"},{"location":"4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/","text":"G-8110: Never use SELECT COUNT(*) if you are only interested in the existence of a row. Critical Efficiency Reason If you do a select count(*) all rows will be read according to the where clause, even if only the availability of data is of interest. For this we have a big performance overhead. If we do a select count(*) ... where rownum = 1 there is also a overhead as there will be two communications between the PL/SQL and the SQL engine. See the following example for a better solution. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 declare l_count pls_integer ; co_zero constant simple_integer : = 0 ; co_salary constant employees . salary % type : = 5000 ; begin select count ( * ) into l_count from employees where salary < co_salary ; if l_count > co_zero then << emp_loop >> for r_emp in ( select employee_id from employees ) loop if r_emp . salary < co_salary then my_package . my_proc ( in_employee_id => r_emp . employee_id ); end if ; end loop emp_loop ; end if ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 declare co_salary constant employees . salary % type : = 5000 ; begin << emp_loop >> for r_emp in ( select e1 . employee_id from employees e1 where exists ( select e2 . salary from employees e2 where e2 . salary < co_salary ) ) loop my_package . my_proc ( in_employee_id => r_emp . employee_id ); end loop emp_loop ; end ; /","title":"G-8110: Never use SELECT COUNT(*) if you are only interested in the existence of a row."},{"location":"4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#g-8110-never-use-select-count-if-you-are-only-interested-in-the-existence-of-a-row","text":"Critical Efficiency","title":"G-8110: Never use SELECT COUNT(*) if you are only interested in the existence of a row."},{"location":"4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#reason","text":"If you do a select count(*) all rows will be read according to the where clause, even if only the availability of data is of interest. For this we have a big performance overhead. If we do a select count(*) ... where rownum = 1 there is also a overhead as there will be two communications between the PL/SQL and the SQL engine. See the following example for a better solution.","title":"Reason"},{"location":"4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 declare l_count pls_integer ; co_zero constant simple_integer : = 0 ; co_salary constant employees . salary % type : = 5000 ; begin select count ( * ) into l_count from employees where salary < co_salary ; if l_count > co_zero then << emp_loop >> for r_emp in ( select employee_id from employees ) loop if r_emp . salary < co_salary then my_package . my_proc ( in_employee_id => r_emp . employee_id ); end if ; end loop emp_loop ; end if ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 declare co_salary constant employees . salary % type : = 5000 ; begin << emp_loop >> for r_emp in ( select e1 . employee_id from employees e1 where exists ( select e2 . salary from employees e2 where e2 . salary < co_salary ) ) loop my_package . my_proc ( in_employee_id => r_emp . employee_id ); end loop emp_loop ; end ; /","title":"Example (good)"},{"location":"4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/","text":"G-8120: Never check existence of a row to decide whether to create it or not. Critical Efficiency, Reliability Reason The result of an existence check is a snapshot of the current situation. You never know whether in the time between the check and the (insert) action someone else has decided to create a row with the values you checked. Therefore, you should only rely on constraints when it comes to prevention of duplicate records. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create or replace package body department_api is procedure ins ( in_r_department in departments % rowtype ) is l_count pls_integer ; begin select count ( * ) -- NOSONAR: a violation of G-8110 is a prerequisite for G-8120 into l_count from departments where department_id = in_r_department . department_id ; if l_count = 0 then insert into departments values in_r_department ; end if ; end ins ; end department_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 create or replace package body department_api is procedure ins ( in_r_department in departments % rowtype ) is begin insert into departments values in_r_department ; exception when dup_val_on_index then null ; -- handle exception end ins ; end department_api ; /","title":"G-8120: Never check existence of a row to decide whether to create it or not."},{"location":"4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#g-8120-never-check-existence-of-a-row-to-decide-whether-to-create-it-or-not","text":"Critical Efficiency, Reliability","title":"G-8120: Never check existence of a row to decide whether to create it or not."},{"location":"4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#reason","text":"The result of an existence check is a snapshot of the current situation. You never know whether in the time between the check and the (insert) action someone else has decided to create a row with the values you checked. Therefore, you should only rely on constraints when it comes to prevention of duplicate records.","title":"Reason"},{"location":"4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create or replace package body department_api is procedure ins ( in_r_department in departments % rowtype ) is l_count pls_integer ; begin select count ( * ) -- NOSONAR: a violation of G-8110 is a prerequisite for G-8120 into l_count from departments where department_id = in_r_department . department_id ; if l_count = 0 then insert into departments values in_r_department ; end if ; end ins ; end department_api ; /","title":"Example (bad)"},{"location":"4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 create or replace package body department_api is procedure ins ( in_r_department in departments % rowtype ) is begin insert into departments values in_r_department ; exception when dup_val_on_index then null ; -- handle exception end ins ; end department_api ; /","title":"Example (good)"},{"location":"4-language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/","text":"G-8210: Always use synonyms when accessing objects of another application schema. Minor Changeability, Maintainability Reason If a connection is needed to a table that is placed in a foreign schema, using synonyms is a good choice. If there are structural changes to that table (e.g. the table name changes or the table changes into another schema) only the synonym has to be changed no changes to the package are needed (single point of change). If you only have read access for a table inside another schema, or there is another reason that does not allow you to change data in this table, you can switch the synonym to a table in your own schema. This is also good practice for testers working on test systems. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare l_product_name oe . products . product_name % type ; co_price constant oe . products @ list_price % type : = 1000 ; begin select p . product_name into l_product_name from oe . products p where list_price > co_price ; exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create synonym oe_products for oe . products ; declare l_product_name oe_products . product_name % type ; co_price constant oe_products . list_price % type : = 1000 ; begin select p . product_name into l_product_name from oe_products p where list_price > co_price ; exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end ; /","title":"G-8210: Always use synonyms when accessing objects of another application schema."},{"location":"4-language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#g-8210-always-use-synonyms-when-accessing-objects-of-another-application-schema","text":"Minor Changeability, Maintainability","title":"G-8210: Always use synonyms when accessing objects of another application schema."},{"location":"4-language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#reason","text":"If a connection is needed to a table that is placed in a foreign schema, using synonyms is a good choice. If there are structural changes to that table (e.g. the table name changes or the table changes into another schema) only the synonym has to be changed no changes to the package are needed (single point of change). If you only have read access for a table inside another schema, or there is another reason that does not allow you to change data in this table, you can switch the synonym to a table in your own schema. This is also good practice for testers working on test systems.","title":"Reason"},{"location":"4-language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 declare l_product_name oe . products . product_name % type ; co_price constant oe . products @ list_price % type : = 1000 ; begin select p . product_name into l_product_name from oe . products p where list_price > co_price ; exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end ; /","title":"Example (bad)"},{"location":"4-language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create synonym oe_products for oe . products ; declare l_product_name oe_products . product_name % type ; co_price constant oe_products . list_price % type : = 1000 ; begin select p . product_name into l_product_name from oe_products p where list_price > co_price ; exception when no_data_found then null ; -- handle_no_data_found; when too_many_rows then null ; -- handle_too_many_rows; end ; /","title":"Example (good)"},{"location":"4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/","text":"G-8310: Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit. Major Maintainability, Reliability, Reusability, Testability Reason This technique raises an error ( value_error ) which may not be handled in the called program unit. This is the right way to do it, as the error is not within this unit but when calling it, so the caller should handle the error. To limit the number of false positives, only the following data types used in parameters should be considered: char dec decimal interval day to second interval year to month nchar number numeric nvarchar2 varchar2 %type Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 create or replace package body department_api is function dept_by_name ( -- NOSONAR: non-deterministic in_dept_name in departments . department_name % type ) return departments % rowtype is r_return departments % rowtype ; co_max_dept_name_length constant integer : = 20 ; begin if in_dept_name is null or length ( in_dept_name ) > co_max_dept_name_length then raise err . e_param_to_large ; end if ; -- get the department by name << trap >> begin select * into r_return from departments where department_name = in_dept_name ; return r_return ; exception when no_data_found then return null ; when too_many_rows then raise ; end trap ; end dept_by_name ; end department_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 create or replace package body department_api is function dept_by_name ( -- NOSONAR: non-deterministic in_dept_name in departments . department_name % type ) return departments % rowtype is co_dept_name constant departments . department_name % type not null : = in_dept_name ; r_return departments % rowtype ; begin -- get the department by name << trap >> begin select * into r_return from departments where department_name = co_dept_name ; return r_return ; exception when no_data_found then return null ; when too_many_rows then raise ; end trap ; end dept_by_name ; end department_api ; / The exception should be handled where the function is called, like this: 1 2 3 4 5 6 7 8 9 10 11 declare co_dept_name constant type_up . text : = 'Far to long name of a department' ; begin pre_processing ; r_department : = department_api . dept_by_name ( co_dept_name ); post_processing ; exception when value_error then handle_error ; end ; /","title":"G-8310: Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit."},{"location":"4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#g-8310-always-validate-input-parameter-size-by-assigning-the-parameter-to-a-size-limited-variable-in-the-declaration-section-of-program-unit","text":"Major Maintainability, Reliability, Reusability, Testability","title":"G-8310: Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit."},{"location":"4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#reason","text":"This technique raises an error ( value_error ) which may not be handled in the called program unit. This is the right way to do it, as the error is not within this unit but when calling it, so the caller should handle the error. To limit the number of false positives, only the following data types used in parameters should be considered: char dec decimal interval day to second interval year to month nchar number numeric nvarchar2 varchar2 %type","title":"Reason"},{"location":"4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 create or replace package body department_api is function dept_by_name ( -- NOSONAR: non-deterministic in_dept_name in departments . department_name % type ) return departments % rowtype is r_return departments % rowtype ; co_max_dept_name_length constant integer : = 20 ; begin if in_dept_name is null or length ( in_dept_name ) > co_max_dept_name_length then raise err . e_param_to_large ; end if ; -- get the department by name << trap >> begin select * into r_return from departments where department_name = in_dept_name ; return r_return ; exception when no_data_found then return null ; when too_many_rows then raise ; end trap ; end dept_by_name ; end department_api ; /","title":"Example (bad)"},{"location":"4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 create or replace package body department_api is function dept_by_name ( -- NOSONAR: non-deterministic in_dept_name in departments . department_name % type ) return departments % rowtype is co_dept_name constant departments . department_name % type not null : = in_dept_name ; r_return departments % rowtype ; begin -- get the department by name << trap >> begin select * into r_return from departments where department_name = co_dept_name ; return r_return ; exception when no_data_found then return null ; when too_many_rows then raise ; end trap ; end dept_by_name ; end department_api ; / The exception should be handled where the function is called, like this: 1 2 3 4 5 6 7 8 9 10 11 declare co_dept_name constant type_up . text : = 'Far to long name of a department' ; begin pre_processing ; r_department : = department_api . dept_by_name ( co_dept_name ); post_processing ; exception when value_error then handle_error ; end ; /","title":"Example (good)"},{"location":"4-language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/","text":"G-8410: Always use application locks to ensure a program unit is only running once at a given time. Blocker Efficiency, Reliability Unsupported in db* CODECOP Validators We cannot identify where an application lock would make sense. Algorithms to detect wrong, missing and right usages of this pattern are virtually impossible to implement without understanding the context. Reason This technique allows us to have locks across transactions as well as a proven way to clean up at the end of the session. The alternative using a table where a \u201cLock-Row\u201d is stored has the disadvantage that in case of an error a proper cleanup has to be done to \u201cunlock\u201d the program unit. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Example */ create or replace package body lock_up is -- manage locks in a dedicated table created as follows: -- CREATE TABLE app_locks ( -- lock_name VARCHAR2(128 CHAR) NOT NULL primary key -- ); procedure request_lock ( in_lock_name in varchar2 ) is co_lock_name constant app_locks . lock_name % type : = in_lock_name ; begin -- raises dup_val_on_index insert into app_locks ( lock_name ) values ( co_lock_name ); end request_lock ; procedure release_lock ( in_lock_name in varchar2 ) is co_lock_name constant app_locks . lock_name % type : = in_lock_name ; begin delete from app_locks where lock_name = co_lock_name ; end release_lock ; end lock_up ; / /* Call bad example */ declare co_lock_name constant app_locks . lock_name % type : = 'APPLICATION_LOCK' ; begin lock_up . request_lock ( in_lock_name => co_lock_name ); -- processing lock_up . release_lock ( in_lock_name => co_lock_name ); exception when dup_val_on_index then -- expected exception lock_up . release_lock ( in_lock_name => co_lock_name ); raise ; when others then -- unexpected exception, logging is recommended lock_up . release_lock ( in_lock_name => co_lock_name ); raise ; end ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /* Example */ create or replace package body lock_up is function request_lock ( -- NOSONAR: non-deterministic in_lock_name in varchar2 , in_release_on_commit in boolean default false ) return varchar2 is co_lock_name constant type_up . lock_name : = in_lock_name ; co_release_on_commit constant boolean : = in_release_on_commit ; l_lock_handle type_up . lock_handle ; begin sys . dbms_lock . allocate_unique ( lockname => co_lock_name , lockhandle => l_lock_handle , expiration_secs => constants_up . co_one_week ); if sys . dbms_lock . request ( lockhandle => l_lock_handle , lockmode => sys . dbms_lock . x_mode , timeout => sys . dbms_lock . maxwait , release_on_commit => co_release_on_commit ) > 0 then raise err . e_lock_request_failed ; end if ; return l_lock_handle ; end request_lock ; procedure release_lock ( in_lock_handle in varchar2 ) is co_lock_type constant type_up . lock_handle : = in_lock_handle ; begin if sys . dbms_lock . release ( lockhandle => co_lock_type ) > 0 then raise err . e_lock_request_failed ; end if ; end release_lock ; end lock_up ; / /* Call good example */ declare l_handle type_up . lock_handle ; co_lock_name constant type_up . lock_name : = 'APPLICATION_LOCK' ; begin l_handle : = lock_up . request_lock ( in_lock_name => co_lock_name ); -- processing lock_up . release_lock ( in_lock_handle => l_handle ); exception when err . e_lock_request_failed then -- expected exception lock_up . release_lock ( in_lock_name => co_lock_name ); raise ; when others then -- unexpected exception, logging is recommended lock_up . release_lock ( in_lock_name => co_lock_name ); raise ; end ; /","title":"G-8410: Always use application locks to ensure a program unit is only running once at a given time."},{"location":"4-language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#g-8410-always-use-application-locks-to-ensure-a-program-unit-is-only-running-once-at-a-given-time","text":"Blocker Efficiency, Reliability Unsupported in db* CODECOP Validators We cannot identify where an application lock would make sense. Algorithms to detect wrong, missing and right usages of this pattern are virtually impossible to implement without understanding the context.","title":"G-8410: Always use application locks to ensure a program unit is only running once at a given time."},{"location":"4-language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#reason","text":"This technique allows us to have locks across transactions as well as a proven way to clean up at the end of the session. The alternative using a table where a \u201cLock-Row\u201d is stored has the disadvantage that in case of an error a proper cleanup has to be done to \u201cunlock\u201d the program unit.","title":"Reason"},{"location":"4-language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Example */ create or replace package body lock_up is -- manage locks in a dedicated table created as follows: -- CREATE TABLE app_locks ( -- lock_name VARCHAR2(128 CHAR) NOT NULL primary key -- ); procedure request_lock ( in_lock_name in varchar2 ) is co_lock_name constant app_locks . lock_name % type : = in_lock_name ; begin -- raises dup_val_on_index insert into app_locks ( lock_name ) values ( co_lock_name ); end request_lock ; procedure release_lock ( in_lock_name in varchar2 ) is co_lock_name constant app_locks . lock_name % type : = in_lock_name ; begin delete from app_locks where lock_name = co_lock_name ; end release_lock ; end lock_up ; / /* Call bad example */ declare co_lock_name constant app_locks . lock_name % type : = 'APPLICATION_LOCK' ; begin lock_up . request_lock ( in_lock_name => co_lock_name ); -- processing lock_up . release_lock ( in_lock_name => co_lock_name ); exception when dup_val_on_index then -- expected exception lock_up . release_lock ( in_lock_name => co_lock_name ); raise ; when others then -- unexpected exception, logging is recommended lock_up . release_lock ( in_lock_name => co_lock_name ); raise ; end ; /","title":"Example (bad)"},{"location":"4-language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /* Example */ create or replace package body lock_up is function request_lock ( -- NOSONAR: non-deterministic in_lock_name in varchar2 , in_release_on_commit in boolean default false ) return varchar2 is co_lock_name constant type_up . lock_name : = in_lock_name ; co_release_on_commit constant boolean : = in_release_on_commit ; l_lock_handle type_up . lock_handle ; begin sys . dbms_lock . allocate_unique ( lockname => co_lock_name , lockhandle => l_lock_handle , expiration_secs => constants_up . co_one_week ); if sys . dbms_lock . request ( lockhandle => l_lock_handle , lockmode => sys . dbms_lock . x_mode , timeout => sys . dbms_lock . maxwait , release_on_commit => co_release_on_commit ) > 0 then raise err . e_lock_request_failed ; end if ; return l_lock_handle ; end request_lock ; procedure release_lock ( in_lock_handle in varchar2 ) is co_lock_type constant type_up . lock_handle : = in_lock_handle ; begin if sys . dbms_lock . release ( lockhandle => co_lock_type ) > 0 then raise err . e_lock_request_failed ; end if ; end release_lock ; end lock_up ; / /* Call good example */ declare l_handle type_up . lock_handle ; co_lock_name constant type_up . lock_name : = 'APPLICATION_LOCK' ; begin l_handle : = lock_up . request_lock ( in_lock_name => co_lock_name ); -- processing lock_up . release_lock ( in_lock_handle => l_handle ); exception when err . e_lock_request_failed then -- expected exception lock_up . release_lock ( in_lock_name => co_lock_name ); raise ; when others then -- unexpected exception, logging is recommended lock_up . release_lock ( in_lock_name => co_lock_name ); raise ; end ; /","title":"Example (good)"},{"location":"4-language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/","text":"G-8510: Always use dbms_application_info to track program process transiently. Critical Efficiency, Reliability Unsupported in db* CODECOP Validators We cannot know where the use of dbms_application_info is sensible. Algorithms to detect wrong, missing and right usages of this pattern are virtually impossible to implement without understanding the context. Reason This technique allows us to view progress of a process without having to persistently write log data in either a table or a file. The information is accessible through the v$session view. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create or replace package body employee_api is procedure process_emps is begin << employees >> for emp_rec in ( select employee_id from employees order by employee_id ) loop -- some processing sys . dbms_output . put_line ( emp_rec . employee_id ); end loop employees ; end process_emps ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 create or replace package body employee_api is procedure process_emps is co_action_name constant v$session . action % type : = 'init' ; co_label constant v$session . action % type : = 'Processing ' ; begin sys . dbms_application_info . set_module ( module_name => $$ plsql_unit , action_name => co_action_name ); << employees >> for emp_rec in ( select employee_id from employees order by employee_id ) loop -- some processing sys . dbms_application_info . set_action ( co_label || emp_rec . employee_id ); end loop employees ; end process_emps ; end employee_api ; /","title":"G-8510: Always use dbms_application_info to track program process transiently."},{"location":"4-language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#g-8510-always-use-dbms_application_info-to-track-program-process-transiently","text":"Critical Efficiency, Reliability Unsupported in db* CODECOP Validators We cannot know where the use of dbms_application_info is sensible. Algorithms to detect wrong, missing and right usages of this pattern are virtually impossible to implement without understanding the context.","title":"G-8510: Always use dbms_application_info to track program process transiently."},{"location":"4-language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#reason","text":"This technique allows us to view progress of a process without having to persistently write log data in either a table or a file. The information is accessible through the v$session view.","title":"Reason"},{"location":"4-language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create or replace package body employee_api is procedure process_emps is begin << employees >> for emp_rec in ( select employee_id from employees order by employee_id ) loop -- some processing sys . dbms_output . put_line ( emp_rec . employee_id ); end loop employees ; end process_emps ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 create or replace package body employee_api is procedure process_emps is co_action_name constant v$session . action % type : = 'init' ; co_label constant v$session . action % type : = 'Processing ' ; begin sys . dbms_application_info . set_module ( module_name => $$ plsql_unit , action_name => co_action_name ); << employees >> for emp_rec in ( select employee_id from employees order by employee_id ) loop -- some processing sys . dbms_application_info . set_action ( co_label || emp_rec . employee_id ); end loop employees ; end process_emps ; end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/9-function-usage/g-9010/","text":"G-9010: Always use a format model in string to date/time conversion functions. Blocker Changeability, Maintainability, Reliability, Security, Testability Reason Converting from strings to date or timestamp datatypes (using to_date , to_timestamp , to_timestamp_tz or cast to any of those datatypes) in practice always expects a fixed format (unlike converting to strings that can be fixed as well as allow the session to decide). Therefore it is a bad idea to allow this conversion to rely on the session NLS settings ( nls_date_format , nls_timestamp_format and nls_timestamp_tz_format ) as this makes the code vulnerable to changes in session and/or server configuration. It is even possible to utilize session nls_date_format for SQL injection if you use dynamic SQL. Using an explicit format model for string to date or timestamp conversion avoids this inappropriate dependability on configurable NLS parameters. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str default null on conversion error ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str default null on conversion error , 'FXYYYY-MM-DD' ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; /","title":"G-9010: Always use a format model in string to date/time conversion functions."},{"location":"4-language-usage/9-function-usage/g-9010/#g-9010-always-use-a-format-model-in-string-to-datetime-conversion-functions","text":"Blocker Changeability, Maintainability, Reliability, Security, Testability","title":"G-9010: Always use a format model in string to date/time conversion functions."},{"location":"4-language-usage/9-function-usage/g-9010/#reason","text":"Converting from strings to date or timestamp datatypes (using to_date , to_timestamp , to_timestamp_tz or cast to any of those datatypes) in practice always expects a fixed format (unlike converting to strings that can be fixed as well as allow the session to decide). Therefore it is a bad idea to allow this conversion to rely on the session NLS settings ( nls_date_format , nls_timestamp_format and nls_timestamp_tz_format ) as this makes the code vulnerable to changes in session and/or server configuration. It is even possible to utilize session nls_date_format for SQL injection if you use dynamic SQL. Using an explicit format model for string to date or timestamp conversion avoids this inappropriate dependability on configurable NLS parameters.","title":"Reason"},{"location":"4-language-usage/9-function-usage/g-9010/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str default null on conversion error ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/9-function-usage/g-9010/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str default null on conversion error , 'FXYYYY-MM-DD' ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/9-function-usage/g-9020/","text":"G-9020: Try to use a format model and NLS_NUMERIC_CHARACTERS in string to number conversion functions. Blocker Changeability, Maintainability, Reliability, Security, Testability Reason Converting from strings to numeric datatypes (using to_number , to_binary_double , to_binary_float or cast to any of those datatypes) rely on session NLS settings for nls_numeric_characters . Typically the input string is expected to have a given decimal- and group-separator, so it is best practice to specify nls_numeric_characters in the function call. However, this requires also setting a format model, which is a good idea but can require a very large format model with many 9's if you do not know the maximum length of the string. To avoid an inappropriate dependability on configurable NLS parameters, try to use both format model and nls_numeric_characters in the conversion function call. The exceptions can be if the input is known to always be integer with no decimal- or group-separator, or if you do not know the maximum number of digits and have control over the session nls_numeric_characters parameter. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body employee_api is procedure set_salary ( in_employee_id in employees . employee_id % type , in_salary in varchar2 ) is co_employee_id constant eployees . employee_id % type : = in_employee_id ; co_salary constant type_up . date_string : = in_salary ; begin update employees set salary = to_number ( co_salary default null on conversion error ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is procedure set_salary ( in_employee_id in employees . employee_id % type , in_salary in varchar2 ) is co_employee_id constant eployees . employee_id % type : = in_employee_id ; co_salary constant type_up . string : = in_salary ; begin update employees set salary = to_number ( co_salary default null on conversion error , '99999999999999999999.99999' , q '[nls_numeric_characters=' ., ']' ) where employee_id = co_employee_id ; end set_dob ; end employee_api ;","title":"G-9020: Try to use a format model and NLS_NUMERIC_CHARACTERS in string to number conversion functions."},{"location":"4-language-usage/9-function-usage/g-9020/#g-9020-try-to-use-a-format-model-and-nls_numeric_characters-in-string-to-number-conversion-functions","text":"Blocker Changeability, Maintainability, Reliability, Security, Testability","title":"G-9020: Try to use a format model and NLS_NUMERIC_CHARACTERS in string to number conversion functions."},{"location":"4-language-usage/9-function-usage/g-9020/#reason","text":"Converting from strings to numeric datatypes (using to_number , to_binary_double , to_binary_float or cast to any of those datatypes) rely on session NLS settings for nls_numeric_characters . Typically the input string is expected to have a given decimal- and group-separator, so it is best practice to specify nls_numeric_characters in the function call. However, this requires also setting a format model, which is a good idea but can require a very large format model with many 9's if you do not know the maximum length of the string. To avoid an inappropriate dependability on configurable NLS parameters, try to use both format model and nls_numeric_characters in the conversion function call. The exceptions can be if the input is known to always be integer with no decimal- or group-separator, or if you do not know the maximum number of digits and have control over the session nls_numeric_characters parameter.","title":"Reason"},{"location":"4-language-usage/9-function-usage/g-9020/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body employee_api is procedure set_salary ( in_employee_id in employees . employee_id % type , in_salary in varchar2 ) is co_employee_id constant eployees . employee_id % type : = in_employee_id ; co_salary constant type_up . date_string : = in_salary ; begin update employees set salary = to_number ( co_salary default null on conversion error ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/9-function-usage/g-9020/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is procedure set_salary ( in_employee_id in employees . employee_id % type , in_salary in varchar2 ) is co_employee_id constant eployees . employee_id % type : = in_employee_id ; co_salary constant type_up . string : = in_salary ; begin update employees set salary = to_number ( co_salary default null on conversion error , '99999999999999999999.99999' , q '[nls_numeric_characters=' ., ']' ) where employee_id = co_employee_id ; end set_dob ; end employee_api ;","title":"Example (good)"},{"location":"4-language-usage/9-function-usage/g-9030/","text":"G-9030: Try to define a default value on conversion errors. Major Maintainability, Reliability, Testability Restriction Oracle Database 12c Release 2 Reason When converting from strings to other datatypes using a conversion function that supports the default ... on conversion error clause, it is a good idea to use this clause to avoid getting an error raised on bad input. The exception can be when you explicitly want an error to be raised to catch and process it in a later exception handler. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str , 'FXYYYY-MM-DD' ) -- violates also G-1050 where employee_id = co_employee_id ; end set_dob ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str default null on conversion error , 'FXYYYY-MM-DD' -- NOSONAR: G-1050 must be a literal ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; /","title":"G-9030: Try to define a default value on conversion errors."},{"location":"4-language-usage/9-function-usage/g-9030/#g-9030-try-to-define-a-default-value-on-conversion-errors","text":"Major Maintainability, Reliability, Testability","title":"G-9030: Try to define a default value on conversion errors."},{"location":"4-language-usage/9-function-usage/g-9030/#restriction","text":"Oracle Database 12c Release 2","title":"Restriction"},{"location":"4-language-usage/9-function-usage/g-9030/#reason","text":"When converting from strings to other datatypes using a conversion function that supports the default ... on conversion error clause, it is a good idea to use this clause to avoid getting an error raised on bad input. The exception can be when you explicitly want an error to be raised to catch and process it in a later exception handler.","title":"Reason"},{"location":"4-language-usage/9-function-usage/g-9030/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str , 'FXYYYY-MM-DD' ) -- violates also G-1050 where employee_id = co_employee_id ; end set_dob ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/9-function-usage/g-9030/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str default null on conversion error , 'FXYYYY-MM-DD' -- NOSONAR: G-1050 must be a literal ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; /","title":"Example (good)"},{"location":"4-language-usage/9-function-usage/g-9040/","text":"G-9040: Try using FX in string to date/time conversion format model to avoid fuzzy conversion. Blocker Reliability, Testability Reason The default string-to-date conversion rules allow fuzzy conversion when converting from strings to date or timestamp datatypes (using to_date , to_timestamp , to_timestamp_tz or cast to any of those datatypes). For example you can omit punctuation characters, use any non-alphanumeric character for punctuation, use month name instead of number, or various other rules. In practice you almost always expect a truly fixed format and want the database to enforce the format model and raise an error if the data does not match the format model. This you can achieve by adding the format modifier FX (format exact). The exception to this rule can be if you are converting textual input typed by a user, in which case the fuzzy conversion may be what you want. Example (bad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str default null on conversion error , 'YYYY-MM-DD' ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; / Example (good) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str default null on conversion error , 'FXYYYY-MM-DD' ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; /","title":"G-9040: Try using FX in string to date/time conversion format model to avoid fuzzy conversion."},{"location":"4-language-usage/9-function-usage/g-9040/#g-9040-try-using-fx-in-string-to-datetime-conversion-format-model-to-avoid-fuzzy-conversion","text":"Blocker Reliability, Testability","title":"G-9040: Try using FX in string to date/time conversion format model to avoid fuzzy conversion."},{"location":"4-language-usage/9-function-usage/g-9040/#reason","text":"The default string-to-date conversion rules allow fuzzy conversion when converting from strings to date or timestamp datatypes (using to_date , to_timestamp , to_timestamp_tz or cast to any of those datatypes). For example you can omit punctuation characters, use any non-alphanumeric character for punctuation, use month name instead of number, or various other rules. In practice you almost always expect a truly fixed format and want the database to enforce the format model and raise an error if the data does not match the format model. This you can achieve by adding the format modifier FX (format exact). The exception to this rule can be if you are converting textual input typed by a user, in which case the fuzzy conversion may be what you want.","title":"Reason"},{"location":"4-language-usage/9-function-usage/g-9040/#example-bad","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str default null on conversion error , 'YYYY-MM-DD' ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; /","title":"Example (bad)"},{"location":"4-language-usage/9-function-usage/g-9040/#example-good","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 create or replace package body employee_api is procedure set_dob ( in_employee_id in employees . employee_id % type , in_dob_str in varchar2 ) is co_employee_id constant employees . employee_id % type : = in_employee_id ; co_dob_str constant type_up . date_string : = in_dob_str ; begin update employees set date_of_birth = to_date ( co_dob_str default null on conversion error , 'FXYYYY-MM-DD' ) where employee_id = co_employee_id ; end set_dob ; end employee_api ; /","title":"Example (good)"},{"location":"5-complexity-analysis/complexity-analysis/","text":"Complexity Analysis Using software metrics like complexity analysis will guide you towards maintainable and testable pieces of code by reducing the complexity and splitting the code into smaller chunks. Halstead Metrics Calculation First, we need to compute the following numbers, given the program: \\(n_1\\) = the number of distinct operators \\(n_2\\) = the number of distinct operands \\(N_1\\) = the total number of operators \\(N_2\\) = the total number of operands From these numbers, five measures can be calculated: Program length: \\(N = N_1 + N_2\\) Program vocabulary: \\(n = n_1 + n_2\\) Volume: \\(V = N \\cdot log_2 n\\) Difficulty: \\(D = \\frac{n_1}{2} \\cdot \\frac{N_2}{n_2}\\) Effort: \\(E = D \\cdot V\\) The difficulty measure \\(D\\) is related to the difficulty of the program to write or understand, e.g. when doing code review. The volume measure \\(V\\) describes the size of the implementation of an algorithm. McCabe's Cyclomatic Complexity Description Cyclomatic complexity (or conditional complexity) is a software metric used to measure the complexity of a program. It directly measures the number of linearly independent paths through a program's source code. Cyclomatic complexity is computed using the control flow graph of the program: the nodes of the graph correspond to indivisible groups of commands of a program, and a directed edge connects two nodes if the second command might be executed immediately after the first command. Cyclomatic complexity may also be applied to individual functions, modules, methods or classes within a program. The cyclomatic complexity of a section of source code is the count of the number of linearly independent paths through the source code. For instance, if the source code contains no decision points, such as if statements or for loops, the complexity would be 1, since there is only a single path through the code. If the code has a single if statement containing a single condition there would be two paths through the code, one path where the if statement is evaluated as true and one path where the if statement is evaluated as false . Calculation Mathematically, the cyclomatic complexity of a structured program is defined with reference to a directed graph containing the basic blocks of the program, with an edge between two basic blocks if control may pass from the first to the second (the control flow graph of the program). The complexity is then defined as: \\[M = E - N + 2P\\] where \\(M\\) = cyclomatic complexity \\(E\\) = the number of edges of the graph \\(N\\) = the number of nodes of the graph \\(P\\) = the number of connected components. Take, for example, a control flow graph of a simple program. The program begins executing at the red node, then enters a loop (group of three nodes immediately below the red node). On exiting the loop, there is a conditional statement (group below the loop), and finally the program exits at the blue node. For this graph, \\(E = 9\\) , \\(N = 8\\) and \\(P = 1\\) , so the cyclomatic complexity of the program is \\(3\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 declare co_upper_bound constant integer : = 3 ; co_msg constant user_objects . object_name % type : = 'in loop ' ; co_yes constant user_objects . object_name % type : = 'yes' ; co_end constant user_objects . object_name % type : = 'end' ; begin << print_in_loop >> for i in 1 .. co_upper_bound loop sys . dbms_output . put_line ( co_msg || i ); end loop print_in_loop ; -- if 1 = 1 then sys . dbms_output . put_line ( co_yes ); end if ; -- sys . dbms_output . put_line ( co_end ); end ; / For a single program (or subroutine or method), P is always equal to 1. Cyclomatic complexity may, however, be applied to several such programs or subprograms at the same time (e.g., to all of the methods in a class), and in these cases P will be equal to the number of programs in question, as each subprogram will appear as a disconnected subset of the graph. It can be shown that the cyclomatic complexity of any structured program with only one entrance point and one exit point is equal to the number of decision points (i.e., if statements or conditional loops) contained in that program plus one. Cyclomatic complexity may be extended to a program with multiple exit points; in this case it is equal to: \\[\\pi = s + 2\\] Where \\(\\pi\\) is the number of decision points in the program, and \\(s\\) is the number of exit points.","title":"Complexity Analysis"},{"location":"5-complexity-analysis/complexity-analysis/#complexity-analysis","text":"Using software metrics like complexity analysis will guide you towards maintainable and testable pieces of code by reducing the complexity and splitting the code into smaller chunks.","title":"Complexity Analysis"},{"location":"5-complexity-analysis/complexity-analysis/#halstead-metrics","text":"","title":"Halstead Metrics"},{"location":"5-complexity-analysis/complexity-analysis/#calculation","text":"First, we need to compute the following numbers, given the program: \\(n_1\\) = the number of distinct operators \\(n_2\\) = the number of distinct operands \\(N_1\\) = the total number of operators \\(N_2\\) = the total number of operands From these numbers, five measures can be calculated: Program length: \\(N = N_1 + N_2\\) Program vocabulary: \\(n = n_1 + n_2\\) Volume: \\(V = N \\cdot log_2 n\\) Difficulty: \\(D = \\frac{n_1}{2} \\cdot \\frac{N_2}{n_2}\\) Effort: \\(E = D \\cdot V\\) The difficulty measure \\(D\\) is related to the difficulty of the program to write or understand, e.g. when doing code review. The volume measure \\(V\\) describes the size of the implementation of an algorithm.","title":"Calculation"},{"location":"5-complexity-analysis/complexity-analysis/#mccabes-cyclomatic-complexity","text":"","title":"McCabe's Cyclomatic Complexity"},{"location":"5-complexity-analysis/complexity-analysis/#description","text":"Cyclomatic complexity (or conditional complexity) is a software metric used to measure the complexity of a program. It directly measures the number of linearly independent paths through a program's source code. Cyclomatic complexity is computed using the control flow graph of the program: the nodes of the graph correspond to indivisible groups of commands of a program, and a directed edge connects two nodes if the second command might be executed immediately after the first command. Cyclomatic complexity may also be applied to individual functions, modules, methods or classes within a program. The cyclomatic complexity of a section of source code is the count of the number of linearly independent paths through the source code. For instance, if the source code contains no decision points, such as if statements or for loops, the complexity would be 1, since there is only a single path through the code. If the code has a single if statement containing a single condition there would be two paths through the code, one path where the if statement is evaluated as true and one path where the if statement is evaluated as false .","title":"Description"},{"location":"5-complexity-analysis/complexity-analysis/#calculation_1","text":"Mathematically, the cyclomatic complexity of a structured program is defined with reference to a directed graph containing the basic blocks of the program, with an edge between two basic blocks if control may pass from the first to the second (the control flow graph of the program). The complexity is then defined as: \\[M = E - N + 2P\\] where \\(M\\) = cyclomatic complexity \\(E\\) = the number of edges of the graph \\(N\\) = the number of nodes of the graph \\(P\\) = the number of connected components. Take, for example, a control flow graph of a simple program. The program begins executing at the red node, then enters a loop (group of three nodes immediately below the red node). On exiting the loop, there is a conditional statement (group below the loop), and finally the program exits at the blue node. For this graph, \\(E = 9\\) , \\(N = 8\\) and \\(P = 1\\) , so the cyclomatic complexity of the program is \\(3\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 declare co_upper_bound constant integer : = 3 ; co_msg constant user_objects . object_name % type : = 'in loop ' ; co_yes constant user_objects . object_name % type : = 'yes' ; co_end constant user_objects . object_name % type : = 'end' ; begin << print_in_loop >> for i in 1 .. co_upper_bound loop sys . dbms_output . put_line ( co_msg || i ); end loop print_in_loop ; -- if 1 = 1 then sys . dbms_output . put_line ( co_yes ); end if ; -- sys . dbms_output . put_line ( co_end ); end ; / For a single program (or subroutine or method), P is always equal to 1. Cyclomatic complexity may, however, be applied to several such programs or subprograms at the same time (e.g., to all of the methods in a class), and in these cases P will be equal to the number of programs in question, as each subprogram will appear as a disconnected subset of the graph. It can be shown that the cyclomatic complexity of any structured program with only one entrance point and one exit point is equal to the number of decision points (i.e., if statements or conditional loops) contained in that program plus one. Cyclomatic complexity may be extended to a program with multiple exit points; in this case it is equal to: \\[\\pi = s + 2\\] Where \\(\\pi\\) is the number of decision points in the program, and \\(s\\) is the number of exit points.","title":"Calculation"},{"location":"6-code-reviews/code-reviews/","text":"Code Reviews Code reviews check the results of software engineering. According to IEEE-Norm 729, a review is a more or less planned and structured analysis and evaluation process. Here we distinguish between code review and architect review. To perform a code review means that after or during the development one or more reviewer proof-reads the code to find potential errors, potential areas for simplification, or test cases. A code review is a very good opportunity to save costs by fixing issues before the testing phase. What can a code-review be good for? Code quality Code clarity and maintainability Quality of the overall architecture Quality of the documentation Quality of the interface specification For an effective review, the following factors must be considered: Definition of clear goals. Choice of a suitable person with constructive critical faculties. Psychological aspects. Selection of the right review techniques. Support of the review process from the management. Existence of a culture of learning and process optimization. Requirements for the reviewer: He must not be the owner of the code. Code reviews may be unpleasant for the developer, as he could fear that his code will be criticized. If the critic is not considerate, the code writer will build up rejection and resistance against code reviews.","title":"Code Reviews"},{"location":"6-code-reviews/code-reviews/#code-reviews","text":"Code reviews check the results of software engineering. According to IEEE-Norm 729, a review is a more or less planned and structured analysis and evaluation process. Here we distinguish between code review and architect review. To perform a code review means that after or during the development one or more reviewer proof-reads the code to find potential errors, potential areas for simplification, or test cases. A code review is a very good opportunity to save costs by fixing issues before the testing phase. What can a code-review be good for? Code quality Code clarity and maintainability Quality of the overall architecture Quality of the documentation Quality of the interface specification For an effective review, the following factors must be considered: Definition of clear goals. Choice of a suitable person with constructive critical faculties. Psychological aspects. Selection of the right review techniques. Support of the review process from the management. Existence of a culture of learning and process optimization. Requirements for the reviewer: He must not be the owner of the code. Code reviews may be unpleasant for the developer, as he could fear that his code will be criticized. If the critic is not considerate, the code writer will build up rejection and resistance against code reviews.","title":"Code Reviews"},{"location":"7-tool-support/1-db-codecop-sqldev/","text":"db* CODECOP for SQL Developer Introduction db* CODECOP for SQL Developer is a free extension to check an editor content for compliance violations of this coding guideline. The extension may be parameterized to your preferred set of rules and allows checking this set against a program unit. db* CODECOP calculates metrics per PL/SQL unit, such as: McCabe\u2019s cyclomatic complexity Halstead\u2019s volume The maintainability index Lines Commands (SQL*Plus and SQL) Statements (within a PL/SQL unit) etc. And aggregates them on file level. The results are presented in an additional tabbed panel. One tab shows all guideline violations to quickly navigate to the corresponding code position. The other tab contains a full HTML report, which also may be opened in your external browser. Examples Open a PL/SQL or SQL script in a SQL Developer editor and press Ctrl-Shift-C to check your code against the Trivadis PL/SQL & SQL guidelines. Navigate through the issues using the cursor keys to highlight the related code section in the linked editor. Dock the db* CODECOP output window on your favorite position within SQL Developer and click on the report tab to reveal some additional metrics. Open the report in an external browser to print or save the report.","title":"db* CODECOP for SQL Developer"},{"location":"7-tool-support/1-db-codecop-sqldev/#db-codecop-for-sql-developer","text":"","title":"db* CODECOP for SQL Developer"},{"location":"7-tool-support/1-db-codecop-sqldev/#introduction","text":"db* CODECOP for SQL Developer is a free extension to check an editor content for compliance violations of this coding guideline. The extension may be parameterized to your preferred set of rules and allows checking this set against a program unit. db* CODECOP calculates metrics per PL/SQL unit, such as: McCabe\u2019s cyclomatic complexity Halstead\u2019s volume The maintainability index Lines Commands (SQL*Plus and SQL) Statements (within a PL/SQL unit) etc. And aggregates them on file level. The results are presented in an additional tabbed panel. One tab shows all guideline violations to quickly navigate to the corresponding code position. The other tab contains a full HTML report, which also may be opened in your external browser.","title":"Introduction"},{"location":"7-tool-support/1-db-codecop-sqldev/#examples","text":"Open a PL/SQL or SQL script in a SQL Developer editor and press Ctrl-Shift-C to check your code against the Trivadis PL/SQL & SQL guidelines. Navigate through the issues using the cursor keys to highlight the related code section in the linked editor. Dock the db* CODECOP output window on your favorite position within SQL Developer and click on the report tab to reveal some additional metrics. Open the report in an external browser to print or save the report.","title":"Examples"},{"location":"7-tool-support/2-db-codecop-sonarqube/","text":"db* CODECOP for SonarQube Introduction db* CODECOP for SonarQube is a plugin for SonarQube . The plugin analyses SQL and PL/SQL code and calculates various metrics and checks the code for compliance of this coding guideline. A static code analysis is typically initiated as part of an continuous integration setup, e.g. at the end of a Jenkins or Hudson build job. SonarQube stores the result of the analysis in a relational database. Supported are PostgreSQL, Microsoft SQL Server and Oracle Database. For evaluation purposes, the embedded H2 database can also be used. Since every analysis is stored as a snapshot in the SonarQube repository the improvement or the decrease of the code quality may be monitored very well. Use SonarQube and the db* CODECOP plugin if you care about your PL/SQL code quality. Examples Run Code Analysis via SonarScanner You start an analysis from the command line as follows (see docs for more information): 1 sonar-scanner -Dsonar.projectKey=\"sample\" Here's an excerpt of the output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 INFO: Scanner configuration file: /usr/local/opt/sonar-scanner/conf/sonar-scanner.properties INFO: Project root configuration file: NONE INFO: SonarQube Scanner 4.1.0.1829 ... INFO: Project configuration: INFO: 115 files indexed INFO: Quality profile for plsql: db* CODECOP INFO: ------------- Run sensors on module sample INFO: JavaScript/TypeScript frontend is enabled INFO: Define db* CODECOP PlugIn (Secondary) INFO: Load metrics repository INFO: Load metrics repository (done) | time=36ms INFO: PlSQL COP Sensor initializing INFO: Instantiate class: com.trivadis.sonar.plugin.TrivadisGuidelines3ValidatorConfig INFO: Sensor CSS Rules [cssfamily] INFO: No CSS, PHP, HTML or VueJS files are found in the project. CSS analysis is skipped. INFO: Sensor CSS Rules [cssfamily] (done) | time=1ms INFO: Sensor PL/SQL Sensor [plsql] INFO: 115 source files to be analyzed INFO: Load project repositories INFO: Load project repositories (done) | time=10ms ... INFO: Analysis report generated in 149ms, dir size=603 KB INFO: Analysis report compressed in 1101ms, zip size=264 KB INFO: Analysis report uploaded in 1858ms INFO: ANALYSIS SUCCESSFUL, you can browse http://localhost:9000/dashboard?id=sample INFO: Note that you will be able to access the updated dashboard once the server has processed the submitted analysis report INFO: More about the report processing at http://localhost:9000/api/ce/task?id=AXiSv3IJVMRTx5sCSVMo INFO: Analysis total time: 27.088 s INFO: ------------------------------------------------------------------------ INFO: EXECUTION SUCCESS INFO: ------------------------------------------------------------------------ INFO: Total time: 28.961s INFO: Final Memory: 40M/144M INFO: ------------------------------------------------------------------------ At the end of the run an URL to the scanner result is provided. Run Code Analyis with CI Environments You can call the SonarScanner also from Gradle, .NET projects, Maven, Ant, Jenkins, etc. Whichever method you use, in the end the analysis report will be uploaded to SonarQube. See SonarScanner for more information. View Code Analysis Result in SonarQube Here are the results of the previous analysis. Under Issues the following Blocker are shown: By clicking on the reddish box you can drill down to the source code. When clicking on Why is this an issue? the complete rule is shown in similar way as in these guidelines. See SonarQube documentation for more information.","title":"db* CODECOP for SonarQube"},{"location":"7-tool-support/2-db-codecop-sonarqube/#db-codecop-for-sonarqube","text":"","title":"db* CODECOP for SonarQube"},{"location":"7-tool-support/2-db-codecop-sonarqube/#introduction","text":"db* CODECOP for SonarQube is a plugin for SonarQube . The plugin analyses SQL and PL/SQL code and calculates various metrics and checks the code for compliance of this coding guideline. A static code analysis is typically initiated as part of an continuous integration setup, e.g. at the end of a Jenkins or Hudson build job. SonarQube stores the result of the analysis in a relational database. Supported are PostgreSQL, Microsoft SQL Server and Oracle Database. For evaluation purposes, the embedded H2 database can also be used. Since every analysis is stored as a snapshot in the SonarQube repository the improvement or the decrease of the code quality may be monitored very well. Use SonarQube and the db* CODECOP plugin if you care about your PL/SQL code quality.","title":"Introduction"},{"location":"7-tool-support/2-db-codecop-sonarqube/#examples","text":"","title":"Examples"},{"location":"7-tool-support/2-db-codecop-sonarqube/#run-code-analysis-via-sonarscanner","text":"You start an analysis from the command line as follows (see docs for more information): 1 sonar-scanner -Dsonar.projectKey=\"sample\" Here's an excerpt of the output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 INFO: Scanner configuration file: /usr/local/opt/sonar-scanner/conf/sonar-scanner.properties INFO: Project root configuration file: NONE INFO: SonarQube Scanner 4.1.0.1829 ... INFO: Project configuration: INFO: 115 files indexed INFO: Quality profile for plsql: db* CODECOP INFO: ------------- Run sensors on module sample INFO: JavaScript/TypeScript frontend is enabled INFO: Define db* CODECOP PlugIn (Secondary) INFO: Load metrics repository INFO: Load metrics repository (done) | time=36ms INFO: PlSQL COP Sensor initializing INFO: Instantiate class: com.trivadis.sonar.plugin.TrivadisGuidelines3ValidatorConfig INFO: Sensor CSS Rules [cssfamily] INFO: No CSS, PHP, HTML or VueJS files are found in the project. CSS analysis is skipped. INFO: Sensor CSS Rules [cssfamily] (done) | time=1ms INFO: Sensor PL/SQL Sensor [plsql] INFO: 115 source files to be analyzed INFO: Load project repositories INFO: Load project repositories (done) | time=10ms ... INFO: Analysis report generated in 149ms, dir size=603 KB INFO: Analysis report compressed in 1101ms, zip size=264 KB INFO: Analysis report uploaded in 1858ms INFO: ANALYSIS SUCCESSFUL, you can browse http://localhost:9000/dashboard?id=sample INFO: Note that you will be able to access the updated dashboard once the server has processed the submitted analysis report INFO: More about the report processing at http://localhost:9000/api/ce/task?id=AXiSv3IJVMRTx5sCSVMo INFO: Analysis total time: 27.088 s INFO: ------------------------------------------------------------------------ INFO: EXECUTION SUCCESS INFO: ------------------------------------------------------------------------ INFO: Total time: 28.961s INFO: Final Memory: 40M/144M INFO: ------------------------------------------------------------------------ At the end of the run an URL to the scanner result is provided.","title":"Run Code Analysis via SonarScanner"},{"location":"7-tool-support/2-db-codecop-sonarqube/#run-code-analyis-with-ci-environments","text":"You can call the SonarScanner also from Gradle, .NET projects, Maven, Ant, Jenkins, etc. Whichever method you use, in the end the analysis report will be uploaded to SonarQube. See SonarScanner for more information.","title":"Run Code Analyis with CI Environments"},{"location":"7-tool-support/2-db-codecop-sonarqube/#view-code-analysis-result-in-sonarqube","text":"Here are the results of the previous analysis. Under Issues the following Blocker are shown: By clicking on the reddish box you can drill down to the source code. When clicking on Why is this an issue? the complete rule is shown in similar way as in these guidelines. See SonarQube documentation for more information.","title":"View Code Analysis Result in SonarQube"},{"location":"7-tool-support/3-db-codecop-cli/","text":"db* CODECOP Command Line Introduction Trivadis db* CODECOP is a command line utility to check Oracle SQL*Plus files for compliance violations of this coding guideline. Furthermore McCabe\u2019s cyclomatic complexity, Halstead\u2019s volume, the maintainability index and some other software metrics are calculated for each PL/SQL unit and aggregated on file level. The code checking results are stored in XML, HTML and Excel files for further processing. To get the most out of this command line utility you should make it part of your Continuous Integration environment by using the db* CODECOP for SonarQube plugin. This way you may control the quality of your code base over time. Have also a look at db* CODECOP for SQL Developer if you are interested to check the code quality of PL/SQL code within SQL Developer. It\u2019s a free extension. db* CODECOP supports custom validators. We provide some example validators in this GitHub repository . You may use these validators as is or amend/extend them to suit your needs. Examples Here are some screen shot taken from an of an HTML report based on the samples provided with db* CODECOP. These HTML and Excel reports have been created by db* CODECOP and are based on a simple set of good and bad example files distributed with db* CODECOP.","title":"db* CODECOP Command Line"},{"location":"7-tool-support/3-db-codecop-cli/#db-codecop-command-line","text":"","title":"db* CODECOP Command Line"},{"location":"7-tool-support/3-db-codecop-cli/#introduction","text":"Trivadis db* CODECOP is a command line utility to check Oracle SQL*Plus files for compliance violations of this coding guideline. Furthermore McCabe\u2019s cyclomatic complexity, Halstead\u2019s volume, the maintainability index and some other software metrics are calculated for each PL/SQL unit and aggregated on file level. The code checking results are stored in XML, HTML and Excel files for further processing. To get the most out of this command line utility you should make it part of your Continuous Integration environment by using the db* CODECOP for SonarQube plugin. This way you may control the quality of your code base over time. Have also a look at db* CODECOP for SQL Developer if you are interested to check the code quality of PL/SQL code within SQL Developer. It\u2019s a free extension. db* CODECOP supports custom validators. We provide some example validators in this GitHub repository . You may use these validators as is or amend/extend them to suit your needs.","title":"Introduction"},{"location":"7-tool-support/3-db-codecop-cli/#examples","text":"Here are some screen shot taken from an of an HTML report based on the samples provided with db* CODECOP. These HTML and Excel reports have been created by db* CODECOP and are based on a simple set of good and bad example files distributed with db* CODECOP.","title":"Examples"},{"location":"7-tool-support/4-db-codecop-validators/","text":"db* CODECOP Validators db* CODECOP supports custom validators. A validator must implement the PLSQLCopValidator Java interface and has to be a direct or indirect descendant of the PLSQLValidator class. Such a class can be used in the command line utility and the SQL Developer extension. For SonarQube a ValidationConfig is required. A config defines the validator with its rules and quality profile for SonarQube. See GLPValidatorConfig . The referenced XML files are generated based on the validator and the optional sample guidelines . You may use these validators as is or amend/extend them to suit your needs. Provided Validators The db* CODECOP Validators project provides the following custom validators in the package com.trivadis.tvdcc.validators : Class Description TrivadisPlsqlNaming Checks Naming Conventions of the Trivadis PL/SQL & SQL Coding Guidelines GLP Checks naming of global and local variables and parameters SQLInjection Looks for SQL injection vulnerabilities, e.g. unasserted parameters in dynamic SQL Hint Looks for unknown hints and invalid table references OverrideTrivadisGuidelines Extends TrivadisGuidelines3 and overrides check for G-1050 . TrivadisGuidelines3Plus Combines the validators TrivadisPlsqlNaming, SQLInjection and OverrideTrivadisGuidelines.","title":"db* CODECOP Validators"},{"location":"7-tool-support/4-db-codecop-validators/#db-codecop-validators","text":"db* CODECOP supports custom validators. A validator must implement the PLSQLCopValidator Java interface and has to be a direct or indirect descendant of the PLSQLValidator class. Such a class can be used in the command line utility and the SQL Developer extension. For SonarQube a ValidationConfig is required. A config defines the validator with its rules and quality profile for SonarQube. See GLPValidatorConfig . The referenced XML files are generated based on the validator and the optional sample guidelines . You may use these validators as is or amend/extend them to suit your needs.","title":"db* CODECOP Validators"},{"location":"7-tool-support/4-db-codecop-validators/#provided-validators","text":"The db* CODECOP Validators project provides the following custom validators in the package com.trivadis.tvdcc.validators : Class Description TrivadisPlsqlNaming Checks Naming Conventions of the Trivadis PL/SQL & SQL Coding Guidelines GLP Checks naming of global and local variables and parameters SQLInjection Looks for SQL injection vulnerabilities, e.g. unasserted parameters in dynamic SQL Hint Looks for unknown hints and invalid table references OverrideTrivadisGuidelines Extends TrivadisGuidelines3 and overrides check for G-1050 . TrivadisGuidelines3Plus Combines the validators TrivadisPlsqlNaming, SQLInjection and OverrideTrivadisGuidelines.","title":"Provided Validators"},{"location":"7-tool-support/5-plscope-utils/","text":"plscope-utils Introduction plscope-utils is based on PL/Scope which is available in the Oracle Database since version 11.1. It consists of the following two components: Core Database Objects Provides relational views and PL/SQL packages to simplify common source code analysis tasks. Requires a server side installation. SQL Developer Extension (plscope-utils for SQL Developer) Extends SQL Developer by a PL/Scope node in the database navigator tree, context menus, views shown for tables, views and PL/SQL nodes and some reports. Requires a client side installation only. Part of plscope-utils is a check of naming conventions according to this coding guideline - either as a database view or a Oracle SQL Developer report.","title":"plscope-utils"},{"location":"7-tool-support/5-plscope-utils/#plscope-utils","text":"","title":"plscope-utils"},{"location":"7-tool-support/5-plscope-utils/#introduction","text":"plscope-utils is based on PL/Scope which is available in the Oracle Database since version 11.1. It consists of the following two components: Core Database Objects Provides relational views and PL/SQL packages to simplify common source code analysis tasks. Requires a server side installation. SQL Developer Extension (plscope-utils for SQL Developer) Extends SQL Developer by a PL/Scope node in the database navigator tree, context menus, views shown for tables, views and PL/SQL nodes and some reports. Requires a client side installation only. Part of plscope-utils is a check of naming conventions according to this coding guideline - either as a database view or a Oracle SQL Developer report.","title":"Introduction"},{"location":"7-tool-support/6-formatter-settings/","text":"PL/SQL & SQL Formatter Settings Introduction This GitHub repository provides formatter settings that follow the Coding Style of these guidelines. Extensive settings using Arbori are provided for Oracle SQLcl Oracle SQL Developer Simple configuration files are also available for Allround Automations PL/SQL Developer JetBrains DataGrip Quest Toad for Oracle There is also a standalone formatter that can be used in a Git pre-commit Hook to automate the formatting process. By the way, the code blocks in these guidelines were formatted using this standalone formatter.","title":"PL/SQL & SQL Formatter Settings"},{"location":"7-tool-support/6-formatter-settings/#plsql-sql-formatter-settings","text":"","title":"PL/SQL &amp; SQL Formatter Settings"},{"location":"7-tool-support/6-formatter-settings/#introduction","text":"This GitHub repository provides formatter settings that follow the Coding Style of these guidelines. Extensive settings using Arbori are provided for Oracle SQLcl Oracle SQL Developer Simple configuration files are also available for Allround Automations PL/SQL Developer JetBrains DataGrip Quest Toad for Oracle There is also a standalone formatter that can be used in a Git pre-commit Hook to automate the formatting process. By the way, the code blocks in these guidelines were formatted using this standalone formatter.","title":"Introduction"},{"location":"9-appendix/appendix/","text":"Appendix A - PL/SQL & SQL Coding Guidelines as PDF These guidelines are primarily produced in HTML using Material for MkDocs . However, we provide these guidelines also as PDF produced by wkhtmltopdf . The formatting is not perfect, but it should be adequate for those who want to work with offline documents. B - Mapping new guidelines to prior versions Old Id New Id Text Severity Change- ability Effi- ciency Maintain- ability Port- ability Reli- ability Reus- ability Secu- rity Test- ability 1 1010 Try to label your sub blocks. Minor \u2718 2 1020 Always have a matching loop or block label. Minor \u2718 3 1030 Avoid defining variables that are not used. Major \u2718 \u2718 4 1040 Avoid dead code. Major \u2718 5 1050 Avoid using literals in your code. Minor \u2718 6 1060 Avoid storing ROWIDs or UROWIDs in database tables. Blocker \u2718 7 1070 Avoid nesting comment blocks. Minor \u2718 n/a 1080 Avoid using the same expression on both sides of a relational comparison operator or a logical operator. Blocker \u2718 \u2718 \u2718 8 2110 Try to use anchored declarations for variables, constants and types. Major \u2718 \u2718 9 2120 Try to have a single location to define your types. Minor \u2718 10 2130 Try to use subtypes for constructs used often in your code. Minor \u2718 n/a 2135 Avoid assigning values to local variables that are not used by a subsequent statement. Major \u2718 \u2718 \u2718 11 2140 Never initialize variables with NULL. Minor \u2718 n/a 2145 Never self-assign a variable. Blocker \u2718 12 2150 Avoid comparisons with NULL value, consider using IS [NOT] NULL. Blocker \u2718 \u2718 13 2160 Avoid initializing variables using functions in the declaration section. Critical \u2718 14 2170 Never overload variables. Major \u2718 15 2180 Never use quoted identifiers. Major \u2718 16 2185 Avoid using overly short names for explicitly or implicitly declared identifiers. Major \u2718 17 2190 Avoid using ROWID or UROWID. Blocker \u2718 \u2718 18 2210 Avoid declaring NUMBER variables, constants or subtypes with no precision. Critical \u2718 19 2220 Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values. Critical \u2718 n/a 2230 Try to use SIMPLE_INTEGER datatype when appropriate. Critical \u2718 20 2310 Avoid using CHAR data type. Blocker \u2718 21 2320 Never use VARCHAR data type. Blocker \u2718 \u2718 22 2330 Never use zero-length strings to substitute NULL. Blocker \u2718 \u2718 23 2340 Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored). Blocker \u2718 24 2410 Try to use boolean data type for values with dual meaning. Minor \u2718 25 2510 Avoid using the LONG and LONG RAW data types. Major \u2718 n/a 2610 Never use self-defined weak ref cursor types. Minor \u2718 \u2718 \u2718 \u2718 26 3110 Always specify the target columns when coding an insert statement. Blocker \u2718 \u2718 n/a 3115 Avoid self-assigning a column. Blocker \u2718 27 3120 Always use table aliases when your SQL statement involves more than one source. Blocker \u2718 28 3130 Try to use ANSI SQL-92 join syntax. Major \u2718 \u2718 29 3140 Try to use anchored records as targets for your cursors. Major \u2718 \u2718 n/a 3145 Avoid using SELECT * directly from a table or view. Blocker \u2718 \u2718 \u2718 \u2718 n/a 3150 Try to use identity columns for surrogate keys. Critical \u2718 \u2718 n/a 3160 Avoid visible virtual columns. Blocker \u2718 \u2718 n/a 3170 Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values. Blocker \u2718 n/a 3180 Always specify column names instead of positional references in ORDER BY clauses. Major \u2718 \u2718 n/a 3182 Always specify column names/aliases instead of positional references in GROUP BY clauses. Blocker \u2718 n/a 3183 Always specify column aliases instead of expressions in GROUP BY clauses. Minor \u2718 n/a 3185 Never use ROWNUM at the same query level as ORDER BY. Blocker \u2718 \u2718 n/a 3190 Avoid using NATURAL JOIN. Blocker \u2718 \u2718 n/a 3195 Always use wildcards in a LIKE clause. Blocker \u2718 30 3210 Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement for more than 4 times. Critical \u2718 n/a 3220 Always process saved exceptions from a FORALL statement. Critical \u2718 \u2718 n/a 3310 Never commit within a cursor loop. Blocker \u2718 \u2718 n/a 3320 Try to move transactions within a non-cursor loop into procedures. Major \u2718 \u2718 \u2718 n/a 3330 Avoid autonomous transactions. Blocker \u2718 \u2718 31 4110 Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data. Minor \u2718 32 4120 Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause. Blocker \u2718 33 4130 Always close locally opened cursors. Blocker \u2718 \u2718 34 4140 Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute. Blocker \u2718 35 4210 Try to use CASE rather than an IF statement with multiple ELSIF paths. Minor \u2718 \u2718 36 4220 Try to use CASE rather than DECODE. Major \u2718 \u2718 37 4230 Always use a COALESCE instead of a NVL command, if parameter 2 of the NVL function is a function call or a SELECT statement. Critical \u2718 \u2718 38 4240 Always use a CASE instead of a NVL2 command if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement. Critical \u2718 \u2718 n/a 4250 Avoid using identical conditions in different branches of the same IF or CASE statement. Blocker \u2718 \u2718 \u2718 n/a 4260 Avoid inverting boolean conditions with NOT. Minor \u2718 \u2718 n/a 4270 Avoid comparing boolean values to boolean literals. Minor \u2718 \u2718 39 4310 Never use GOTO statements in your code. Major \u2718 \u2718 40 4320 Always label your loops. Minor \u2718 n/a 4325 Never reuse labels in inner scopes. Major \u2718 \u2718 \u2718 41 4330 Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations. Major \u2718 42 4340 Always use a NUMERIC FOR loop to process a dense array. Major \u2718 43 4350 Always use 1 as lower and COUNT() as upper bound when looping through a dense array. Blocker \u2718 44 4360 Always use a WHILE loop to process a loose array. Critical \u2718 n/a 4365 Never use unconditional CONTINUE or EXIT in a loop. Major \u2718 \u2718 45 4370 Avoid using EXIT to stop loop processing unless you are in a basic loop. Major \u2718 46 4375 Always use EXIT WHEN instead of an IF statement to exit from a loop. Minor \u2718 47 4380 Try to label your EXIT WHEN statements. Minor \u2718 48 4385 Never use a cursor for loop to check whether a cursor returns data. Critical \u2718 n/a 4387 !!!CHARACTERISTIC ERROR!!! Blocker \u2718 \u2718 49 4390 Avoid use of unreferenced FOR loop indexes. Major \u2718 50 4395 Avoid hard-coded upper or lower bound values with FOR loops. Minor \u2718 \u2718 n/a 5010 Try to use a error/logging framework for your application. Critical \u2718 \u2718 \u2718 51 5020 Never handle unnamed exceptions using the error number. Critical \u2718 52 5030 Never assign predefined exception names to user defined exceptions. Blocker \u2718 \u2718 53 5040 Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers. Critical \u2718 54 n/a Avoid use of EXCEPTION_INIT pragma for a 20nnn error. Major \u2718 55 5050 Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded 20nnn error number or hard-coded message. Major \u2718 \u2718 56 5060 Avoid unhandled exceptions. Major \u2718 57 5070 Avoid using Oracle predefined exceptions. Blocker \u2718 n/a 5080 Always use FORMAT_ERROR_BACKTRACE when using FORMAT_ERROR_STACK or SQLERRM. Critical \u2718 \u2718 58 6010 Always use a character variable to execute dynamic SQL. Major \u2718 \u2718 59 6020 Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause. Minor \u2718 60 7110 Try to use named notation when calling program units. Major \u2718 \u2718 61 7120 Always add the name of the program unit to its end keyword. Minor \u2718 n/a 7125 Always use CREATE OR REPLACE instead of CREATE alone. Major \u2718 62 7130 Always use parameters or pull in definitions rather than referencing external variables in a local program unit. Major \u2718 \u2718 \u2718 63 7140 Always ensure that locally defined procedures or functions are referenced. Major \u2718 \u2718 64 7150 Try to remove unused parameters. Major \u2718 \u2718 68 7160 Always explicitly state parameter mode. Major \u2718 n/a 7170 Avoid using an IN OUT parameter as IN or OUT only. Major \u2718 \u2718 65 7210 Try to keep your packages small. Include only few procedures and functions that are used in the same context. Major \u2718 \u2718 66 7220 Always use forward declaration for private functions and procedures. Minor \u2718 67 7230 Avoid declaring global variables public. Major \u2718 n/a 7250 Never use RETURN in package initialization block. Major \u2718 69 7310 Avoid standalone procedures \u2013 put your procedures in packages. Minor \u2718 70 7320 Avoid using RETURN statements in a PROCEDURE. Major \u2718 \u2718 n/a 7330 Always assign values to OUT parameters. Blocker \u2718 \u2718 71 7410 Avoid standalone functions \u2013 put your functions in packages. Minor \u2718 73 7420 Always make the RETURN statement the last statement of your function. Major \u2718 72 7430 Try to use no more than one RETURN statement within a function. Major \u2718 \u2718 74 7440 Never use OUT parameters to return values from a function. Major \u2718 75 7450 Never return a NULL value from a BOOLEAN function. Blocker \u2718 \u2718 n/a 7460 Try to define your packaged/standalone function deterministic if appropriate. Major \u2718 76 7510 Always prefix Oracle supplied packages with owner schema name. Major \u2718 77 7710 Avoid cascading triggers. Major \u2718 \u2718 n/a 7720 Never use multiple UPDATE OF in trigger event clause. Blocker \u2718 \u2718 \u2718 n/a 7730 Avoid multiple DML events per trigger. Minor \u2718 \u2718 n/a 7740 Never handle multiple DML events per trigger if primary key is assigned in trigger. Critical \u2718 \u2718 n/a 7810 Never use SQL inside PL/SQL to read sequence numbers (or SYSDATE). Critical \u2718 \u2718 n/a 7910 Never use DML within a SQL macro. Blocker \u2718 \u2718 78 8110 Never use SELECT COUNT(*) if you are only interested in the existence of a row. Critical \u2718 n/a 8120 Never check existence of a row to decide whether to create it or not. Critical \u2718 \u2718 79 8210 Always use synonyms when accessing objects of another application schema. Minor \u2718 \u2718 n/a 8310 Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit. Major \u2718 \u2718 \u2718 \u2718 n/a 8410 Always use application locks to ensure a program unit is only running once at a given time. Blocker \u2718 \u2718 n/a 8510 Always use dbms_application_info to track program process transiently. Critical \u2718 \u2718 n/a 9010 Always use a format model in string to date/time conversion functions. Blocker \u2718 \u2718 \u2718 \u2718 \u2718 n/a 9020 Try to use a format model and NLS_NUMERIC_CHARACTERS in string to number conversion functions. Blocker \u2718 \u2718 \u2718 \u2718 \u2718 n/a 9030 Try to define a default value on conversion errors. Major \u2718 \u2718 \u2718 n/a 9040 Try using FX in string to date/time conversion format model to avoid fuzzy conversion. Blocker \u2718 \u2718","title":"Appendix"},{"location":"9-appendix/appendix/#appendix","text":"","title":"Appendix"},{"location":"9-appendix/appendix/#a-plsql-sql-coding-guidelines-as-pdf","text":"These guidelines are primarily produced in HTML using Material for MkDocs . However, we provide these guidelines also as PDF produced by wkhtmltopdf . The formatting is not perfect, but it should be adequate for those who want to work with offline documents.","title":"A - PL/SQL &amp; SQL Coding Guidelines as PDF"},{"location":"9-appendix/appendix/#b-mapping-new-guidelines-to-prior-versions","text":"Old Id New Id Text Severity Change- ability Effi- ciency Maintain- ability Port- ability Reli- ability Reus- ability Secu- rity Test- ability 1 1010 Try to label your sub blocks. Minor \u2718 2 1020 Always have a matching loop or block label. Minor \u2718 3 1030 Avoid defining variables that are not used. Major \u2718 \u2718 4 1040 Avoid dead code. Major \u2718 5 1050 Avoid using literals in your code. Minor \u2718 6 1060 Avoid storing ROWIDs or UROWIDs in database tables. Blocker \u2718 7 1070 Avoid nesting comment blocks. Minor \u2718 n/a 1080 Avoid using the same expression on both sides of a relational comparison operator or a logical operator. Blocker \u2718 \u2718 \u2718 8 2110 Try to use anchored declarations for variables, constants and types. Major \u2718 \u2718 9 2120 Try to have a single location to define your types. Minor \u2718 10 2130 Try to use subtypes for constructs used often in your code. Minor \u2718 n/a 2135 Avoid assigning values to local variables that are not used by a subsequent statement. Major \u2718 \u2718 \u2718 11 2140 Never initialize variables with NULL. Minor \u2718 n/a 2145 Never self-assign a variable. Blocker \u2718 12 2150 Avoid comparisons with NULL value, consider using IS [NOT] NULL. Blocker \u2718 \u2718 13 2160 Avoid initializing variables using functions in the declaration section. Critical \u2718 14 2170 Never overload variables. Major \u2718 15 2180 Never use quoted identifiers. Major \u2718 16 2185 Avoid using overly short names for explicitly or implicitly declared identifiers. Major \u2718 17 2190 Avoid using ROWID or UROWID. Blocker \u2718 \u2718 18 2210 Avoid declaring NUMBER variables, constants or subtypes with no precision. Critical \u2718 19 2220 Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values. Critical \u2718 n/a 2230 Try to use SIMPLE_INTEGER datatype when appropriate. Critical \u2718 20 2310 Avoid using CHAR data type. Blocker \u2718 21 2320 Never use VARCHAR data type. Blocker \u2718 \u2718 22 2330 Never use zero-length strings to substitute NULL. Blocker \u2718 \u2718 23 2340 Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored). Blocker \u2718 24 2410 Try to use boolean data type for values with dual meaning. Minor \u2718 25 2510 Avoid using the LONG and LONG RAW data types. Major \u2718 n/a 2610 Never use self-defined weak ref cursor types. Minor \u2718 \u2718 \u2718 \u2718 26 3110 Always specify the target columns when coding an insert statement. Blocker \u2718 \u2718 n/a 3115 Avoid self-assigning a column. Blocker \u2718 27 3120 Always use table aliases when your SQL statement involves more than one source. Blocker \u2718 28 3130 Try to use ANSI SQL-92 join syntax. Major \u2718 \u2718 29 3140 Try to use anchored records as targets for your cursors. Major \u2718 \u2718 n/a 3145 Avoid using SELECT * directly from a table or view. Blocker \u2718 \u2718 \u2718 \u2718 n/a 3150 Try to use identity columns for surrogate keys. Critical \u2718 \u2718 n/a 3160 Avoid visible virtual columns. Blocker \u2718 \u2718 n/a 3170 Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values. Blocker \u2718 n/a 3180 Always specify column names instead of positional references in ORDER BY clauses. Major \u2718 \u2718 n/a 3182 Always specify column names/aliases instead of positional references in GROUP BY clauses. Blocker \u2718 n/a 3183 Always specify column aliases instead of expressions in GROUP BY clauses. Minor \u2718 n/a 3185 Never use ROWNUM at the same query level as ORDER BY. Blocker \u2718 \u2718 n/a 3190 Avoid using NATURAL JOIN. Blocker \u2718 \u2718 n/a 3195 Always use wildcards in a LIKE clause. Blocker \u2718 30 3210 Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement for more than 4 times. Critical \u2718 n/a 3220 Always process saved exceptions from a FORALL statement. Critical \u2718 \u2718 n/a 3310 Never commit within a cursor loop. Blocker \u2718 \u2718 n/a 3320 Try to move transactions within a non-cursor loop into procedures. Major \u2718 \u2718 \u2718 n/a 3330 Avoid autonomous transactions. Blocker \u2718 \u2718 31 4110 Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data. Minor \u2718 32 4120 Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause. Blocker \u2718 33 4130 Always close locally opened cursors. Blocker \u2718 \u2718 34 4140 Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute. Blocker \u2718 35 4210 Try to use CASE rather than an IF statement with multiple ELSIF paths. Minor \u2718 \u2718 36 4220 Try to use CASE rather than DECODE. Major \u2718 \u2718 37 4230 Always use a COALESCE instead of a NVL command, if parameter 2 of the NVL function is a function call or a SELECT statement. Critical \u2718 \u2718 38 4240 Always use a CASE instead of a NVL2 command if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement. Critical \u2718 \u2718 n/a 4250 Avoid using identical conditions in different branches of the same IF or CASE statement. Blocker \u2718 \u2718 \u2718 n/a 4260 Avoid inverting boolean conditions with NOT. Minor \u2718 \u2718 n/a 4270 Avoid comparing boolean values to boolean literals. Minor \u2718 \u2718 39 4310 Never use GOTO statements in your code. Major \u2718 \u2718 40 4320 Always label your loops. Minor \u2718 n/a 4325 Never reuse labels in inner scopes. Major \u2718 \u2718 \u2718 41 4330 Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations. Major \u2718 42 4340 Always use a NUMERIC FOR loop to process a dense array. Major \u2718 43 4350 Always use 1 as lower and COUNT() as upper bound when looping through a dense array. Blocker \u2718 44 4360 Always use a WHILE loop to process a loose array. Critical \u2718 n/a 4365 Never use unconditional CONTINUE or EXIT in a loop. Major \u2718 \u2718 45 4370 Avoid using EXIT to stop loop processing unless you are in a basic loop. Major \u2718 46 4375 Always use EXIT WHEN instead of an IF statement to exit from a loop. Minor \u2718 47 4380 Try to label your EXIT WHEN statements. Minor \u2718 48 4385 Never use a cursor for loop to check whether a cursor returns data. Critical \u2718 n/a 4387 !!!CHARACTERISTIC ERROR!!! Blocker \u2718 \u2718 49 4390 Avoid use of unreferenced FOR loop indexes. Major \u2718 50 4395 Avoid hard-coded upper or lower bound values with FOR loops. Minor \u2718 \u2718 n/a 5010 Try to use a error/logging framework for your application. Critical \u2718 \u2718 \u2718 51 5020 Never handle unnamed exceptions using the error number. Critical \u2718 52 5030 Never assign predefined exception names to user defined exceptions. Blocker \u2718 \u2718 53 5040 Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers. Critical \u2718 54 n/a Avoid use of EXCEPTION_INIT pragma for a 20nnn error. Major \u2718 55 5050 Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded 20nnn error number or hard-coded message. Major \u2718 \u2718 56 5060 Avoid unhandled exceptions. Major \u2718 57 5070 Avoid using Oracle predefined exceptions. Blocker \u2718 n/a 5080 Always use FORMAT_ERROR_BACKTRACE when using FORMAT_ERROR_STACK or SQLERRM. Critical \u2718 \u2718 58 6010 Always use a character variable to execute dynamic SQL. Major \u2718 \u2718 59 6020 Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause. Minor \u2718 60 7110 Try to use named notation when calling program units. Major \u2718 \u2718 61 7120 Always add the name of the program unit to its end keyword. Minor \u2718 n/a 7125 Always use CREATE OR REPLACE instead of CREATE alone. Major \u2718 62 7130 Always use parameters or pull in definitions rather than referencing external variables in a local program unit. Major \u2718 \u2718 \u2718 63 7140 Always ensure that locally defined procedures or functions are referenced. Major \u2718 \u2718 64 7150 Try to remove unused parameters. Major \u2718 \u2718 68 7160 Always explicitly state parameter mode. Major \u2718 n/a 7170 Avoid using an IN OUT parameter as IN or OUT only. Major \u2718 \u2718 65 7210 Try to keep your packages small. Include only few procedures and functions that are used in the same context. Major \u2718 \u2718 66 7220 Always use forward declaration for private functions and procedures. Minor \u2718 67 7230 Avoid declaring global variables public. Major \u2718 n/a 7250 Never use RETURN in package initialization block. Major \u2718 69 7310 Avoid standalone procedures \u2013 put your procedures in packages. Minor \u2718 70 7320 Avoid using RETURN statements in a PROCEDURE. Major \u2718 \u2718 n/a 7330 Always assign values to OUT parameters. Blocker \u2718 \u2718 71 7410 Avoid standalone functions \u2013 put your functions in packages. Minor \u2718 73 7420 Always make the RETURN statement the last statement of your function. Major \u2718 72 7430 Try to use no more than one RETURN statement within a function. Major \u2718 \u2718 74 7440 Never use OUT parameters to return values from a function. Major \u2718 75 7450 Never return a NULL value from a BOOLEAN function. Blocker \u2718 \u2718 n/a 7460 Try to define your packaged/standalone function deterministic if appropriate. Major \u2718 76 7510 Always prefix Oracle supplied packages with owner schema name. Major \u2718 77 7710 Avoid cascading triggers. Major \u2718 \u2718 n/a 7720 Never use multiple UPDATE OF in trigger event clause. Blocker \u2718 \u2718 \u2718 n/a 7730 Avoid multiple DML events per trigger. Minor \u2718 \u2718 n/a 7740 Never handle multiple DML events per trigger if primary key is assigned in trigger. Critical \u2718 \u2718 n/a 7810 Never use SQL inside PL/SQL to read sequence numbers (or SYSDATE). Critical \u2718 \u2718 n/a 7910 Never use DML within a SQL macro. Blocker \u2718 \u2718 78 8110 Never use SELECT COUNT(*) if you are only interested in the existence of a row. Critical \u2718 n/a 8120 Never check existence of a row to decide whether to create it or not. Critical \u2718 \u2718 79 8210 Always use synonyms when accessing objects of another application schema. Minor \u2718 \u2718 n/a 8310 Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit. Major \u2718 \u2718 \u2718 \u2718 n/a 8410 Always use application locks to ensure a program unit is only running once at a given time. Blocker \u2718 \u2718 n/a 8510 Always use dbms_application_info to track program process transiently. Critical \u2718 \u2718 n/a 9010 Always use a format model in string to date/time conversion functions. Blocker \u2718 \u2718 \u2718 \u2718 \u2718 n/a 9020 Try to use a format model and NLS_NUMERIC_CHARACTERS in string to number conversion functions. Blocker \u2718 \u2718 \u2718 \u2718 \u2718 n/a 9030 Try to define a default value on conversion errors. Major \u2718 \u2718 \u2718 n/a 9040 Try using FX in string to date/time conversion format model to avoid fuzzy conversion. Blocker \u2718 \u2718","title":"B - Mapping new guidelines to prior versions"}]}